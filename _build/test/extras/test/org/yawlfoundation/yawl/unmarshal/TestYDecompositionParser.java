/*
 * Copyright (c) 2004-2025 The YAWL Foundation. All rights reserved.
 * The YAWL Foundation is a collaboration of individuals and
 * organisations who are committed to improving workflow technology.
 *
 * This file is part of YAWL. YAWL is free software: you can
 * redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation.
 *
 * YAWL is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
 * Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General
 * License along with YAWL. If not, see <http://www.gnu.org/licenses/>.
 */

package org.yawlfoundation.yawl.unmarshal;

import static org.junit.jupiter.api.Assertions.*;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.jdom2.JDOMException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.yawlfoundation.yawl.elements.*;
import org.yawlfoundation.yawl.elements.data.YParameter;
import org.yawlfoundation.yawl.elements.data.YVariable;
import org.yawlfoundation.yawl.exceptions.YSchemaBuildingException;
import org.yawlfoundation.yawl.exceptions.YSyntaxException;
import org.yawlfoundation.yawl.schema.YSchemaVersion;
import org.yawlfoundation.yawl.util.StringUtil;

/**
 * Chicago TDD tests for YDecompositionParser.
 *
 * <p>Tests the parsing of YAWL decompositions from XML specification files.
 * Uses real YSpecification objects parsed from actual XML fixtures - no mocks.</p>
 *
 * <h2>Test Coverage</h2>
 * <ul>
 *   <li>Net decomposition parsing (YNet)</li>
 *   <li>Web Service Gateway decomposition parsing (YAWLServiceGateway)</li>
 *   <li>Task element parsing (YAtomicTask, YCompositeTask)</li>
 *   <li>Condition element parsing (YInputCondition, YOutputCondition, YCondition)</li>
 *   <li>Flow/transition element parsing</li>
 *   <li>Split/Join type parsing (AND, OR, XOR)</li>
 *   <li>Multi-instance task attribute parsing</li>
 *   <li>Data variable and parameter parsing</li>
 * </ul>
 *
 * @author Test Suite Generated by Claude
 * @see YDecompositionParser
 * @see YNet
 * @see YAWLServiceGateway
 */
@DisplayName("YDecompositionParser Tests")
@Tag("unit")
class TestYDecompositionParser {

    private YSpecification specification;
    private static final String TEST_SPEC_PATH = "YAWL_Specification.xml";

    @BeforeEach
    void setUp() throws YSyntaxException, IOException, YSchemaBuildingException, JDOMException {
        File specificationFile = new File(YMarshal.class.getResource(TEST_SPEC_PATH).getFile());
        List<YSpecification> specifications = YMarshal.unmarshalSpecifications(
                StringUtil.fileToString(specificationFile.getAbsolutePath()), false);
        specification = specifications.iterator().next();
    }

    @Nested
    @DisplayName("Net Decomposition Parsing")
    class NetDecompositionTests {

        @Test
        @DisplayName("Parse root net decomposition with correct ID")
        void parseRootNetDecomposition() {
            YNet rootNet = specification.getRootNet();
            assertNotNull(rootNet, "Root net should not be null");
            assertEquals("top", rootNet.getID(), "Root net ID should be 'top'");
        }

        @Test
        @DisplayName("Root net should be instance of YNet")
        void rootNetIsYNetInstance() {
            YNet rootNet = specification.getRootNet();
            assertInstanceOf(YNet.class, rootNet, "Root net should be YNet instance");
        }

        @Test
        @DisplayName("Root net has input condition")
        void rootNetHasInputCondition() {
            YNet rootNet = specification.getRootNet();
            YInputCondition inputCondition = rootNet.getInputCondition();
            assertNotNull(inputCondition, "Root net should have input condition");
            assertEquals("i-top", inputCondition.getID(), "Input condition ID should be 'i-top'");
        }

        @Test
        @DisplayName("Root net has output condition")
        void rootNetHasOutputCondition() {
            YNet rootNet = specification.getRootNet();
            YOutputCondition outputCondition = rootNet.getOutputCondition();
            assertNotNull(outputCondition, "Root net should have output condition");
            assertEquals("o-top", outputCondition.getID(), "Output condition ID should be 'o-top'");
        }

        @Test
        @DisplayName("Root net contains expected net elements")
        void rootNetContainsNetElements() {
            YNet rootNet = specification.getRootNet();
            Map<String, YExternalNetElement> netElements = rootNet.getNetElements();

            assertNotNull(netElements, "Net elements map should not be null");
            assertTrue(netElements.size() > 0, "Net should contain net elements");

            // Verify specific elements exist
            assertTrue(netElements.containsKey("i-top"), "Should contain input condition");
            assertTrue(netElements.containsKey("o-top"), "Should contain output condition");
            assertTrue(netElements.containsKey("a-top"), "Should contain task 'a-top'");
        }

        @Test
        @DisplayName("Root net references parent specification")
        void rootNetReferencesSpecification() {
            YNet rootNet = specification.getRootNet();
            assertEquals(specification, rootNet.getSpecification(),
                    "Root net should reference parent specification");
        }
    }

    @Nested
    @DisplayName("Web Service Gateway Decomposition Parsing")
    class WebServiceGatewayTests {

        @Test
        @DisplayName("Parse WebServiceGateway decomposition")
        void parseWebServiceGatewayDecomposition() {
            YDecomposition decompA = specification.getDecomposition("A");
            assertNotNull(decompA, "Decomposition 'A' should exist");
            assertInstanceOf(YAWLServiceGateway.class, decompA,
                    "Decomposition 'A' should be a YAWLServiceGateway");
        }

        @Test
        @DisplayName("WebServiceGateway has correct ID")
        void webServiceGatewayHasCorrectId() {
            YDecomposition decompB = specification.getDecomposition("B");
            assertNotNull(decompB, "Decomposition 'B' should exist");
            assertEquals("B", decompB.getID(), "Decomposition ID should be 'B'");
        }

        @Test
        @DisplayName("Multiple WebServiceGateway decompositions parsed")
        void multipleWebServiceGatewaysParsed() {
            String[] expectedGateways = {"A", "B", "E", "F", "G", "H", "J", "I"};

            for (String gatewayId : expectedGateways) {
                YDecomposition decomp = specification.getDecomposition(gatewayId);
                assertNotNull(decomp, "Decomposition '" + gatewayId + "' should exist");
                assertInstanceOf(YAWLServiceGateway.class, decomp,
                        "Decomposition '" + gatewayId + "' should be YAWLServiceGateway");
            }
        }

        @Test
        @DisplayName("Decomposition references parent specification")
        void decompositionReferencesSpecification() {
            YDecomposition decompA = specification.getDecomposition("A");
            assertEquals(specification, decompA.getSpecification(),
                    "Decomposition should reference parent specification");
        }
    }

    @Nested
    @DisplayName("Task Element Parsing")
    class TaskElementTests {

        @Test
        @DisplayName("Parse atomic task with correct properties")
        void parseAtomicTask() {
            YNet rootNet = specification.getRootNet();
            YExternalNetElement element = rootNet.getNetElement("a-top");

            assertNotNull(element, "Task 'a-top' should exist");
            assertInstanceOf(YAtomicTask.class, element, "Task 'a-top' should be YAtomicTask");
        }

        @Test
        @DisplayName("Task has correct split type")
        void taskHasCorrectSplitType() {
            YNet rootNet = specification.getRootNet();
            YTask taskA = (YTask) rootNet.getNetElement("a-top");

            assertEquals(YTask._OR, taskA.getSplitType(), "Task 'a-top' should have OR split");
        }

        @Test
        @DisplayName("Task has correct join type")
        void taskHasCorrectJoinType() {
            YNet rootNet = specification.getRootNet();
            YTask taskA = (YTask) rootNet.getNetElement("a-top");

            assertEquals(YTask._XOR, taskA.getJoinType(), "Task 'a-top' should have XOR join");
        }

        @Test
        @DisplayName("Task has decomposition reference")
        void taskHasDecompositionReference() {
            YNet rootNet = specification.getRootNet();
            YTask taskA = (YTask) rootNet.getNetElement("a-top");

            YDecomposition decomp = taskA.getDecompositionPrototype();
            assertNotNull(decomp, "Task 'a-top' should have decomposition reference");
            assertEquals("A", decomp.getID(), "Task 'a-top' should decompose to 'A'");
        }

        @Test
        @DisplayName("Task with AND split parsed correctly")
        void taskWithAndSplit() {
            YNet rootNet = specification.getRootNet();
            YTask taskB = (YTask) rootNet.getNetElement("b-top");

            assertEquals(YTask._AND, taskB.getSplitType(), "Task 'b-top' should have AND split");
            assertEquals(YTask._XOR, taskB.getJoinType(), "Task 'b-top' should have XOR join");
        }

        @Test
        @DisplayName("Task with OR join parsed correctly")
        void taskWithOrJoin() {
            YNet rootNet = specification.getRootNet();
            YTask taskD = (YTask) rootNet.getNetElement("d-top");

            assertEquals(YTask._OR, taskD.getJoinType(), "Task 'd-top' should have OR join");
        }
    }

    @Nested
    @DisplayName("Condition Element Parsing")
    class ConditionElementTests {

        @Test
        @DisplayName("Parse intermediate condition")
        void parseIntermediateCondition() {
            YNet rootNet = specification.getRootNet();
            YExternalNetElement element = rootNet.getNetElement("c1-top");

            assertNotNull(element, "Condition 'c1-top' should exist");
            assertInstanceOf(YCondition.class, element, "Element should be YCondition");
        }

        @Test
        @DisplayName("Condition has correct name")
        void conditionHasCorrectName() {
            YNet rootNet = specification.getRootNet();
            YCondition condition = (YCondition) rootNet.getNetElement("c1-top");

            assertEquals("c1", condition.getName(), "Condition name should be 'c1'");
        }

        @Test
        @DisplayName("Input condition has correct name")
        void inputConditionHasCorrectName() {
            YNet rootNet = specification.getRootNet();
            YInputCondition inputCondition = rootNet.getInputCondition();

            assertEquals("i", inputCondition.getName(), "Input condition name should be 'i'");
        }

        @Test
        @DisplayName("Output condition has correct name")
        void outputConditionHasCorrectName() {
            YNet rootNet = specification.getRootNet();
            YOutputCondition outputCondition = rootNet.getOutputCondition();

            assertEquals("o", outputCondition.getName(), "Output condition name should be 'o'");
        }
    }

    @Nested
    @DisplayName("Flow and Transition Parsing")
    class FlowParsingTests {

        @Test
        @DisplayName("Input condition flows to first task")
        void inputConditionFlowsToFirstTask() {
            YNet rootNet = specification.getRootNet();
            YInputCondition inputCondition = rootNet.getInputCondition();

            Set<YExternalNetElement> postsetElements = inputCondition.getPostsetElements();
            assertEquals(1, postsetElements.size(), "Input condition should have one postset element");

            YExternalNetElement nextElement = postsetElements.iterator().next();
            assertEquals("a-top", nextElement.getID(),
                    "Input condition should flow to task 'a-top'");
        }

        @Test
        @DisplayName("Task with OR split has multiple postset flows")
        void taskWithOrSplitHasMultipleFlows() {
            YNet rootNet = specification.getRootNet();
            YTask taskA = (YTask) rootNet.getNetElement("a-top");

            // OR split should have multiple outgoing flows
            Set<YExternalNetElement> postsetElements = taskA.getPostsetElements();
            assertTrue(postsetElements.size() >= 2,
                    "Task 'a-top' with OR split should have multiple postset elements");
        }

        @Test
        @DisplayName("Flow predicates parsed correctly")
        void flowPredicatesParsed() {
            YNet rootNet = specification.getRootNet();
            YTask taskA = (YTask) rootNet.getNetElement("a-top");

            Set<YFlow> flows = taskA.getPostsetFlows();
            assertTrue(flows.size() > 0, "Task 'a-top' should have postset flows");

            // Check that at least one flow has a predicate
            boolean hasPredicate = flows.stream()
                    .anyMatch(flow -> flow.getXpathPredicate() != null);
            assertTrue(hasPredicate, "At least one flow should have a predicate");
        }

        @Test
        @DisplayName("Default flow flag parsed")
        void defaultFlowFlagParsed() {
            YNet rootNet = specification.getRootNet();
            YTask taskA = (YTask) rootNet.getNetElement("a-top");

            Set<YFlow> flows = taskA.getPostsetFlows();
            boolean hasDefaultFlow = flows.stream().anyMatch(YFlow::isDefaultFlow);

            assertTrue(hasDefaultFlow, "Task 'a-top' should have a default flow");
        }
    }

    @Nested
    @DisplayName("Multi-Instance Task Parsing")
    class MultiInstanceTaskTests {

        @Test
        @DisplayName("Multi-instance task parsed with attributes")
        void multiInstanceTaskParsed() {
            YNet rootNet = specification.getRootNet();
            YExternalNetElement element = rootNet.getNetElement("c-top");

            // c-top decomposes to leaf-c (a net), so it's a YCompositeTask
            assertInstanceOf(YCompositeTask.class, element, "Task 'c-top' should be YCompositeTask");
            YTask taskC = (YTask) element;

            assertTrue(taskC.isMultiInstance(), "Task 'c-top' should be multi-instance");
        }

        @Test
        @DisplayName("Multi-instance attributes parsed correctly")
        void multiInstanceAttributesCorrect() {
            YNet rootNet = specification.getRootNet();
            YTask taskC = (YTask) rootNet.getNetElement("c-top");

            YMultiInstanceAttributes miAttrs = taskC.getMultiInstanceAttributes();
            assertNotNull(miAttrs, "Multi-instance attributes should not be null");
            assertEquals(2, miAttrs.getMinInstances(), "Min instances should be 2");
            assertEquals(7, miAttrs.getMaxInstances(), "Max instances should be 7");
            assertEquals(5, miAttrs.getThreshold(), "Threshold should be 5");
        }

        @Test
        @DisplayName("Static multi-instance task parsed")
        void staticMultiInstanceTask() {
            YNet rootNet = specification.getRootNet();
            YTask taskD = (YTask) rootNet.getNetElement("d-top");

            YMultiInstanceAttributes miAttrs = taskD.getMultiInstanceAttributes();
            assertNotNull(miAttrs, "Multi-instance attributes should not be null");

            // d-top has static creation mode
            assertFalse(miAttrs.isDynamicCreationMode(), "Task 'd-top' should have static creation mode");
        }

        @Test
        @DisplayName("Dynamic multi-instance task parsed")
        void dynamicMultiInstanceTask() {
            YNet rootNet = specification.getRootNet();
            YTask taskC = (YTask) rootNet.getNetElement("c-top");

            YMultiInstanceAttributes miAttrs = taskC.getMultiInstanceAttributes();
            assertTrue(miAttrs.isDynamicCreationMode(), "Task 'c-top' should have dynamic creation mode");
        }
    }

    @Nested
    @DisplayName("Nested Net Decomposition Parsing")
    class NestedNetTests {

        @Test
        @DisplayName("Nested net decomposition parsed")
        void nestedNetDecompositionParsed() {
            YDecomposition leafC = specification.getDecomposition("leaf-c");
            assertNotNull(leafC, "Decomposition 'leaf-c' should exist");
            assertInstanceOf(YNet.class, leafC, "Decomposition 'leaf-c' should be YNet");
        }

        @Test
        @DisplayName("Nested net has its own input condition")
        void nestedNetHasInputCondition() {
            YNet leafC = (YNet) specification.getDecomposition("leaf-c");
            YInputCondition inputCondition = leafC.getInputCondition();

            assertNotNull(inputCondition, "Nested net should have input condition");
            assertEquals("i-leaf-c", inputCondition.getID(),
                    "Nested net input condition ID should be 'i-leaf-c'");
        }

        @Test
        @DisplayName("Nested net has its own output condition")
        void nestedNetHasOutputCondition() {
            YNet leafC = (YNet) specification.getDecomposition("leaf-c");
            YOutputCondition outputCondition = leafC.getOutputCondition();

            assertNotNull(outputCondition, "Nested net should have output condition");
            assertEquals("o-leaf-c", outputCondition.getID(),
                    "Nested net output condition ID should be 'o-leaf-c'");
        }

        @Test
        @DisplayName("Nested net contains tasks")
        void nestedNetContainsTasks() {
            YNet leafC = (YNet) specification.getDecomposition("leaf-c");
            Map<String, YExternalNetElement> netElements = leafC.getNetElements();

            assertTrue(netElements.containsKey("e-leaf-c"), "Should contain task 'e-leaf-c'");
            assertTrue(netElements.containsKey("f-leaf-c"), "Should contain task 'f-leaf-c'");
            assertTrue(netElements.containsKey("g-leaf-c"), "Should contain task 'g-leaf-c'");
            assertTrue(netElements.containsKey("h-leaf-c"), "Should contain task 'h-leaf-c'");
        }

        @Test
        @DisplayName("Nested net task decomposes to gateway")
        void nestedNetTaskDecomposesToGateway() {
            YNet leafC = (YNet) specification.getDecomposition("leaf-c");
            YTask taskE = (YTask) leafC.getNetElement("e-leaf-c");

            YDecomposition decomp = taskE.getDecompositionPrototype();
            assertNotNull(decomp, "Task should have decomposition");
            assertEquals("E", decomp.getID(), "Task 'e-leaf-c' should decompose to 'E'");
            assertInstanceOf(YAWLServiceGateway.class, decomp,
                    "Decomposition should be YAWLServiceGateway");
        }
    }

    @Nested
    @DisplayName("Cancellation Region Parsing")
    class CancellationRegionTests {

        @Test
        @DisplayName("Task with remove set parsed")
        void taskWithRemoveSet() {
            YNet rootNet = specification.getRootNet();
            // c-top is YCompositeTask (decomposes to net leaf-c)
            YTask taskC = (YTask) rootNet.getNetElement("c-top");

            // Task c-top has removesTokens for b-top and a-top
            Set<YExternalNetElement> removeSet = taskC.getRemoveSet();
            assertTrue(removeSet.size() >= 2,
                    "Task 'c-top' should have at least 2 elements in remove set");
        }

        @Test
        @DisplayName("Remove set contains correct elements")
        void removeSetContainsCorrectElements() {
            YNet rootNet = specification.getRootNet();
            // c-top is YCompositeTask (decomposes to net leaf-c)
            YTask taskC = (YTask) rootNet.getNetElement("c-top");

            Set<YExternalNetElement> removeSet = taskC.getRemoveSet();
            List<String> removeIds = removeSet.stream()
                    .map(YExternalNetElement::getID)
                    .toList();

            assertTrue(removeIds.contains("b-top") || removeIds.contains("a-top"),
                    "Remove set should contain 'b-top' or 'a-top'");
        }
    }

    @Nested
    @DisplayName("Specification Structure Tests")
    class SpecificationStructureTests {

        @Test
        @DisplayName("All decompositions are accessible")
        void allDecompositionsAccessible() {
            Set<YDecomposition> decompositions = specification.getDecompositions();

            assertNotNull(decompositions, "Decompositions set should not be null");
            assertTrue(decompositions.size() > 0, "Specification should have decompositions");

            // Root net should be accessible
            YDecomposition rootNet = specification.getDecomposition("top");
            assertNotNull(rootNet, "Root net 'top' should be accessible");
        }

        @Test
        @DisplayName("Specification URI is correct")
        void specificationUriCorrect() {
            assertEquals(TEST_SPEC_PATH, specification.getURI(),
                    "Specification URI should match test file name");
        }

        @Test
        @DisplayName("Root net is set in specification")
        void rootNetSetInSpecification() {
            YNet rootNet = specification.getRootNet();
            assertNotNull(rootNet, "Root net should be set");
            assertEquals(rootNet, specification.getDecomposition("top"),
                    "Root net should be accessible via getDecomposition");
        }
    }

    @Nested
    @DisplayName("Edge Cases and Error Handling")
    class EdgeCaseTests {

        @Test
        @DisplayName("Get non-existent decomposition returns null")
        void getNonExistentDecomposition() {
            YDecomposition decomp = specification.getDecomposition("non-existent");
            assertNull(decomp, "Non-existent decomposition should return null");
        }

        @Test
        @DisplayName("Get non-existent net element returns null")
        void getNonExistentNetElement() {
            YNet rootNet = specification.getRootNet();
            YExternalNetElement element = rootNet.getNetElement("non-existent");
            assertNull(element, "Non-existent net element should return null");
        }

        @Test
        @DisplayName("Empty task has no decomposition")
        void taskWithoutDecomposition() {
            // Tasks that don't reference a decomposition should still parse
            YNet rootNet = specification.getRootNet();
            Map<String, YExternalNetElement> elements = rootNet.getNetElements();

            // All tasks should be parsed regardless of decomposition reference
            assertTrue(elements.size() > 0, "Net should contain elements");
        }
    }
}
