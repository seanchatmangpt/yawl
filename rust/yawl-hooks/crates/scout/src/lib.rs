use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;
use std::time::SystemTime;

/// Fetch target configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FetchTarget {
    pub name: String,
    pub url: String,
    pub semantic_unit: String,
    pub watermark_ttl_hours: u64,
}

/// Watermark for fetch optimization
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Watermark {
    pub url: String,
    pub fetched_at_ns: u64,
    pub content_hash: String,
    pub ttl_hours: u64,
}

impl Watermark {
    pub fn is_stale(&self) -> bool {
        let now_ns = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_nanos() as u64;

        let ttl_ns = self.ttl_hours * 3_600_000_000_000;
        now_ns > self.fetched_at_ns + ttl_ns
    }

    pub fn content_changed(&self, new_hash: &str) -> bool {
        self.content_hash != new_hash
    }
}

/// Result of a fetch operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FetchResult {
    pub target_name: String,
    pub success: bool,
    pub new_content: bool,
    pub content: Option<String>,
    pub error: Option<String>,
}

/// Load watermarks from JSON file
pub fn load_watermarks(path: &Path) -> Result<Vec<Watermark>, Box<dyn std::error::Error>> {
    if !path.exists() {
        return Ok(Vec::new());
    }

    let content = fs::read_to_string(path)?;
    let watermarks: Vec<Watermark> = serde_json::from_str(&content)?;
    Ok(watermarks)
}

/// Save watermarks to JSON file
pub fn save_watermarks(
    path: &Path,
    watermarks: &[Watermark],
) -> Result<(), Box<dyn std::error::Error>> {
    let json = serde_json::to_string_pretty(watermarks)?;
    fs::write(path, json)?;
    Ok(())
}

/// Fetch from a single target (simplified for v1)
pub fn fetch_target(target: &FetchTarget, watermark: Option<&Watermark>) -> FetchResult {
    // Check if we should skip based on watermark
    if let Some(wm) = watermark {
        if !wm.is_stale() {
            return FetchResult {
                target_name: target.name.clone(),
                success: true,
                new_content: false,
                content: None,
                error: None,
            };
        }
    }

    // For v1, return skipped - actual HTTP fetching will be done via shell
    // This allows us to validate structure without HTTP library complexity
    FetchResult {
        target_name: target.name.clone(),
        success: true,
        new_content: false,
        content: None,
        error: None,
    }
}

/// Generate live-intelligence.md from fetch results
pub fn generate_intelligence_md(results: &[FetchResult]) -> String {
    let mut md = String::from("# Live Intelligence\n\n");
    md.push_str("*Auto-generated by yawl-scout*\n");
    md.push_str(&format!(
        "**Last updated**: {}\n\n",
        chrono::Local::now().format("%Y-%m-%dT%H:%M:%SZ")
    ));

    for result in results {
        if result.success && result.new_content {
            md.push_str(&format!("## {}\n", result.target_name));
            if let Some(content) = &result.content {
                // Truncate very long content
                let truncated = if content.len() > 500 {
                    format!("{}...\n\n[Content truncated]", &content[..500])
                } else {
                    content.clone()
                };
                md.push_str(&format!("{}\n\n", truncated));
            }
        }
    }

    md
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_watermark_stale() {
        let wm = Watermark {
            url: "https://example.com".to_string(),
            fetched_at_ns: 0,
            content_hash: "abc".to_string(),
            ttl_hours: 24,
        };
        assert!(wm.is_stale());
    }

    #[test]
    fn test_generate_intelligence_md() {
        let result = FetchResult {
            target_name: "test".to_string(),
            success: true,
            new_content: true,
            content: Some("test content".to_string()),
            error: None,
        };
        let md = generate_intelligence_md(&[result]);
        assert!(md.contains("test"));
        assert!(md.contains("test content"));
    }
}
