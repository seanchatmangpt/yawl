use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;
use std::time::SystemTime;

/// Fetch target configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FetchTarget {
    pub name: String,
    pub url: String,
    pub semantic_unit: String,
    pub watermark_ttl_hours: u64,
}

/// Watermark for fetch optimization
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Watermark {
    pub url: String,
    pub fetched_at_ns: u64,
    pub content_hash: String,
    pub ttl_hours: u64,
}

impl Watermark {
    pub fn is_stale(&self) -> bool {
        let now_ns = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap_or_default()
            .as_nanos() as u64;

        let ttl_ns = self.ttl_hours * 3_600_000_000_000;
        now_ns > self.fetched_at_ns + ttl_ns
    }

    pub fn content_changed(&self, new_hash: &str) -> bool {
        self.content_hash != new_hash
    }
}

/// Result of a fetch operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FetchResult {
    pub target_name: String,
    pub success: bool,
    pub new_content: bool,
    pub content: Option<String>,
    pub error: Option<String>,
}

/// Fetch URL using curl as subprocess (fallback approach)
fn fetch_url_via_curl(url: &str) -> Option<String> {
    use std::process::Command;

    let output = Command::new("curl")
        .arg("-s")
        .arg("--max-time")
        .arg("10")
        .arg(url)
        .output()
        .ok()?;

    if output.status.success() {
        String::from_utf8(output.stdout).ok()
    } else {
        None
    }
}

/// Load watermarks from JSON file
pub fn load_watermarks(path: &Path) -> Result<Vec<Watermark>, Box<dyn std::error::Error>> {
    if !path.exists() {
        return Ok(Vec::new());
    }

    let content = fs::read_to_string(path)?;
    let watermarks: Vec<Watermark> = serde_json::from_str(&content)?;
    Ok(watermarks)
}

/// Save watermarks to JSON file
pub fn save_watermarks(
    path: &Path,
    watermarks: &[Watermark],
) -> Result<(), Box<dyn std::error::Error>> {
    let json = serde_json::to_string_pretty(watermarks)?;
    fs::write(path, json)?;
    Ok(())
}

/// Fetch from a single target via HTTP
pub fn fetch_target(target: &FetchTarget, watermark: Option<&Watermark>) -> FetchResult {
    // Check if we should skip based on watermark
    if let Some(wm) = watermark {
        if !wm.is_stale() {
            return FetchResult {
                target_name: target.name.clone(),
                success: true,
                new_content: false,
                content: None,
                error: None,
            };
        }
    }

    // Attempt HTTP fetch with ureqâ€”fallback gracefully
    // ureq Response doesn't provide a simple .text() in all versions
    // So we'll use curl as a subprocess fallback if ureq fails

    let body: Option<String> = fetch_url_via_curl(&target.url);

    if let Some(body) = body {
        // Hash the content
        let hash = blake3::hash(body.as_bytes()).to_hex().to_string();

        // Check if content changed
        let new_content = if let Some(wm) = watermark {
            wm.content_changed(&hash)
        } else {
            true // First fetch
        };

        FetchResult {
            target_name: target.name.clone(),
            success: true,
            new_content,
            content: if new_content { Some(body) } else { None },
            error: None,
        }
    } else {
        FetchResult {
            target_name: target.name.clone(),
            success: false,
            new_content: false,
            content: None,
            error: Some("HTTP fetch failed".to_string()),
        }
    }
}

/// Generate live-intelligence.md from fetch results
pub fn generate_intelligence_md(results: &[FetchResult]) -> String {
    let mut md = String::from("# Live Intelligence\n\n");
    md.push_str("*Auto-generated by yawl-scout*\n");
    md.push_str(&format!(
        "**Last updated**: {}\n\n",
        chrono::Local::now().format("%Y-%m-%dT%H:%M:%SZ")
    ));

    for result in results {
        if result.success && result.new_content {
            md.push_str(&format!("## {}\n", result.target_name));
            if let Some(content) = &result.content {
                // Truncate very long content
                let truncated = if content.len() > 500 {
                    format!("{}...\n\n[Content truncated]", &content[..500])
                } else {
                    content.clone()
                };
                md.push_str(&format!("{}\n\n", truncated));
            }
        }
    }

    md
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_watermark_stale() {
        let wm = Watermark {
            url: "https://example.com".to_string(),
            fetched_at_ns: 0,
            content_hash: "abc".to_string(),
            ttl_hours: 24,
        };
        assert!(wm.is_stale());
    }

    #[test]
    fn test_generate_intelligence_md() {
        let result = FetchResult {
            target_name: "test".to_string(),
            success: true,
            new_content: true,
            content: Some("test content".to_string()),
            error: None,
        };
        let md = generate_intelligence_md(&[result]);
        assert!(md.contains("test"));
        assert!(md.contains("test content"));
    }
}
