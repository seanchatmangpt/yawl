input {
  # TCP input for syslog
  tcp {
    port => 5000
    type => syslog
  }

  # UDP input for syslog
  udp {
    port => 5000
    type => syslog
  }

  # HTTP input
  http {
    port => 8080
    codec => json
  }

  # Beats input for Filebeat, Metricbeat, etc.
  beats {
    port => 5044
  }

  # JDBC input for database queries
  jdbc {
    jdbc_driver_library => "/usr/share/logstash/vendor/jar/mysql-connector-java.jar"
    jdbc_driver_class => "com.mysql.jdbc.Driver"
    jdbc_connection_string => "jdbc:mysql://localhost:3306/mydb"
    jdbc_user => "logstash"
    jdbc_password => "password"
    schedule => "* * * * *"
    statement => "SELECT * FROM logs WHERE created_at > :sql_last_value"
    use_column_value => true
    tracking_column => "created_at"
    last_run_metadata_path => "/usr/share/logstash/data/.logstash_jdbc_last_run"
  }
}

filter {
  if [type] == "syslog" {
    grok {
      match => { "message" => "%{SYSLOGLINE}" }
      add_field => { "[@metadata][index]" => "syslog-%{+YYYY.MM.dd}" }
    }
  }

  if [type] == "http" {
    # Parse JSON if not already parsed
    if ![parsed] {
      json {
        source => "message"
      }
    }
    add_field => { "[@metadata][index]" => "http-logs-%{+YYYY.MM.dd}" }
  }

  if [type] == "application" {
    grok {
      match => { "message" => "%{COMBINEDAPACHELOG}" }
      add_field => { "[@metadata][index]" => "application-%{+YYYY.MM.dd}" }
    }
  }

  # Common filters
  mutate {
    add_field => {
      "[@metadata][version]" => "1.0"
      "environment" => "production"
    }
    remove_field => [ "headers" ]
  }

  # Add timestamp
  date {
    match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
    target => "@timestamp"
  }

  # Geoip enrichment
  geoip {
    source => "clientip"
    target => "geoip"
  }

  # User agent parsing
  user_agent {
    source => "user_agent"
    target => "user_agent_parsed"
  }

  # Remove empty fields
  mutate {
    remove_empty => ["field1", "field2"]
  }

  # Calculate response time statistics
  if [response_time] {
    mutate {
      convert => { "response_time" => "integer" }
      add_field => {
        "slow_query" => false
      }
    }
    if [response_time] > 1000 {
      mutate {
        replace => { "slow_query" => true }
        add_tag => [ "slow" ]
      }
    }
  }

  # Error classification
  if [status] >= 400 {
    mutate {
      add_tag => [ "error" ]
    }
    if [status] >= 500 {
      mutate {
        add_tag => [ "server_error" ]
      }
    }
  }
}

output {
  # Output to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    user => "elastic"
    password => "${ELASTIC_PASSWORD}"
    index => "%{[@metadata][index]}"
    document_id => "%{[@metadata][fingerprint]}"
    action => "index"
    ecs_compatibility => "disabled"
    retry_on_conflict => 1
  }

  # Console output for debugging (disabled in production)
  if [@metadata][debug] {
    stdout {
      codec => json
    }
  }

  # Conditional outputs
  if "error" in [tags] {
    email {
      to => "alerts@example.com"
      subject => "Error detected in application logs"
      body => "Error: %{message}"
    }
  }

  if "slow" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      user => "elastic"
      password => "${ELASTIC_PASSWORD}"
      index => "slow-queries-%{+YYYY.MM.dd}"
    }
  }
}
