/**
 * Generated by ggen from YAWL SHACL Shapes v6.0.0
 * Source: yawl-shapes.ttl
 * Generated: {{ generated.timestamp }}
 *
 * DO NOT EDIT - Changes will be overwritten on next generation
 */
package {{ java_package }}.validation;

import org.yawlfoundation.yawl.generated.annotation.Generated;
import org.yawlfoundation.yawl.generated.YawlElement;
import javax.annotation.Nonnull;
import java.util.*;
import java.util.regex.Pattern;

/**
 * SHACL Validator for {{ shape.label | default(value=shape.name) }}
 *
 * {% if shape.comment -%}
 * <p>
 * {{ shape.comment }}
 * </p>
 * {% endif -%}
 *
 * SHACL NodeShape: <code>{{ shape.uri }}</code><br>
 * Target Class: <code>{{ shape.target_class }}</code>
 *
 * <p>
 * <strong>Validation Rules:</strong>
 * <ul>
 * {% for constraint in shape.constraints -%}
 * <li>{{ constraint.description }}</li>
 * {% endfor -%}
 * </ul>
 * </p>
 *
 * @author YAWL Foundation
 * @version {{ generated.version }}
 * @since 6.0.0
 */
@Generated(
    value = "org.yawlfoundation.ggen.CodeGenerator",
    date = "{{ generated.timestamp }}",
    comments = "Generated from SHACL shape: {{ shape.uri }}"
)
public class {{ shape.name | pascalcase }}Validator {

    // SHACL shape metadata
    public static final String SHAPE_URI = "{{ shape.uri }}";
    public static final String TARGET_CLASS = "{{ shape.target_class }}";
    public static final String SHAPE_SEVERITY = "{{ shape.severity | default(value="violation") }}";

    // Compiled regex patterns for validation
{% for constraint in shape.constraints -%}
{% if constraint.pattern -%}
    private static final Pattern PATTERN_{{ constraint.property | upper | replace("-", "_") }} =
        Pattern.compile("{{ constraint.pattern }}");
{% endif -%}
{% endfor -%}

    /**
     * Validate an element against SHACL constraints
     *
     * @param element the element to validate
     * @return ValidationResult with details of any violations
     */
    @Nonnull
    public static ValidationResult validate(@Nonnull YawlElement element) {
        ValidationResult result = new ValidationResult();

{% for constraint in shape.constraints -%}
        // {{ constraint.description }}
        validateConstraint_{{ constraint.property | snakecase }}(element, result);

{% endfor -%}
        return result;
    }

{% for constraint in shape.constraints -%}
    /**
     * Validate: {{ constraint.description }}
     *
     * SHACL Path: {{ constraint.property }}<br>
     * Constraint: {{ constraint.constraint_type }}
     *
     * @param element the element to validate
     * @param result the result accumulator
     */
    private static void validateConstraint_{{ constraint.property | snakecase }}(
        @Nonnull YawlElement element,
        @Nonnull ValidationResult result
    ) {
        try {
            {% if constraint.constraint_type == "minCount" -%}
            // sh:minCount {{ constraint.min_count }}
            Object value = element.getProperty("{{ constraint.property }}");
            int count = (value instanceof Collection) ? ((Collection<?>) value).size() : (value != null ? 1 : 0);
            if (count < {{ constraint.min_count }}) {
                result.addViolation(
                    new ShaclViolation(
                        SHAPE_URI,
                        "{{ constraint.property }}",
                        "{{ constraint.message | default(value='Minimum count violation') }}",
                        SHAPE_SEVERITY
                    )
                );
            }

            {% elif constraint.constraint_type == "maxCount" -%}
            // sh:maxCount {{ constraint.max_count }}
            Object value = element.getProperty("{{ constraint.property }}");
            int count = (value instanceof Collection) ? ((Collection<?>) value).size() : (value != null ? 1 : 0);
            if (count > {{ constraint.max_count }}) {
                result.addViolation(
                    new ShaclViolation(
                        SHAPE_URI,
                        "{{ constraint.property }}",
                        "{{ constraint.message | default(value='Maximum count violation') }}",
                        SHAPE_SEVERITY
                    )
                );
            }

            {% elif constraint.constraint_type == "datatype" -%}
            // sh:datatype {{ constraint.datatype }}
            Object value = element.getProperty("{{ constraint.property }}");
            if (value != null && !isValidDatatype(value, "{{ constraint.datatype }}")) {
                result.addViolation(
                    new ShaclViolation(
                        SHAPE_URI,
                        "{{ constraint.property }}",
                        "{{ constraint.message | default(value='Datatype violation') }}",
                        SHAPE_SEVERITY
                    )
                );
            }

            {% elif constraint.constraint_type == "pattern" -%}
            // sh:pattern "{{ constraint.pattern }}"
            Object value = element.getProperty("{{ constraint.property }}");
            if (value instanceof String) {
                if (!PATTERN_{{ constraint.property | upper | replace("-", "_") }}.matcher((String) value).matches()) {
                    result.addViolation(
                        new ShaclViolation(
                            SHAPE_URI,
                            "{{ constraint.property }}",
                            "{{ constraint.message | default(value='Pattern violation') }}",
                            SHAPE_SEVERITY
                        )
                    );
                }
            }

            {% elif constraint.constraint_type == "minLength" -%}
            // sh:minLength {{ constraint.min_length }}
            Object value = element.getProperty("{{ constraint.property }}");
            if (value instanceof String) {
                if (((String) value).length() < {{ constraint.min_length }}) {
                    result.addViolation(
                        new ShaclViolation(
                            SHAPE_URI,
                            "{{ constraint.property }}",
                            "{{ constraint.message | default(value='Minimum length violation') }}",
                            SHAPE_SEVERITY
                        )
                    );
                }
            }

            {% elif constraint.constraint_type == "maxLength" -%}
            // sh:maxLength {{ constraint.max_length }}
            Object value = element.getProperty("{{ constraint.property }}");
            if (value instanceof String) {
                if (((String) value).length() > {{ constraint.max_length }}) {
                    result.addViolation(
                        new ShaclViolation(
                            SHAPE_URI,
                            "{{ constraint.property }}",
                            "{{ constraint.message | default(value='Maximum length violation') }}",
                            SHAPE_SEVERITY
                        )
                    );
                }
            }

            {% elif constraint.constraint_type == "class" -%}
            // sh:class {{ constraint.class }}
            Object value = element.getProperty("{{ constraint.property }}");
            if (value instanceof YawlElement) {
                YawlElement elem = (YawlElement) value;
                if (!elem.getRdfType().equals("{{ constraint.class }}")) {
                    result.addViolation(
                        new ShaclViolation(
                            SHAPE_URI,
                            "{{ constraint.property }}",
                            "{{ constraint.message | default(value='Class violation') }}",
                            SHAPE_SEVERITY
                        )
                    );
                }
            }

            {% elif constraint.constraint_type == "minInclusive" -%}
            // sh:minInclusive {{ constraint.min_inclusive }}
            Object value = element.getProperty("{{ constraint.property }}");
            if (value instanceof Number) {
                if (((Number) value).doubleValue() < {{ constraint.min_inclusive }}) {
                    result.addViolation(
                        new ShaclViolation(
                            SHAPE_URI,
                            "{{ constraint.property }}",
                            "{{ constraint.message | default(value='Minimum inclusive violation') }}",
                            SHAPE_SEVERITY
                        )
                    );
                }
            }

            {% elif constraint.constraint_type == "maxInclusive" -%}
            // sh:maxInclusive {{ constraint.max_inclusive }}
            Object value = element.getProperty("{{ constraint.property }}");
            if (value instanceof Number) {
                if (((Number) value).doubleValue() > {{ constraint.max_inclusive }}) {
                    result.addViolation(
                        new ShaclViolation(
                            SHAPE_URI,
                            "{{ constraint.property }}",
                            "{{ constraint.message | default(value='Maximum inclusive violation') }}",
                            SHAPE_SEVERITY
                        )
                    );
                }
            }
            {% endif -%}
        } catch (Exception e) {
            result.addViolation(
                new ShaclViolation(
                    SHAPE_URI,
                    "{{ constraint.property }}",
                    "Validation error: " + e.getMessage(),
                    "error"
                )
            );
        }
    }

{% endfor -%}

    /**
     * Check if value matches expected datatype
     *
     * @param value the value to check
     * @param datatype the expected XSD datatype
     * @return true if value matches datatype
     */
    private static boolean isValidDatatype(Object value, String datatype) {
        return switch (datatype) {
            case "http://www.w3.org/2001/XMLSchema#string" ->
                value instanceof String;
            case "http://www.w3.org/2001/XMLSchema#boolean" ->
                value instanceof Boolean;
            case "http://www.w3.org/2001/XMLSchema#integer",
                 "http://www.w3.org/2001/XMLSchema#long",
                 "http://www.w3.org/2001/XMLSchema#int" ->
                value instanceof Integer || value instanceof Long;
            case "http://www.w3.org/2001/XMLSchema#decimal",
                 "http://www.w3.org/2001/XMLSchema#double",
                 "http://www.w3.org/2001/XMLSchema#float" ->
                value instanceof Number;
            case "http://www.w3.org/2001/XMLSchema#date",
                 "http://www.w3.org/2001/XMLSchema#dateTime" ->
                value instanceof java.util.Date || value instanceof String;
            default -> true; // Allow unknown datatypes
        };
    }

    /**
     * SHACL Validation Result
     */
    public static class ValidationResult {
        private final List<ShaclViolation> violations = new ArrayList<>();
        private boolean valid = true;

        public void addViolation(ShaclViolation violation) {
            violations.add(violation);
            valid = false;
        }

        public boolean isValid() {
            return valid;
        }

        public List<ShaclViolation> getViolations() {
            return Collections.unmodifiableList(violations);
        }

        public int getViolationCount() {
            return violations.size();
        }

        @Override
        public String toString() {
            if (valid) {
                return "ValidationResult{valid=true}";
            }
            StringBuilder sb = new StringBuilder("ValidationResult{violations=[");
            for (int i = 0; i < violations.size(); i++) {
                sb.append(violations.get(i));
                if (i < violations.size() - 1) sb.append(", ");
            }
            sb.append("]}");
            return sb.toString();
        }
    }

    /**
     * SHACL Validation Violation
     */
    public static class ShaclViolation {
        private final String shape;
        private final String property;
        private final String message;
        private final String severity;

        public ShaclViolation(String shape, String property, String message, String severity) {
            this.shape = shape;
            this.property = property;
            this.message = message;
            this.severity = severity;
        }

        public String getShape() { return shape; }
        public String getProperty() { return property; }
        public String getMessage() { return message; }
        public String getSeverity() { return severity; }

        @Override
        public String toString() {
            return String.format("[%s] %s.%s: %s", severity, shape, property, message);
        }
    }
}
