/**
 * Generated by ggen from YAWL OWL 2 DL Ontology v6.0.0
 * Source: yawl-ontology.ttl
 * Generated: {{ generated.timestamp }}
 *
 * DO NOT EDIT - Changes will be overwritten on next generation
 */
package {{ java_package }}.constraints;

import org.yawlfoundation.yawl.generated.annotation.Generated;
import javax.annotation.Nonnull;
import java.util.*;

/**
 * Cardinality Constraint for property: {{ property.name }}
 *
 * <p>
 * Defines the allowed cardinality (number of values) for the property
 * <code>{{ property.uri }}</code> on domain classes:
 * {% for domain in property.domain %}
 *   - {{ domain }}<br>
 * {% endfor %}
 * </p>
 *
 * <p>
 * <strong>Cardinality Constraints:</strong><br>
 * Minimum: {% if property.min_cardinality is not null %}{{ property.min_cardinality }}{% else %}0 (unbounded){% endif %}<br>
 * Maximum: {% if property.max_cardinality is not null %}{{ property.max_cardinality }}{% else %}unbounded{% endif %}<br>
 * </p>
 *
 * {% if property.functional -%}
 * <p>
 * <strong>Note:</strong> This is a functional property (max cardinality = 1).
 * Each domain instance has at most one value.
 * </p>
 * {% endif -%}
 *
 * @author YAWL Foundation
 * @version {{ generated.version }}
 * @since 6.0.0
 */
@Generated(
    value = "org.yawlfoundation.ggen.CodeGenerator",
    date = "{{ generated.timestamp }}",
    comments = "Cardinality constraint from property: {{ property.uri }}"
)
public enum {{ property.name | pascalcase }}Constraint {
    /**
     * No constraint (0..*): zero or more values allowed
     */
    UNBOUNDED(null, null),

    /**
     * Exactly one (1..1): one value required
     * Applies to mandatory, functional properties
     */
    REQUIRED(1, 1),

    /**
     * At most one (0..1): optional, functional property
     */
    OPTIONAL(0, 1),

    /**
     * One or more (1..*): at least one value required
     */
    ONE_OR_MORE(1, null),

    {%- if property.min_cardinality is not null and property.max_cardinality is not null %}

    /**
     * Fixed range ({{ property.min_cardinality }}..{{ property.max_cardinality }})
     */
    FIXED_RANGE({{ property.min_cardinality }}, {{ property.max_cardinality }}),
    {%- endif %}

    {%- if property.min_cardinality is not null and property.max_cardinality is null %}

    /**
     * Minimum {{ property.min_cardinality }} ({{ property.min_cardinality }}..*): at least {{ property.min_cardinality }} values
     */
    MIN_{{ property.min_cardinality }}({{ property.min_cardinality }}, null),
    {%- endif %}

    {%- if property.min_cardinality is null and property.max_cardinality is not null %}

    /**
     * Maximum {{ property.max_cardinality }} (0..{{ property.max_cardinality }}): at most {{ property.max_cardinality }} values
     */
    MAX_{{ property.max_cardinality }}(null, {{ property.max_cardinality }}),
    {%- endif %};

    private final Integer minCardinality;
    private final Integer maxCardinality;

    /**
     * Create a cardinality constraint
     *
     * @param minCardinality minimum number of values (null = 0)
     * @param maxCardinality maximum number of values (null = unbounded)
     */
    {{ property.name | pascalcase }}Constraint(Integer minCardinality, Integer maxCardinality) {
        this.minCardinality = minCardinality;
        this.maxCardinality = maxCardinality;
    }

    /**
     * Get the minimum cardinality for this constraint
     *
     * @return minimum cardinality (null if 0)
     */
    public Integer getMinCardinality() {
        return minCardinality;
    }

    /**
     * Get the actual minimum cardinality value (0 if null)
     *
     * @return minimum cardinality as integer
     */
    public int getMinCardinalityValue() {
        return minCardinality != null ? minCardinality : 0;
    }

    /**
     * Get the maximum cardinality for this constraint
     *
     * @return maximum cardinality (null if unbounded)
     */
    public Integer getMaxCardinality() {
        return maxCardinality;
    }

    /**
     * Check if the cardinality is bounded (has both min and max)
     *
     * @return true if both bounds are specified
     */
    public boolean isBounded() {
        return minCardinality != null && maxCardinality != null;
    }

    /**
     * Check if a collection satisfies this cardinality constraint
     *
     * @param values the collection to validate
     * @return true if collection size satisfies constraint
     */
    public boolean validates(@Nonnull Collection<?> values) {
        int size = values.size();
        return validates(size);
    }

    /**
     * Check if a specific cardinality value satisfies this constraint
     *
     * @param cardinality the number of values
     * @return true if cardinality satisfies constraint
     */
    public boolean validates(int cardinality) {
        if (minCardinality != null && cardinality < minCardinality) {
            return false;
        }
        if (maxCardinality != null && cardinality > maxCardinality) {
            return false;
        }
        return true;
    }

    /**
     * Get a human-readable description of this constraint
     *
     * @return constraint description (e.g., "0..1", "1..*", "1..1")
     */
    public String getDescription() {
        int min = getMinCardinalityValue();
        String max = maxCardinality == null ? "*" : maxCardinality.toString();
        return min + ".." + max;
    }

    /**
     * Get the constraint that matches the actual cardinality from ontology
     *
     * @return the applicable constraint, or UNBOUNDED if ontology specifies no limits
     */
    public static {{ property.name | pascalcase }}Constraint getOntologyConstraint() {
        {%- if property.min_cardinality is not null or property.max_cardinality is not null %}
        // From ontology yawl-ontology.ttl:
        // Property {{ property.uri }}
        {%- if property.min_cardinality is not null %}
        // minCardinality: {{ property.min_cardinality }}
        {%- endif %}
        {%- if property.max_cardinality is not null %}
        // maxCardinality: {{ property.max_cardinality }}
        {%- endif %}
        {%- endif %}

        {%- if property.functional %}
        // Functional property: max cardinality = 1
        if (minCardinality == 1 && maxCardinality == 1) {
            return REQUIRED;
        }
        {%- endif %}

        {%- if property.min_cardinality == 1 and property.max_cardinality == 1 %}
        return REQUIRED; // exactly 1
        {%- else if property.min_cardinality == 0 and property.max_cardinality == 1 %}
        return OPTIONAL; // 0 or 1
        {%- else if property.min_cardinality == 1 and property.max_cardinality is null %}
        return ONE_OR_MORE; // 1 or more
        {%- else if property.min_cardinality == 0 and property.max_cardinality is null %}
        return UNBOUNDED; // 0 or more
        {%- else if property.min_cardinality is not null and property.max_cardinality is not null %}
        return FIXED_RANGE; // {{ property.min_cardinality }}..{{ property.max_cardinality }}
        {%- else if property.min_cardinality is not null %}
        return MIN_{{ property.min_cardinality }}; // {{ property.min_cardinality }} or more
        {%- else if property.max_cardinality is not null %}
        return MAX_{{ property.max_cardinality }}; // at most {{ property.max_cardinality }}
        {%- else %}
        return UNBOUNDED; // default: no constraints
        {%- endif %}
    }

    /**
     * Get error message for a cardinality violation
     *
     * @param actualCardinality the actual number of values
     * @return error message describing the violation
     */
    public String getViolationMessage(int actualCardinality) {
        return String.format(
            "Cardinality constraint violated for property '{{ property.name }}'. " +
            "Expected %s, but got %d value(s).",
            getDescription(),
            actualCardinality
        );
    }
}
