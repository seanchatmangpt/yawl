/**
 * Generated by ggen from YAWL OWL 2 DL Ontology v6.0.0
 * Source: yawl-ontology.ttl
 * Generated: {{ generated.timestamp }}
 *
 * DO NOT EDIT - Changes will be overwritten on next generation
 */
package {{ java_package }}.properties;

import org.yawlfoundation.yawl.generated.annotation.Generated;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.lang.reflect.Field;
import java.util.*;

/**
 * Property Descriptor for: {{ property.name }}
 *
 * <p>
 * <strong>OWL Property:</strong> {{ property.uri }}<br>
 * <strong>Type:</strong> {{ property.property_type }}<br>
 * <strong>Domain:</strong> {{ property.domain | join(sep=", ") }}<br>
 * <strong>Range:</strong> {{ property.range }}
 * </p>
 *
 * {% if property.comment -%}
 * <p>
 * {{ property.comment }}
 * </p>
 * {% endif -%}
 *
 * {% if property.min_cardinality is not null or property.max_cardinality is not null -%}
 * <p>
 * <strong>Cardinality:</strong>
 * {% if property.min_cardinality is not null -%}
 * min={{ property.min_cardinality }}
 * {% endif -%}
 * {% if property.max_cardinality is not null -%}
 * max={{ property.max_cardinality }}
 * {% endif -%}
 * </p>
 * {% endif -%}
 *
 * {% if property.functional -%}
 * <p><strong>Functional Property:</strong> Each domain instance has at most one value</p>
 * {% endif -%}
 *
 * {% if property.inverse_functional -%}
 * <p><strong>Inverse Functional Property:</strong> Each range value has at most one domain instance</p>
 * {% endif -%}
 *
 * @author YAWL Foundation
 * @version {{ generated.version }}
 * @since 6.0.0
 */
@Generated(
    value = "org.yawlfoundation.ggen.CodeGenerator",
    date = "{{ generated.timestamp }}",
    comments = "Generated from ontology property: {{ property.uri }}"
)
public class {{ property.name | pascalcase }}Descriptor {

    // OWL Property URI
    public static final String PROPERTY_URI = "{{ property.uri }}";

    // Property metadata
    public static final String PROPERTY_NAME = "{{ property.name }}";
    public static final String PROPERTY_LABEL = "{{ property.label | default(value=property.name) }}";
    public static final String PROPERTY_COMMENT = "{{ property.comment | default(value="") }}";

    // Domain and range information
    public static final String[] DOMAIN_CLASSES = {
{% for domain in property.domain -%}
        "{{ domain }}"{{ if not loop.last }},{{ endif }}
{% endfor -%}
    };

    public static final String RANGE_CLASS = "{{ property.range }}";

    // Cardinality constraints
    public static final Integer MIN_CARDINALITY = {% if property.min_cardinality is not null %}{{ property.min_cardinality }}{% else %}null{% endif %};
    public static final Integer MAX_CARDINALITY = {% if property.max_cardinality is not null %}{{ property.max_cardinality }}{% else %}null{% endif %};

    // Property characteristics
    public static final boolean IS_FUNCTIONAL = {{ property.functional | default(value="false") }};
    public static final boolean IS_INVERSE_FUNCTIONAL = {{ property.inverse_functional | default(value="false") }};
    public static final boolean IS_TRANSITIVE = {{ property.transitive | default(value="false") }};
    public static final boolean IS_SYMMETRIC = {{ property.symmetric | default(value="false") }};
    public static final boolean IS_ASYMMETRIC = {{ property.asymmetric | default(value="false") }};
    public static final boolean IS_REFLEXIVE = {{ property.reflexive | default(value="false") }};
    public static final boolean IS_IRREFLEXIVE = {{ property.irreflexive | default(value="false") }};

    {%- if property.inverse_property %}

    // Inverse property
    public static final String INVERSE_PROPERTY_URI = "{{ property.inverse_property.uri }}";
    public static final String INVERSE_PROPERTY_NAME = "{{ property.inverse_property.name }}";
    {%- endif %}

    /**
     * Get the OWL property URI
     *
     * @return the property URI
     */
    public static String getPropertyUri() {
        return PROPERTY_URI;
    }

    /**
     * Get the property name
     *
     * @return the property name
     */
    public static String getPropertyName() {
        return PROPERTY_NAME;
    }

    /**
     * Get the property label/display name
     *
     * @return the human-readable label
     */
    public static String getPropertyLabel() {
        return PROPERTY_LABEL;
    }

    /**
     * Get the property description
     *
     * @return the comment/description
     */
    public static String getPropertyComment() {
        return PROPERTY_COMMENT;
    }

    /**
     * Get all domain classes for this property
     *
     * @return array of domain class URIs
     */
    public static String[] getDomainClasses() {
        return DOMAIN_CLASSES.clone();
    }

    /**
     * Get the range class for this property
     *
     * @return the range class URI
     */
    public static String getRangeClass() {
        return RANGE_CLASS;
    }

    /**
     * Check if this property is functional (at most one value per domain)
     *
     * @return true if functional
     */
    public static boolean isFunctional() {
        return IS_FUNCTIONAL;
    }

    /**
     * Check if this property is inverse functional (at most one domain per value)
     *
     * @return true if inverse functional
     */
    public static boolean isInverseFunctional() {
        return IS_INVERSE_FUNCTIONAL;
    }

    /**
     * Validate cardinality constraints for a collection of values
     *
     * @param values the values to check
     * @return true if cardinality constraints are satisfied
     */
    public static boolean validateCardinality(@Nullable Collection<?> values) {
        if (values == null) {
            return MIN_CARDINALITY == null || MIN_CARDINALITY == 0;
        }

        int count = values.size();

        if (MIN_CARDINALITY != null && count < MIN_CARDINALITY) {
            return false;
        }

        if (MAX_CARDINALITY != null && count > MAX_CARDINALITY) {
            return false;
        }

        if (IS_FUNCTIONAL && count > 1) {
            return false;
        }

        return true;
    }

    /**
     * Get a validator for this property
     *
     * @return a property validator instance
     */
    public static PropertyValidator getValidator() {
        return new PropertyValidator();
    }

    /**
     * Validator class for this property
     */
    public static class PropertyValidator {

        /**
         * Validate that value conforms to property constraints
         *
         * @param value the value to validate
         * @return true if valid
         * @throws IllegalArgumentException if value is invalid
         */
        public boolean validate(@Nullable Object value) {
            if (value == null) {
                if (MIN_CARDINALITY != null && MIN_CARDINALITY > 0) {
                    throw new IllegalArgumentException(
                        "Property " + PROPERTY_NAME + " is required (min cardinality: " + MIN_CARDINALITY + ")"
                    );
                }
                return true;
            }

            // Check value type
            if (value instanceof Collection) {
                Collection<?> values = (Collection<?>) value;
                if (!validateCardinality(values)) {
                    throw new IllegalArgumentException(
                        "Property " + PROPERTY_NAME + " has invalid cardinality: " + values.size() +
                        " (min: " + MIN_CARDINALITY + ", max: " + MAX_CARDINALITY + ")"
                    );
                }
            } else if (IS_FUNCTIONAL) {
                // Single value is OK for functional properties
            }

            return true;
        }

        /**
         * Check if a value belongs to the range class
         *
         * @param value the value to check
         * @return true if value is in range
         */
        public boolean isInRange(@Nonnull Object value) {
            // This would typically check against an ontology reasoner
            // For now, basic type checking
            return value != null;
        }
    }

    /**
     * Get all property metadata as a map
     *
     * @return metadata map
     */
    public static Map<String, Object> getMetadata() {
        Map<String, Object> meta = new LinkedHashMap<>();
        meta.put("uri", PROPERTY_URI);
        meta.put("name", PROPERTY_NAME);
        meta.put("label", PROPERTY_LABEL);
        meta.put("comment", PROPERTY_COMMENT);
        meta.put("domain", DOMAIN_CLASSES);
        meta.put("range", RANGE_CLASS);
        meta.put("minCardinality", MIN_CARDINALITY);
        meta.put("maxCardinality", MAX_CARDINALITY);
        meta.put("functional", IS_FUNCTIONAL);
        meta.put("inverseFunctional", IS_INVERSE_FUNCTIONAL);
        return Collections.unmodifiableMap(meta);
    }

    /**
     * Private constructor to prevent instantiation
     */
    private {{ property.name | pascalcase }}Descriptor() {
        // Static utility class
    }
}
