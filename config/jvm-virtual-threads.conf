# YAWL Engine JVM Configuration for Virtual Threads (Java 21)
#
# This configuration file contains optimized JVM flags for running YAWL with
# virtual threads enabled. Apply these flags to your Tomcat or standalone
# Java process.
#
# Version: 5.2
# Date: 2026-02-16
# Java: 21 LTS

# =============================================================================
# VIRTUAL THREAD CONFIGURATION
# =============================================================================

# Virtual thread stack size (default 1MB, reduced to 256KB for efficiency)
# Reduces memory overhead for high concurrency scenarios
-XX:VirtualThreadStackSize=256k

# Enable full stack traces for pinned virtual threads (development/debugging)
# Remove or set to 'short' in production
-Djdk.tracePinnedThreads=full

# =============================================================================
# GARBAGE COLLECTOR CONFIGURATION
# =============================================================================

# Use G1GC (recommended for virtual threads)
# G1GC handles large heaps efficiently and works well with virtual thread workloads
-XX:+UseG1GC

# Unlock experimental VM options (required for some G1GC tuning)
-XX:+UnlockExperimentalVMOptions

# G1GC young generation size (30% of heap recommended for virtual threads)
# Balances throughput and pause times for I/O-heavy workloads
-XX:G1NewCollectionHeapPercent=30

# G1GC pause time target (default 200ms, adjust based on requirements)
-XX:MaxGCPauseMillis=200

# =============================================================================
# HEAP CONFIGURATION
# =============================================================================

# Initial heap size (adjust based on workload)
# Virtual threads reduce heap pressure compared to platform threads
-Xms2g

# Maximum heap size (adjust based on workload)
# Rule of thumb: Same as platform threads (virtual threads don't require more)
-Xmx4g

# Metaspace size (for class metadata)
-XX:MetaspaceSize=256m
-XX:MaxMetaspaceSize=512m

# =============================================================================
# MONITORING & DIAGNOSTICS
# =============================================================================

# Enable Java Flight Recorder (production-safe, low overhead <1%)
# Captures virtual thread events for analysis
-XX:StartFlightRecording=filename=/var/log/yawl/vthreads.jfr,settings=profile,dumponexit=true,maxsize=500M

# JFR event settings (optional, for fine-tuned monitoring)
# -XX:FlightRecorderOptions=stackdepth=256

# GC logging (for performance analysis)
-Xlog:gc*:file=/var/log/yawl/gc.log:time,uptime,level,tags:filecount=5,filesize=10M

# Print virtual thread statistics on exit (development only)
# -XX:+PrintVirtualThreadStatistics

# =============================================================================
# PERFORMANCE TUNING
# =============================================================================

# Use large pages for heap (if supported by OS)
# Improves performance for large heaps
# -XX:+UseLargePages

# String deduplication (saves memory in high-concurrency scenarios)
-XX:+UseStringDeduplication

# Compressed OOPs (enabled by default, explicitly set for clarity)
-XX:+UseCompressedOops
-XX:+UseCompressedClassPointers

# =============================================================================
# CARRIER THREAD POOL CONFIGURATION
# =============================================================================

# Carrier thread pool size (defaults to CPU core count)
# Usually no tuning needed, but can be set explicitly:
# -Djdk.virtualThreadScheduler.parallelism=32
# -Djdk.virtualThreadScheduler.maxPoolSize=256

# Note: Only tune carrier pool if JFR shows carrier thread starvation
# For most workloads, default (CPU count) is optimal

# =============================================================================
# APPLICATION-SPECIFIC FLAGS
# =============================================================================

# YAWL engine properties
-Dyawl.logging.level=INFO
-Dhibernate.logging.level=WARN

# Database connection pool (HikariCP)
# Keep pool size reasonable (virtual threads don't change DB connection requirements)
-Dhikari.maximum-pool-size=50
-Dhikari.minimum-idle=10

# =============================================================================
# SECURITY FLAGS (OPTIONAL)
# =============================================================================

# Enable security manager (if required)
# -Djava.security.manager
# -Djava.security.policy=/path/to/security.policy

# =============================================================================
# EXAMPLE USAGE
# =============================================================================

# Tomcat (setenv.sh):
# export CATALINA_OPTS="@/path/to/jvm-virtual-threads.conf"

# Standalone Java:
# java @/path/to/jvm-virtual-threads.conf -jar yawl-engine.jar

# Docker:
# ENV JAVA_OPTS="@/app/config/jvm-virtual-threads.conf"

# =============================================================================
# PRODUCTION vs DEVELOPMENT SETTINGS
# =============================================================================

# PRODUCTION:
# - Remove -Djdk.tracePinnedThreads (or set to 'short')
# - Keep JFR enabled (production-safe)
# - Tune heap sizes based on actual usage
# - Monitor GC logs and adjust MaxGCPauseMillis

# DEVELOPMENT:
# - Keep -Djdk.tracePinnedThreads=full
# - Add -XX:+PrintVirtualThreadStatistics
# - Smaller heap sizes for faster iteration

# =============================================================================
# MONITORING CHECKLIST
# =============================================================================

# 1. Check JFR for pinning events:
#    jfr print --events jdk.VirtualThreadPinned /var/log/yawl/vthreads.jfr
#
# 2. Check virtual thread creation rate:
#    jfr print --events jdk.VirtualThreadStart /var/log/yawl/vthreads.jfr
#
# 3. Check GC overhead:
#    Analyze /var/log/yawl/gc.log
#
# 4. Check heap usage:
#    jcmd <pid> GC.heap_info
#
# 5. Check carrier thread utilization:
#    jfr print --events jdk.ThreadPark /var/log/yawl/vthreads.jfr

# =============================================================================
# TROUBLESHOOTING
# =============================================================================

# Issue: High pinning events
# Solution: Replace synchronized blocks with ReentrantLock
#
# Issue: OutOfMemoryError
# Solution: Increase -Xmx, check for memory leaks
#
# Issue: High GC overhead
# Solution: Tune G1NewCollectionHeapPercent, increase heap size
#
# Issue: Carrier thread starvation
# Solution: Increase jdk.virtualThreadScheduler.maxPoolSize (rare)

# =============================================================================
# REFERENCES
# =============================================================================

# JEP 444: Virtual Threads
# https://openjdk.org/jeps/444
#
# Java 21 GC Tuning Guide
# https://docs.oracle.com/en/java/javase/21/gctuning/
#
# Virtual Threads Best Practices
# https://inside.java/tag/virtual-threads
