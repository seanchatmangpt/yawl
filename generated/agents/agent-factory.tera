// GENERATED by ggen from a2a-protocols.ttl and mcp-tools.ttl
// Agent Factory — Creates agent instances from protocol specifications

package org.yawl.integration.agents;

import org.yawl.integration.mcp.*;
import org.yawl.integration.a2a.*;
import java.util.*;
import java.time.Instant;
import java.util.concurrent.*;

/**
 * AgentFactory — Creates and manages agent instances
 *
 * Agents created:
 * 1. OrchestrationAgent (Orchestrator, port 9001)
 * 2. ExecutorAgent (Worker, port 9002)
 * 3. ValidatorAgent (QA, port 9003)
 * 4. ObserverAgent (Monitoring, port 9004)
 * 5. ResolverAgent (Error Handling, port 9005)
 */
public class AgentFactory {

    private static final Map<String, Agent> AGENTS = new ConcurrentHashMap<>();
    private static final ExecutorService EXECUTOR = ForkJoinPool.commonPool();

    /**
     * Initialize all 5 agents
     */
    public static void initializeAllAgents() throws Exception {
        AGENTS.put("orchestrator", createOrchestrationAgent());
        AGENTS.put("executor", createExecutorAgent());
        AGENTS.put("validator", createValidatorAgent());
        AGENTS.put("observer", createObserverAgent());
        AGENTS.put("resolver", createResolverAgent());

        // Start MCP servers
        for (Agent agent : AGENTS.values()) {
            agent.getMCPServer().start();
        }
    }

    /**
     * AGENT 1: Orchestration Agent
     * Role: Coordinates multi-agent workflows
     * MCP Port: 9001
     * Tools: task_assign, status_poll, dependency_check
     */
    private static Agent createOrchestrationAgent() {
        AgentBuilder builder = new AgentBuilder("OrchestrationAgent");

        // Configure A2A Protocol
        builder.withA2AProtocol(
            A2AProtocol.builder()
                .name("OrchestrationProtocol")
                .messagingStyle(MessagingStyle.REQUEST_REPLY)
                .concurrency(Concurrency.PARALLEL)
                .encryption(Encryption.TLS12)
                .messageFormat(MessageFormat.JSON)
                .retryPolicy(new RetryPolicy(3, 2.0f, 100))
                .circuitBreaker(new CircuitBreaker(5, 2, 10000))
                .build()
        );

        // Configure MCP Server
        builder.withMCPServer(
            MCPServer.builder()
                .name("OrchestrationMCPServer")
                .host("127.0.0.1")
                .port(9001)
                .protocol(MCPProtocol.JSONRPC_2_0)
                .authentication(Authentication.JWT_BEARER)
                .build()
        );

        // Register tools
        builder.withTool(new TaskAssignTool())
               .withTool(new StatusPollTool())
               .withTool(new DependencyCheckTool());

        // Configure endpoints
        builder.withEndpoint(new A2AEndpoint("orchestration/tasks",
            A2AMethod.POST, MessageType.TASK_ASSIGNMENT, 500))
               .withEndpoint(new A2AEndpoint("orchestration/status",
            A2AMethod.GET, MessageType.STATUS_QUERY, 100))
               .withEndpoint(new A2AEndpoint("orchestration/dependencies",
            A2AMethod.GET, MessageType.DEPENDENCY_GRAPH, 200));

        // Configure resource quota
        builder.withResourceQuota(
            ResourceQuota.builder()
                .maxConcurrentTasks(16)
                .maxContextTokens(200000)
                .timeoutSeconds(3600)
                .build()
        );

        return builder.build();
    }

    /**
     * AGENT 2: Task Executor Agent
     * Role: Executes assigned tasks and reports progress
     * MCP Port: 9002
     * Tools: task_execute, progress_report, error_notify
     */
    private static Agent createExecutorAgent() {
        AgentBuilder builder = new AgentBuilder("ExecutorAgent");

        builder.withA2AProtocol(
            A2AProtocol.builder()
                .name("ExecutionProtocol")
                .messagingStyle(MessagingStyle.PUBLISH_SUBSCRIBE)
                .concurrency(Concurrency.SEQUENTIAL)
                .messageFormat(MessageFormat.JSON)
                .encryption(Encryption.TLS12)
                .queueing(Queueing.FIFO)
                .ordering(Ordering.ORDERED)
                .deliveryGuarantee(DeliveryGuarantee.AT_LEAST_ONCE)
                .build()
        );

        builder.withMCPServer(
            MCPServer.builder()
                .name("ExecutorMCPServer")
                .host("127.0.0.1")
                .port(9002)
                .protocol(MCPProtocol.JSONRPC_2_0)
                .authentication(Authentication.JWT_BEARER)
                .build()
        );

        builder.withTool(new TaskExecuteTool())
               .withTool(new ProgressReportTool())
               .withTool(new ErrorNotifyTool());

        builder.withEndpoint(new A2AEndpoint("executor/task/start",
            A2AMethod.POST, MessageType.TASK_START, 200))
               .withEndpoint(new A2AEndpoint("executor/task/progress",
            A2AMethod.POST, MessageType.PROGRESS_UPDATE, 100))
               .withEndpoint(new A2AEndpoint("executor/task/complete",
            A2AMethod.POST, MessageType.TASK_COMPLETION, 300));

        builder.withResourceQuota(
            ResourceQuota.builder()
                .maxConcurrentTasks(1)
                .maxContextTokens(50000)
                .timeoutSeconds(1800)
                .build()
        );

        return builder.build();
    }

    /**
     * AGENT 3: Validator Agent
     * Role: Validates task outputs and enforces quality gates
     * MCP Port: 9003
     * Tools: validate_output, check_gates, report_compliance
     */
    private static Agent createValidatorAgent() {
        AgentBuilder builder = new AgentBuilder("ValidatorAgent");

        builder.withA2AProtocol(
            A2AProtocol.builder()
                .name("ValidationProtocol")
                .messagingStyle(MessagingStyle.REQUEST_REPLY)
                .concurrency(Concurrency.PARALLEL)
                .messageFormat(MessageFormat.JSON)
                .encryption(Encryption.TLS12)
                .timeout(new Timeout(5000, 30000, 60000))
                .logging(LogLevel.VERBOSE)
                .build()
        );

        builder.withMCPServer(
            MCPServer.builder()
                .name("ValidatorMCPServer")
                .host("127.0.0.1")
                .port(9003)
                .protocol(MCPProtocol.JSONRPC_2_0)
                .authentication(Authentication.JWT_BEARER)
                .build()
        );

        builder.withTool(new ValidateOutputTool())
               .withTool(new CheckGatesTool())
               .withTool(new ReportComplianceTool());

        builder.withEndpoint(new A2AEndpoint("validator/check",
            A2AMethod.POST, MessageType.VALIDATION_REQUEST, 1000))
               .withEndpoint(new A2AEndpoint("validator/gates",
            A2AMethod.POST, MessageType.GATE_CHECK, 500))
               .withEndpoint(new A2AEndpoint("validator/compliance",
            A2AMethod.GET, MessageType.COMPLIANCE_REPORT, 2000));

        builder.withResourceQuota(
            ResourceQuota.builder()
                .maxConcurrentTasks(8)
                .maxContextTokens(100000)
                .timeoutSeconds(600)
                .build()
        );

        return builder.build();
    }

    /**
     * AGENT 4: Observer Agent
     * Role: Monitors system state and collects observability metrics
     * MCP Port: 9004
     * Tools: emit_metric, emit_trace, emit_log
     */
    private static Agent createObserverAgent() {
        AgentBuilder builder = new AgentBuilder("ObserverAgent");

        builder.withA2AProtocol(
            A2AProtocol.builder()
                .name("ObservationProtocol")
                .messagingStyle(MessagingStyle.PUSH_BASED)
                .concurrency(Concurrency.PARALLEL)
                .messageFormat(MessageFormat.JSON)
                .encryption(Encryption.TLS12)
                .buffering(new Buffering(100, 1000, true))
                .routing(RoutingMode.LOAD_BALANCED)
                .build()
        );

        builder.withMCPServer(
            MCPServer.builder()
                .name("ObserverMCPServer")
                .host("127.0.0.1")
                .port(9004)
                .protocol(MCPProtocol.JSONRPC_2_0)
                .authentication(Authentication.JWT_BEARER)
                .build()
        );

        builder.withTool(new EmitMetricTool())
               .withTool(new EmitTraceTool())
               .withTool(new EmitLogTool());

        builder.withEndpoint(new A2AEndpoint("observer/metrics",
            A2AMethod.POST, MessageType.METRIC_EMISSION, 50))
               .withEndpoint(new A2AEndpoint("observer/traces",
            A2AMethod.POST, MessageType.TRACE_SPAN, 50))
               .withEndpoint(new A2AEndpoint("observer/logs",
            A2AMethod.POST, MessageType.LOG_ENTRY, 25));

        builder.withResourceQuota(
            ResourceQuota.builder()
                .maxConcurrentTasks(32)
                .maxContextTokens(150000)
                .timeoutSeconds(300)
                .build()
        );

        return builder.build();
    }

    /**
     * AGENT 5: Resolver Agent
     * Role: Handles failures, conflicts, and recovery scenarios
     * MCP Port: 9005
     * Tools: handle_error, resolve_conflict, recovery_plan
     */
    private static Agent createResolverAgent() {
        AgentBuilder builder = new AgentBuilder("ResolverAgent");

        builder.withA2AProtocol(
            A2AProtocol.builder()
                .name("ResolutionProtocol")
                .messagingStyle(MessagingStyle.EVENT_DRIVEN)
                .concurrency(Concurrency.PARALLEL)
                .messageFormat(MessageFormat.JSON)
                .encryption(Encryption.TLS12)
                .priority(Priority.HIGH)
                .acknowledgement(Acknowledgement.REQUIRED)
                .deadLetterQueue(Feature.ENABLED)
                .build()
        );

        builder.withMCPServer(
            MCPServer.builder()
                .name("ResolverMCPServer")
                .host("127.0.0.1")
                .port(9005)
                .protocol(MCPProtocol.JSONRPC_2_0)
                .authentication(Authentication.JWT_BEARER)
                .build()
        );

        builder.withTool(new HandleErrorTool())
               .withTool(new ResolveConflictTool())
               .withTool(new RecoveryPlanTool());

        builder.withEndpoint(new A2AEndpoint("resolver/error",
            A2AMethod.POST, MessageType.ERROR_NOTIFICATION, 500))
               .withEndpoint(new A2AEndpoint("resolver/conflict",
            A2AMethod.POST, MessageType.CONFLICT_RESOLUTION, 1000))
               .withEndpoint(new A2AEndpoint("resolver/recovery",
            A2AMethod.POST, MessageType.RECOVERY_PLAN, 2000));

        builder.withResourceQuota(
            ResourceQuota.builder()
                .maxConcurrentTasks(4)
                .maxContextTokens(75000)
                .timeoutSeconds(900)
                .build()
        );

        return builder.build();
    }

    /**
     * Get agent by name
     */
    public static Agent getAgent(String name) {
        return AGENTS.get(name.toLowerCase());
    }

    /**
     * Get all agents
     */
    public static Collection<Agent> getAllAgents() {
        return AGENTS.values();
    }

    /**
     * Shutdown all agents
     */
    public static void shutdownAll() throws Exception {
        for (Agent agent : AGENTS.values()) {
            agent.getMCPServer().stop();
        }
        AGENTS.clear();
        EXECUTOR.shutdown();
    }

    /**
     * Create agent status report
     */
    public static String getStatusReport() {
        StringBuilder sb = new StringBuilder();
        sb.append("=== Agent Status Report ===\n");
        sb.append("Timestamp: ").append(Instant.now()).append("\n\n");

        for (String name : AGENTS.keySet()) {
            Agent agent = AGENTS.get(name);
            sb.append(String.format("%-20s | Status: %s | Tools: %d | Port: %d\n",
                agent.getName(),
                agent.isRunning() ? "RUNNING" : "STOPPED",
                agent.getToolCount(),
                agent.getMCPServer().getPort()
            ));
        }

        return sb.toString();
    }
}
