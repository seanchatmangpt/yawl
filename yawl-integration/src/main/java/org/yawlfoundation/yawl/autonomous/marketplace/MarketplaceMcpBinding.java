/*
 * Copyright (c) 2004-2026 The YAWL Foundation. All rights reserved.
 * The YAWL Foundation is a collaboration of individuals and
 * organisations who are committed to improving workflow technology.
 *
 * This file is part of YAWL. YAWL is free software: you can
 * redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation.
 *
 * YAWL is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with YAWL. If not, see <http://www.gnu.org/licenses/>.
 */

package org.yawlfoundation.yawl.integration.autonomous.marketplace;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Exposes the agent marketplace as MCP tool descriptors.
 *
 * <p>When a {@link SparqlEngine} is provided, tool definitions are generated by
 * loading the {@link MarketplaceConstructQueries#MARKETPLACE_SCHEMA_GRAPH} into the
 * engine and running {@link MarketplaceConstructQueries#MCP_TOOL_SCHEMA_CONSTRUCT}.
 * The Turtle result is parsed into {@link McpToolDescriptor} objects.
 * When no engine is provided (or the engine is unavailable), the same five tools
 * are returned from Java constants — the marketplace functions without SPARQL.</p>
 *
 * <p>Agent query results ({@link #queryAgentsAsTurtle}) require a live engine:
 * they export live marketplace data via {@link MarketplaceRdfExporter}, load it
 * into the engine, and run the supplied CONSTRUCT query.</p>
 *
 * @since YAWL 6.0
 */
public final class MarketplaceMcpBinding {

    // Matches: <full-iri> or ops:localName followed by a string literal
    // Captures: (1) local predicate name, (2) unescaped literal content
    private static final Pattern PRED_LITERAL = Pattern.compile(
            "(?:<[^>]+/ops#|ops:)(\\w+)\\s+\"((?:[^\"\\\\]|\\\\.)*)\"");

    // Matches: a subject IRI at the start of a triple group
    private static final Pattern SUBJECT_IRI = Pattern.compile(
            "^\\s*<([^>]+)>\\s*(?:a\\s+\\S+\\s*[;.])?", Pattern.MULTILINE);

    private final AgentMarketplace marketplace;
    private final SparqlEngine engine;   // may be null
    private final MarketplaceRdfExporter exporter = new MarketplaceRdfExporter();

    /**
     * Creates a binding with an optional SPARQL engine.
     *
     * @param marketplace the marketplace to expose; must not be null
     * @param engine      a live SPARQL engine, or null to use Java-constant fallback
     */
    public MarketplaceMcpBinding(AgentMarketplace marketplace, SparqlEngine engine) {
        this.marketplace = Objects.requireNonNull(marketplace, "marketplace must not be null");
        this.engine = engine;
    }

    /**
     * Returns MCP tool descriptors for all five marketplace operations.
     *
     * <p>If an engine is present and available, descriptors are generated by
     * SPARQL CONSTRUCT against the schema graph. Otherwise the Java-constant
     * fallback is used; the same five tools are returned either way.</p>
     *
     * @return unmodifiable list of five {@link McpToolDescriptor}s; never null
     */
    public List<McpToolDescriptor> getMcpTools() {
        if (engine != null && engine.isAvailable()) {
            try {
                return buildToolsViaConstruct();
            } catch (SparqlEngineException ignored) {
                // Fall through to static fallback
            }
        }
        return staticMcpTools();
    }

    /**
     * Export live marketplace listings into the engine, then execute the given
     * CONSTRUCT query and return the Turtle result.
     *
     * @param constructQuery a SPARQL CONSTRUCT query against the {@code mkt:} vocabulary
     * @return Turtle string with CONSTRUCT results
     * @throws SparqlEngineException        if the CONSTRUCT fails
     * @throws SparqlEngineUnavailableException if no engine is configured or reachable
     */
    public String queryAgentsAsTurtle(String constructQuery) throws SparqlEngineException {
        Objects.requireNonNull(constructQuery, "constructQuery must not be null");
        if (engine == null) {
            throw new SparqlEngineUnavailableException("No SparqlEngine configured",
                    (Throwable) null);
        }
        if (!engine.isAvailable()) {
            throw new SparqlEngineUnavailableException(engine.engineType(),
                    "engine is unreachable");
        }
        if (!(engine instanceof OxigraphSparqlEngine oxEngine)) {
            throw new SparqlEngineException(
                    "queryAgentsAsTurtle requires an OxigraphSparqlEngine (mutable engine); "
                    + "got: " + engine.engineType());
        }
        String turtle = exporter.exportToTurtle(marketplace);
        oxEngine.loadTurtle(turtle);
        return engine.constructToTurtle(constructQuery);
    }

    // -----------------------------------------------------------------------
    // Internal — CONSTRUCT-based tool derivation
    // -----------------------------------------------------------------------

    private List<McpToolDescriptor> buildToolsViaConstruct() throws SparqlEngineException {
        if (!(engine instanceof OxigraphSparqlEngine oxEngine)) {
            // QLever is read-only; load schema via Oxigraph only
            return parseToolsFromTurtle(
                    engine.constructToTurtle(MarketplaceConstructQueries.MCP_TOOL_SCHEMA_CONSTRUCT));
        }
        oxEngine.loadTurtle(MarketplaceConstructQueries.MARKETPLACE_SCHEMA_GRAPH);
        String result = engine.constructToTurtle(MarketplaceConstructQueries.MCP_TOOL_SCHEMA_CONSTRUCT);
        List<McpToolDescriptor> tools = parseToolsFromTurtle(result);
        if (tools.isEmpty()) {
            throw new SparqlEngineException(
                    "MCP_TOOL_SCHEMA_CONSTRUCT returned no results; schema graph may not be loaded");
        }
        return tools;
    }

    /**
     * Parse Turtle output from {@link MarketplaceConstructQueries#MCP_TOOL_SCHEMA_CONSTRUCT}
     * into {@link McpToolDescriptor} objects.
     *
     * <p>Extracts {@code ops:name}, {@code ops:description}, and {@code ops:inputSchema}
     * predicates grouped by subject IRI. Handles both prefixed ({@code ops:predicate})
     * and full-IRI ({@code <...#predicate>}) forms that Oxigraph may emit.</p>
     */
    static List<McpToolDescriptor> parseToolsFromTurtle(String turtle) {
        // Group triple lines by subject IRI
        Map<String, Map<String, String>> subjects = new LinkedHashMap<>();
        String currentSubject = null;

        for (String line : turtle.split("\n")) {
            // Detect new subject lines: starts with <iri>
            Matcher subjMatcher = SUBJECT_IRI.matcher(line);
            if (subjMatcher.find() && line.stripLeading().startsWith("<")) {
                currentSubject = subjMatcher.group(1);
                subjects.computeIfAbsent(currentSubject, k -> new LinkedHashMap<>());
            }
            if (currentSubject == null) continue;

            // Extract predicate + literal pairs on this line
            Matcher pred = PRED_LITERAL.matcher(line);
            while (pred.find()) {
                String predName = pred.group(1);
                String value = unescape(pred.group(2));
                subjects.get(currentSubject).put(predName, value);
            }
        }

        List<McpToolDescriptor> tools = new ArrayList<>();
        for (Map<String, String> props : subjects.values()) {
            String name   = props.get("name");
            String desc   = props.get("description");
            String schema = props.get("inputSchema");
            if (name != null && desc != null && schema != null) {
                tools.add(new McpToolDescriptor(name, desc, schema));
            }
        }
        return Collections.unmodifiableList(tools);
    }

    /** Unescape Turtle string literal escape sequences. */
    private static String unescape(String s) {
        return s.replace("\\\"", "\"")
                .replace("\\n", "\n")
                .replace("\\r", "\r")
                .replace("\\\\", "\\");
    }

    // -----------------------------------------------------------------------
    // Static fallback — same 5 tools, always available
    // -----------------------------------------------------------------------

    static List<McpToolDescriptor> staticMcpTools() {
        return List.of(
            new McpToolDescriptor(
                "marketplace_list_agents",
                "List all live agents in the marketplace",
                "{\"type\":\"object\",\"properties\":{}}"),
            new McpToolDescriptor(
                "marketplace_find_for_slot",
                "Find agents satisfying a multi-dimensional transition slot query",
                "{\"type\":\"object\",\"properties\":{"
                + "\"namespace\":{\"type\":\"string\"},"
                + "\"wcpPattern\":{\"type\":\"string\"},"
                + "\"maxP99Ms\":{\"type\":\"integer\"},"
                + "\"maxCost\":{\"type\":\"number\"}}}"),
            new McpToolDescriptor(
                "marketplace_find_by_namespace",
                "Find agents that declare a specific RDF namespace",
                "{\"type\":\"object\",\"required\":[\"namespace\"],"
                + "\"properties\":{\"namespace\":{\"type\":\"string\"}}}"),
            new McpToolDescriptor(
                "marketplace_find_by_wcp",
                "Find agents supporting a specific Workflow Control Pattern",
                "{\"type\":\"object\",\"required\":[\"wcpPattern\"],"
                + "\"properties\":{\"wcpPattern\":{\"type\":\"string\"}}}"),
            new McpToolDescriptor(
                "marketplace_heartbeat",
                "Update an agent's heartbeat to mark it as live",
                "{\"type\":\"object\",\"required\":[\"agentId\"],"
                + "\"properties\":{\"agentId\":{\"type\":\"string\"}}}")
        );
    }
}
