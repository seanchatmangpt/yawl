# How-To: Write Tera Templates for ggen Code Generation

This guide shows you how to write reusable Tera templates for ggen that generate YAWL specifications, Java service stubs, and other artifacts from RDF knowledge bases.

---

## What is a Tera Template?

**Tera** is a template engine inspired by Jinja2. In ggen, Tera templates are rendered with data extracted from SPARQL queries, allowing you to generate code, configurations, and specifications in any text format.

Key features:
- **Variable interpolation**: `{{ variable }}`
- **Loops**: `{% for item in items %}`
- **Conditionals**: `{% if condition %}`
- **Filters**: `{{ value | upper }}`
- **Macros**: Define reusable template fragments

---

## Task 1: Generate a YAWL Specification from RDF

### Goal

Generate a complete YAWL specification from RDF describing tasks, flows, and conditions.

### Setup

Create two files:

1. **workflow-model.ttl** (RDF knowledge base):

```turtle
@prefix : <http://example.com/invoice#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

:InvoiceApproval a :Workflow ;
    rdfs:label "Invoice Approval" .

:StartCondition a :Condition ;
    rdfs:label "Start" .

:ReceiveInvoice a :Task ;
    rdfs:label "Receive Invoice" ;
    :splitType :and .

:ReviewInvoice a :Task ;
    rdfs:label "Review Invoice" .

:ApproveInvoice a :Task ;
    rdfs:label "Approve Invoice" .

:RejectInvoice a :Task ;
    rdfs:label "Reject Invoice" .

:UpdateRecord a :Task ;
    rdfs:label "Update Financial Record" .

:EndCondition a :Condition ;
    rdfs:label "End" .

:ReceiveInvoice :flowsTo :ReviewInvoice .
:ReviewInvoice :flowsTo :Decision .

:Decision a :Condition ;
    rdfs:label "Approved?" .

:Decision :flowsTo :ApproveInvoice ;
    :condition "reviewerApproved = true" .

:Decision :flowsTo :RejectInvoice ;
    :condition "reviewerApproved = false" .

:ApproveInvoice :flowsTo :UpdateRecord .
:RejectInvoice :flowsTo :EndCondition .
:UpdateRecord :flowsTo :EndCondition .
```

2. **yawl-specification.tera** (Tera template):

```tera
<?xml version="1.0" encoding="UTF-8"?>
<specificationSet xmlns="http://www.yawlfoundation.org/yawlschema"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.yawlfoundation.org/yawlschema
                   http://www.yawlfoundation.org/yawlschema/YAWL_Schema2.3.xsd">

  <specification uri="http://example.com/{{ workflow.uri }}">
    <name>{{ workflow.label }}</name>
    <documentation>Generated by ggen on {{ timestamp }}</documentation>
    <metaData>
      <version>1.0</version>
      <author>ggen</author>
      <created>{{ timestamp }}</created>
    </metaData>

    <net id="{{ net_id }}">
      <name>{{ workflow.label }}</name>

      <!-- Start condition -->
      <inputCondition id="InputCondition">
        <name>Start</name>
        <flowsInto>
          <nextElementRef id="{{ first_task }}" />
        </flowsInto>
      </inputCondition>

      <!-- Generate all tasks -->
      {% for task in tasks %}
      <task id="{{ task.id }}">
        <name>{{ task.label }}</name>
        <documentation>{{ task.documentation | default(value="") }}</documentation>

        {% if task.splits.and %}
        <split code="AND">
          {% for output in task.outputs %}
          <outputCondition id="{{ output }}" />
          {% endfor %}
        </split>
        {% else %}
        {% if task.splits.xor %}
        <split code="XOR">
          {% for output in task.outputs %}
          <outputCondition id="{{ output }}" />
          {% endfor %}
        </split>
        {% else %}
        <!-- Default: single output -->
        <flowsInto>
          <nextElementRef id="{{ task.next_element }}" />
        </flowsInto>
        {% endif %}
        {% endif %}
      </task>
      {% endfor %}

      <!-- Generate all conditions -->
      {% for condition in conditions %}
      <condition id="{{ condition.id }}">
        <name>{{ condition.label }}</name>
        {% for flow in condition.outflows %}
        <flowsInto>
          <nextElementRef id="{{ flow.target }}" />
        </flowsInto>
        {% endfor %}
      </condition>
      {% endfor %}

      <!-- End condition -->
      <outputCondition id="OutputCondition">
        <name>End</name>
      </outputCondition>
    </net>
  </specification>
</specificationSet>
```

### Java Code to Render

```java
import org.apache.jena.query.*;
import org.apache.jena.rdf.model.*;
import org.apache.jena.riot.RDFDataMgr;
import java.util.*;

public class GenerateYawlSpec {
    public static void main(String[] args) throws Exception {
        Model model = RDFDataMgr.loadModel("workflow-model.ttl");

        // SPARQL queries to extract data
        String tasksQuery = """
            PREFIX : <http://example.com/invoice#>
            PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

            SELECT ?id ?label
            WHERE {
                ?id a :Task ;
                    rdfs:label ?label .
            }
            """;

        QueryExecution qe = QueryExecutionFactory.create(
            QueryFactory.create(tasksQuery), model);
        ResultSet rs = qe.execSelect();

        List<Map<String, String>> tasks = new ArrayList<>();
        while (rs.hasNext()) {
            QuerySolution soln = rs.next();
            Map<String, String> task = new HashMap<>();
            task.put("id", soln.getResource("id").getLocalName());
            task.put("label", soln.getLiteral("label").getString());
            task.put("next_element", "OutputCondition"); // Simplified; query actual flows
            tasks.add(task);
        }
        qe.close();

        // Build template context
        Map<String, Object> context = new HashMap<>();
        Map<String, String> workflow = new HashMap<>();
        workflow.put("uri", "invoice-approval");
        workflow.put("label", "Invoice Approval");
        context.put("workflow", workflow);

        context.put("net_id", "InvoiceApprovalNet");
        context.put("first_task", "ReceiveInvoice");
        context.put("tasks", tasks);
        context.put("timestamp", java.time.Instant.now().toString());

        // Render with Tera (in practice, use ggen's template engine)
        System.out.println("Context for template: " + context);
        // Output would be a valid YAWL specification XML
    }
}
```

---

## Task 2: Generate Java Service Stubs from RDF

### Goal

Generate Java interface stubs for YAWL task handlers from RDF specifications.

### Template: service-interface.tera

```tera
package {{ package }};

import org.yawlfoundation.yawl.engine.YWorkItem;

/**
 * Generated service interface for {{ workflow.label }}
 * Generated by ggen on {{ timestamp }}
 */
public interface {{ service_class }}Service {

    {% for task in tasks %}
    /**
     * Handler for {{ task.label }}
     * @param workItem the work item to process
     * @return true if successful, false otherwise
     */
    boolean {{ task.handler_name }}(YWorkItem workItem);

    {% endfor %}
}
```

### Java Code

```java
import java.util.*;

public class GenerateServiceStub {
    public static void main(String[] args) throws Exception {
        // Extract tasks from RDF
        List<Map<String, String>> tasks = new ArrayList<>();
        String[] taskLabels = {"Receive Invoice", "Review Invoice", "Approve Invoice"};
        for (String label : taskLabels) {
            Map<String, String> task = new HashMap<>();
            task.put("label", label);
            task.put("handler_name", camelCase(label.toLowerCase().replace(" ", "_")));
            tasks.add(task);
        }

        // Build template context
        Map<String, Object> context = new HashMap<>();
        context.put("package", "com.example.workflow");
        context.put("service_class", "InvoiceApproval");
        context.put("tasks", tasks);
        context.put("timestamp", java.time.Instant.now());

        System.out.println("Service stub context: " + context);
    }

    private static String camelCase(String str) {
        String[] parts = str.split("_");
        StringBuilder sb = new StringBuilder();
        for (String part : parts) {
            if (sb.length() == 0) {
                sb.append(part); // First part lowercase
            } else {
                sb.append(part.substring(0, 1).toUpperCase())
                  .append(part.substring(1));
            }
        }
        return sb.toString();
    }
}
```

---

## Task 3: Generate Configuration YAML from RDF

### Goal

Generate YAWL engine configuration files from RDF specifications.

### Template: engine-config.tera

```yaml
# Generated YAWL Engine Configuration
# Generated by ggen on {{ timestamp }}

yawl:
  engine:
    name: {{ engine.name }}
    version: {{ engine.version }}

  specifications:
    default_timeout_ms: {{ engine.timeout_ms }}

  resources:
    {% for resource in resources %}
    - id: {{ resource.id }}
      type: {{ resource.type }}
      label: {{ resource.label }}
      {% if resource.properties %}
      properties:
        {% for prop_key, prop_value in resource.properties %}
        {{ prop_key }}: "{{ prop_value }}"
        {% endfor %}
      {% endif %}
    {% endfor %}

  participants:
    {% for participant in participants %}
    - id: {{ participant.id }}
      name: {{ participant.name }}
      role: {{ participant.role }}
    {% endfor %}

  audit:
    enabled: {{ audit.enabled }}
    log_level: {{ audit.log_level }}
```

---

## Best Practices

### 1. Use Filters for Text Transformation

```tera
<!-- Convert to uppercase -->
<name>{{ task.label | upper }}</name>

<!-- Default values -->
<description>{{ task.description | default(value="No description") }}</description>

<!-- String truncation -->
<shortName>{{ task.label | truncate(length=20) }}</shortName>
```

### 2. Validate Template Syntax

Always test templates with sample data before deploying:

```bash
# Test template rendering with ggen CLI
ggen render --template yawl-specification.tera \
            --context workflow-context.json \
            --output generated-spec.xml
```

### 3. Organize Complex Templates

For large templates, use includes:

```tera
{% include "common-header.tera" %}

<tasks>
  {% for task in tasks %}
  {% include "task-template.tera" %}
  {% endfor %}
</tasks>
```

### 4. Document Template Variables

Always document the context structure expected by your template:

```
# yawl-specification.tera
# Expected context:
# {
#   "workflow": {
#     "uri": string,
#     "label": string
#   },
#   "net_id": string,
#   "first_task": string,
#   "tasks": [
#     {
#       "id": string,
#       "label": string,
#       "next_element": string,
#       "outputs": [string]
#     }
#   ],
#   "conditions": [
#     {
#       "id": string,
#       "label": string,
#       "outflows": [{ "target": string }]
#     }
#   ],
#   "timestamp": string
# }
```

---

## Troubleshooting

### Template Not Found

Ensure template file is in the classpath or specify absolute path:

```bash
ggen render --template /absolute/path/to/template.tera
```

### Variable Not Rendering

Check SPARQL query output:

```bash
sparql --query extract-tasks.sparql --data workflow.ttl
```

### Invalid XML Output

Validate generated XML:

```bash
xmllint --noout generated-spec.xml
```

---

## Next Steps

- [How-To: Synthesize Workflows from Event Logs](ggen-synthesis-from-logs.md)
- [Reference: ggen API](../reference/ggen-api.md)
