# ADR-017: Authentication and Session Management for v6.0.0

## Status
**ACCEPTED**

## Context

YAWL v5.x session handles are opaque base64-encoded blobs generated by the engine and
stored in an in-memory `HashMap`. This design has several problems:

1. **No clustering support**: session handles are local to the JVM; requests must be
   routed to the same node (sticky sessions). This directly blocks ADR-014 (clustering).
2. **No expiry enforcement**: sessions expire only when the map entry is evicted;
   there is no guaranteed maximum lifetime.
3. **No standard format**: custom parsing is required on every endpoint; no tooling
   integration (JWT libraries, API gateways, service meshes).
4. **No role-based access control**: all authenticated sessions have identical
   permissions; the engine cannot distinguish admin from service accounts.
5. **Password in query parameters**: some v5.x endpoints accept credentials as query
   parameters, which are logged in access logs (security risk).

The SPIFFE/SPIRE zero-trust identity framework (ADR-005) covers service-to-service
authentication. This ADR covers human-to-engine and client-application-to-engine
authentication.

## Decision

**YAWL v6.0.0 replaces opaque session handles with HMAC-SHA256 signed JWTs
(JSON Web Tokens, RFC 7519), while retaining the `sessionHandle` parameter name
for backward-compatible API signatures.**

### Token Structure

```
Header: {"alg": "HS256", "typ": "JWT"}
Payload: {
  "sub":   "jane.smith",          // user ID
  "iss":   "yawl-engine",         // issuer
  "aud":   "yawl-api",            // audience
  "iat":   1739800000,            // issued-at (epoch seconds)
  "exp":   1739803600,            // expiry (issued-at + session.timeout)
  "jti":   "a3f7-bee2-4109",      // JWT ID (for revocation)
  "roles": ["workflow-user"],     // YAWL role set
  "tenant": "acme-corp"           // tenant identifier (ADR-015)
}
Signature: HMAC-SHA256(header + "." + payload, secretKey)
```

The `sessionHandle` name is preserved in the API for backward compatibility (see ADR-016).
The value is now a JWT string (`xxxxx.yyyyy.zzzzz`) rather than an opaque blob.

### Role Model

| Role | Capabilities |
|------|-------------|
| `workflow-user` | Checkout, checkin, complete work items; read case data |
| `workflow-admin` | Above + launch/cancel cases, manage participants |
| `spec-designer` | Upload/delete specifications (Interface A) |
| `engine-admin` | Full admin access including cluster management |
| `service-account` | Programmatic access (no session timeout) |

Roles are stored in the engine's user directory and embedded in the JWT at login time.

### Token Lifecycle

```
1. POST /ib/connect (userid + password)
   → Verify credentials against user store
   → Generate JWT with roles + tenant
   → Return JWT as sessionHandle

2. Subsequent requests: ?sessionHandle={jwt}
   → Parse JWT (no DB lookup required — stateless validation)
   → Verify HMAC signature
   → Check exp claim (reject if expired)
   → Authorise against required role for the endpoint
   → Process request

3. POST /ib/disconnect
   → Add jti to revocation cache (Redis or DB table)
   → Token remains cryptographically valid but is rejected by revocation check
```

### Stateless Validation

Because the JWT signature is verified using a symmetric key held by all engine nodes,
any node can validate any session without consulting the database. This satisfies the
clustering requirement (ADR-014: no sticky sessions).

The signing key is distributed via environment variable:
```properties
yawl.security.jwt.secret=${YAWL_JWT_SECRET}  # 256-bit minimum entropy
yawl.security.jwt.session-timeout=PT60M
yawl.security.jwt.service-account-timeout=PT24H
```

For multi-node deployments, `YAWL_JWT_SECRET` must be identical across all nodes.
Key rotation requires a rolling restart with a grace period during which both old
and new keys are accepted.

### Revocation

Token revocation (logout, admin forced-expire) uses a compact revocation set:

- Revoked JTIs are stored in Redis with TTL = `exp - now`
- On token expiry, the Redis key auto-expires — no manual cleanup
- If Redis is unavailable, revocation checks are skipped (log warning, accept token)
  — availability is prioritised over perfect revocation in degraded mode

### Backward Compatibility

v5.x clients generating opaque session handles will receive a 401 on the first request
after upgrade. The error message explicitly instructs them to re-authenticate:

```json
{
  "error": "Session handle format is not valid for YAWL v6.0. Re-authenticate via POST /ib/connect.",
  "status": 401,
  "code": "YAWL-E-AUTH-001"
}
```

### Password Security

Passwords are hashed using BCrypt (work factor 12) in the engine's user store.
The plain-text password accepted at `/ib/connect` is never persisted.

Passwords in query parameters (`?password=...`) are rejected with `400 Bad Request`
and a clear message directing clients to the request body.

## Consequences

### Positive

1. Stateless token validation enables clustering (ADR-014) without sticky sessions
2. JWT is a standard format — API gateways, OAuth 2.0 proxies, and monitoring tools
   can inspect tokens without custom parsing
3. Role-based access control enables fine-grained security policies
4. Revocation via Redis is O(1) and does not require scanning all active sessions
5. Multi-tenant context carried in JWT (no extra database lookup per request)

### Negative

1. JWT tokens are larger than opaque handles (~200 bytes vs ~50 bytes), increasing
   request size marginally
2. Symmetric HMAC means the signing key is shared across all nodes — if it leaks,
   all tokens can be forged. Rotate immediately if compromised.
3. Existing v5.x clients must re-authenticate after upgrade (one-time migration cost)
4. Revocation requires Redis; without it, revocation is best-effort

### Risks

| Risk | Probability | Impact | Mitigation |
|------|------------|--------|------------|
| JWT secret leakage | LOW | CRITICAL | Store in Kubernetes Secret / Vault; rotate every 90 days |
| Token replay attacks | LOW | HIGH | Short expiry (60 min) + jti revocation; use TLS everywhere |
| Clock skew causing premature expiry | LOW | LOW | Allow 30s clock skew tolerance via `nbf` claim |
| Redis revocation unavailability | MEDIUM | LOW | Degraded mode: accept non-revoked tokens; alert on Redis unavailability |

## Alternatives Considered

### OAuth 2.0 Authorization Server
Full OAuth 2.0 with an external authorization server (Keycloak, Okta) would be the
gold standard for enterprise deployments. Rejected for v6.0 because it introduces an
external infrastructure dependency that complicates standalone deployments. OAuth 2.0
integration via JWT bearer tokens is planned as an optional configuration in v6.1.

### Asymmetric RS256 JWT
Using RSA-256 (asymmetric) instead of HMAC-256 would allow engine nodes to verify
tokens without the private key (only the public key is needed for verification).
Rejected for v6.0: symmetric HMAC is simpler to configure and the security model is
equivalent for a closed system. RS256 is the target for OAuth 2.0 integration in v6.1.

### Session Database Table
Storing sessions in a database table (as v5.x conceptually does with in-memory HashMap).
Rejected: requires a database lookup on every request, which is the primary performance
bottleneck the JWT approach eliminates.

## Related ADRs

- ADR-005: SPIFFE/SPIRE (service-to-service authentication, complementary)
- ADR-014: Clustering (stateless JWT validation enables no-sticky-session clustering)
- ADR-015: Persistence Layer (revocation table as fallback for Redis-less deployments)
- ADR-016: Deprecation Policy (v5.x session handles deprecated with 6-month sunset)

## Implementation Notes

### JWT Filter

```java
// org.yawlfoundation.yawl.rest.filter.JwtAuthenticationFilter
@Provider
@Priority(Priorities.AUTHENTICATION)
public class JwtAuthenticationFilter implements ContainerRequestFilter {

    @Override
    public void filter(ContainerRequestContext ctx) {
        String handle = ctx.getUriInfo().getQueryParameters().getFirst("sessionHandle");
        if (handle == null || handle.isBlank()) {
            ctx.abortWith(Response.status(Response.Status.UNAUTHORIZED)
                .entity(new YawlApiError("sessionHandle parameter is required", 401))
                .build());
            return;
        }
        try {
            Claims claims = jwtService.validate(handle);
            ctx.setSecurityContext(new YawlSecurityContext(claims));
        } catch (JwtException ex) {
            ctx.abortWith(Response.status(Response.Status.UNAUTHORIZED)
                .entity(new YawlApiError(ex.getMessage(), 401))
                .build());
        }
    }
}
```

### Dependencies

```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.13.0</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.13.0</version>
    <scope>runtime</scope>
</dependency>
```

## Approval

**Approved by:** YAWL Architecture Team
**Date:** 2026-02-17
**Implementation Status:** IN PROGRESS (v6.0.0)
**Review Date:** 2026-08-17

---

**Revision History:**
- 2026-02-17: Initial version
