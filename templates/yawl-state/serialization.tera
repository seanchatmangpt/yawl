{#
 Serialization Code Generation Template for YAWL State Machine

 Generates XML marshal/unmarshal methods for state machine objects.
 Supports case export/import format with XNode utility.

 Template Parameters:
   - class_name: Name of the generated serializer class
   - package: Java package name
   - target_class: The class being serialized
   - elements: Array of serializable element definitions
   - supports_jdom: Use JDOM2 for XML handling
   - supports_xnode: Use YAWL XNode utility

 Usage:
   tera -t serialization.tera -c '{"class_name":"CaseSerializer","package":"org.yawlfoundation.yawl.engine"}'
-#}
/*
 * Copyright (c) 2004-{{ "now" | date(format="%Y") }} The YAWL Foundation. All rights reserved.
 * The YAWL Foundation is a collaboration of individuals and
 * organisations who are committed to improving workflow technology.
 *
 * This file is part of YAWL. YAWL is free software: you can
 * redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation.
 *
 * YAWL is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
 * Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with YAWL. If not, see <http://www.gnu.org/licenses/>.
 *
 * GENERATED BY: yawl-state/serialization.tera
 * GENERATION TIMESTAMP: {{ "now" | date(format="%Y-%m-%dT%H:%M:%SZ") }}
 */

package {{ package }};

{% if supports_jdom | default(value=true) %}
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.JDOMException;
import org.jdom2.input.SAXBuilder;
import org.jdom2.output.Format;
import org.jdom2.output.XMLOutputter;
{% endif %}
{% if supports_xnode | default(value=true) %}
import org.yawlfoundation.yawl.util.XNode;
import org.yawlfoundation.yawl.util.JDOMUtil;
{% endif %}
import org.yawlfoundation.yawl.elements.state.YIdentifier;
import org.yawlfoundation.yawl.engine.YNetRunner;
import org.yawlfoundation.yawl.engine.YWorkItem;

import java.io.IOException;
import java.io.StringReader;
import java.time.Instant;
import java.util.*;

/**
 * {{ class_name }} - XML Serialization for YAWL State Objects
 *
 * Provides marshalling and unmarshalling methods for workflow state objects
 * using the YAWL case export/import XML format.
 *
 * <h2>XML Format</h2>
 * <pre>
 *   &lt;case&gt;
 *     &lt;runners&gt;
 *       &lt;runner&gt;
 *         &lt;identifier id="..."&gt;
 *           &lt;locations&gt;
 *             &lt;location&gt;...&lt;/location&gt;
 *           &lt;/locations&gt;
 *           &lt;children&gt;...&lt;/children&gt;
 *         &lt;/identifier&gt;
 *         &lt;netdata&gt;...&lt;/netdata&gt;
 *         &lt;enabledtasks&gt;...&lt;/enabledtasks&gt;
 *         &lt;busytasks&gt;...&lt;/busytasks&gt;
 *       &lt;/runner&gt;
 *     &lt;/runners&gt;
 *     &lt;workitems&gt;...&lt;/workitems&gt;
 *   &lt;/case&gt;
 * </pre>
 *
 * <h2>Thread Safety</h2>
 * This class is thread-safe for serialization operations. Each serialization
 * creates independent data structures.
 *
 * @author YAWL Code Generator
 * @since {{ version | default(value="5.2") }}
 */
public class {{ class_name }} {

    /** XML format version */
    public static final String FORMAT_VERSION = "4.0";

    /** Namespace for YAWL elements */
    public static final String YAWL_NS = "http://www.yawlfoundation.org/yawl";

    // ============================================================
    // MARSHALLING (Object -> XML)
    // ============================================================

    /**
     * Serializes a complete case to XML format.
     *
     * @param caseID the case identifier
     * @param runners the net runners for this case
     * @param workItems the work items for this case
     * @return XML string representation
     */
    public String marshalCase(YIdentifier caseID,
                              List<YNetRunner> runners,
                              List<YWorkItem> workItems) {
        XNode root = new XNode("case");
        root.addAttribute("version", FORMAT_VERSION);
        root.addAttribute("timestamp", Instant.now().toString());

        root.addChild(marshalRunners(runners));
        root.addChild(marshalWorkItems(workItems, caseID));

        return root.toString();
    }

    /**
     * Serializes multiple cases to XML format.
     *
     * @param cases map of case IDs to their runners
     * @param workItems all work items indexed by case
     * @return XML string representation
     */
    public String marshalCases(Map<YIdentifier, List<YNetRunner>> cases,
                               Map<YIdentifier, List<YWorkItem>> workItems) {
        XNode root = new XNode("cases");
        root.addAttribute("version", FORMAT_VERSION);
        root.addAttribute("count", String.valueOf(cases.size()));

        for (Map.Entry<YIdentifier, List<YNetRunner>> entry : cases.entrySet()) {
            XNode caseNode = root.addChild("case");
            caseNode.addChild(marshalRunners(entry.getValue()));
            caseNode.addChild(marshalWorkItems(
                workItems.getOrDefault(entry.getKey(), Collections.emptyList()),
                entry.getKey()));
        }

        return root.toString();
    }

    // ============================================================
    // IDENTIFIER SERIALIZATION
    // ============================================================

    /**
     * Serializes an identifier to XNode format.
     *
     * @param id the identifier to serialize
     * @return XNode representation
     */
    public XNode marshalIdentifier(YIdentifier id) {
        XNode nID = new XNode("identifier");
        nID.addAttribute("id", id.toString());

        nID.addChild(marshalLocations(id));
        nID.addChild(marshalParent(id));
        nID.addChild(marshalChildren(id));

        return nID;
    }

    /**
     * Serializes identifier locations.
     *
     * @param id the identifier
     * @return XNode with location elements
     */
    private XNode marshalLocations(YIdentifier id) {
        XNode nLocations = new XNode("locations");
        for (String location : id.getLocationNames()) {
            nLocations.addChild("location", location);
        }
        return nLocations;
    }

    /**
     * Serializes parent reference.
     *
     * @param id the identifier
     * @return XNode with parent info
     */
    private XNode marshalParent(YIdentifier id) {
        YIdentifier parent = id.getParent();
        String parentID = parent != null ? parent.toString() : null;
        return new XNode("parent", parentID);
    }

    /**
     * Recursively serializes identifier children.
     *
     * @param id the identifier
     * @return XNode with child identifiers
     */
    private XNode marshalChildren(YIdentifier id) {
        XNode nChildren = new XNode("children");
        for (YIdentifier child : id.getChildren()) {
            if (child != null) {
                nChildren.addChild(marshalIdentifier(child));
            }
        }
        return nChildren;
    }

    // ============================================================
    // NET RUNNER SERIALIZATION
    // ============================================================

    /**
     * Serializes a list of net runners.
     *
     * @param runners the runners to serialize
     * @return XNode with runner elements
     */
    public XNode marshalRunners(List<YNetRunner> runners) {
        XNode nRunners = new XNode("runners");
        for (YNetRunner runner : runners) {
            nRunners.addChild(marshalRunner(runner));
        }
        return nRunners;
    }

    /**
     * Serializes a single net runner.
     *
     * @param runner the runner to serialize
     * @return XNode representation
     */
    public XNode marshalRunner(YNetRunner runner) {
        YIdentifier id = runner.getCaseID();
        XNode nRunner = new XNode("runner");

        nRunner.addChild(marshalParent(id));
        nRunner.addChild(marshalIdentifier(id));
        nRunner.addChild(marshalNetData(runner));
        nRunner.addChild(runner.getSpecificationID().toXNode());
        nRunner.addChild("containingtask", runner.getContainingTaskID());
        nRunner.addChild("starttime", runner.getStartTime());
        nRunner.addChild("observer", runner.get_caseObserverStr());
        nRunner.addChild("executionstatus", runner.getExecutionStatus().name());
        nRunner.addChild(marshalEnabledTasks(runner));
        nRunner.addChild(marshalBusyTasks(runner));
        nRunner.addChild(marshalTimerStates(runner.get_timerStates()));

        return nRunner;
    }

    /**
     * Serializes net data.
     *
     * @param runner the runner
     * @return XNode with net data
     */
    private XNode marshalNetData(YNetRunner runner) {
        XNode nData = new XNode("netdata");
        nData.addContent(runner.getNetData().getData());
        return nData;
    }

    /**
     * Serializes enabled task names.
     *
     * @param runner the runner
     * @return XNode with enabled tasks
     */
    private XNode marshalEnabledTasks(YNetRunner runner) {
        XNode nTasks = new XNode("enabledtasks");
        runner.getEnabledTaskNames().forEach(name -> nTasks.addChild("task", name));
        return nTasks;
    }

    /**
     * Serializes busy tasks with optional multi-instance data.
     *
     * @param runner the runner
     * @return XNode with busy tasks
     */
    private XNode marshalBusyTasks(YNetRunner runner) {
        XNode nTasks = new XNode("busytasks");
        runner.getBusyTasks().forEach(task -> {
            XNode nTask = nTasks.addChild("task");
            nTask.addChild("name", task.getID());
            if (task.isMultiInstance()) {
                String doc = task.getMIOutputData().getDataDocString();
                XNode miNode = nTask.addChild("midata");
                miNode.addContent(doc);
                miNode.addAttribute("uid", task.getMIOutputData().getUniqueIdentifier());
            }
        });
        return nTasks;
    }

    /**
     * Serializes timer states.
     *
     * @param timerStates map of task names to timer states
     * @return XNode with timer states
     */
    private XNode marshalTimerStates(Map<String, String> timerStates) {
        XNode nTimers = new XNode("timerstates");
        if (timerStates != null) {
            for (Map.Entry<String, String> entry : timerStates.entrySet()) {
                XNode nState = nTimers.addChild("timerstate");
                nState.addChild("taskname", entry.getKey());
                nState.addChild("state", entry.getValue());
            }
        }
        return nTimers;
    }

    // ============================================================
    // WORK ITEM SERIALIZATION
    // ============================================================

    /**
     * Serializes work items for a case.
     *
     * @param workItems the items to serialize
     * @param caseID the case identifier
     * @return XNode with work item elements
     */
    public XNode marshalWorkItems(List<YWorkItem> workItems, YIdentifier caseID) {
        XNode nItems = new XNode("workitems");
        for (YWorkItem item : workItems) {
            if (item != null) {
                nItems.addChild(marshalWorkItem(item));
            }
        }
        return nItems;
    }

    /**
     * Serializes a single work item.
     *
     * @param item the work item to serialize
     * @return XNode representation
     */
    public XNode marshalWorkItem(YWorkItem item) {
        XNode nItem = new XNode("item");

        nItem.addChild("id", item.get_thisID());
        nItem.addChild(item.getSpecificationID().toXNode());
        nItem.addChild("enablement", marshalTime(item.getEnablementTime()));
        nItem.addChild("firing", marshalTime(item.getFiringTime()));
        nItem.addChild("start", marshalTime(item.getStartTime()));
        nItem.addChild("status", item.getStatus().toString());
        nItem.addChild("prevstatus", item.get_prevStatus());
        nItem.addChild("client", item.get_externalClient());
        nItem.addChild("allowsdynamic", item.allowsDynamicCreation());
        nItem.addChild("manualresourcing", item.requiresManualResourcing());
        nItem.addChild(marshalWorkItemData(item));
        nItem.addChild("timerstarted", item.hasTimerStarted());
        nItem.addChild("timerexpiry", item.getTimerExpiry());
        nItem.addChild("deferredgroupid", item.getDeferredChoiceGroupID());
        nItem.addChild("codelet", item.getCodelet());
        nItem.addChild("parent", marshalWorkItemParent(item));

        return nItem;
    }

    /**
     * Serializes work item data.
     *
     * @param item the work item
     * @return XNode with data content
     */
    private XNode marshalWorkItemData(YWorkItem item) {
        XNode nData = new XNode("data");
        nData.addContent(item.get_dataString());
        return nData;
    }

    /**
     * Serializes work item parent reference.
     *
     * @param item the work item
     * @return parent ID or null
     */
    private String marshalWorkItemParent(YWorkItem item) {
        YWorkItem parent = item.getParent();
        return parent != null ? parent.get_thisID() : null;
    }

    /**
     * Serializes a timestamp.
     *
     * @param instant the timestamp
     * @return epoch milliseconds or 0
     */
    private long marshalTime(Instant instant) {
        return instant != null ? instant.toEpochMilli() : 0;
    }

    // ============================================================
    // UNMARSHALLING (XML -> Object)
    // ============================================================

{% if supports_jdom | default(value=true) %}
    /**
     * Parses XML string to JDOM Element.
     *
     * @param xml the XML string
     * @return root element
     * @throws SerializationException if parsing fails
     */
    public Element parseXML(String xml) throws SerializationException {
        try {
            SAXBuilder builder = new SAXBuilder();
            Document doc = builder.build(new StringReader(xml));
            return doc.getRootElement();
        } catch (JDOMException | IOException e) {
            throw new SerializationException("Failed to parse XML", e);
        }
    }

    /**
     * Extracts case identifiers from XML.
     *
     * @param root the root element
     * @return list of case ID strings
     */
    public List<String> unmarshalCaseIDs(Element root) {
        List<String> caseIDs = new ArrayList<>();
        for (Element caseElement : root.getChildren("case")) {
            Element runners = caseElement.getChild("runners");
            if (runners != null) {
                for (Element runner : runners.getChildren("runner")) {
                    Element identifier = runner.getChild("identifier");
                    if (identifier != null) {
                        caseIDs.add(identifier.getAttributeValue("id"));
                    }
                }
            }
        }
        return caseIDs;
    }

    /**
     * Unmarshals identifier locations from XML.
     *
     * @param identifierElement the identifier element
     * @return list of location names
     */
    public List<String> unmarshalLocations(Element identifierElement) {
        List<String> locations = new ArrayList<>();
        Element locationsElement = identifierElement.getChild("locations");
        if (locationsElement != null) {
            for (Element loc : locationsElement.getChildren("location")) {
                locations.add(loc.getTextTrim());
            }
        }
        return locations;
    }

    /**
     * Unmarshals work item status from string.
     *
     * @param statusStr the status string
     * @return YWorkItemStatus enum value
     */
    public YWorkItem.WorkItemStatus unmarshalStatus(String statusStr) {
        if (statusStr == null) return null;
        return YWorkItem.WorkItemStatus.fromString(statusStr);
    }
{% endif %}

{% if supports_xnode | default(value=true) %}
    /**
     * Parses XML string to XNode.
     *
     * @param xml the XML string
     * @return XNode root
     * @throws SerializationException if parsing fails
     */
    public XNode parseToXNode(String xml) throws SerializationException {
        try {
            return XNode.parse(xml);
        } catch (Exception e) {
            throw new SerializationException("Failed to parse XML to XNode", e);
        }
    }

    /**
     * Extracts child text values from XNode.
     *
     * @param parent the parent node
     * @param childName the child element name
     * @return list of text values
     */
    public List<String> extractChildTexts(XNode parent, String childName) {
        List<String> values = new ArrayList<>();
        for (XNode child : parent.getChildren(childName)) {
            values.add(child.getText());
        }
        return values;
    }

    /**
     * Extracts a single child text value.
     *
     * @param parent the parent node
     * @param childName the child element name
     * @return text value or null
     */
    public String extractChildText(XNode parent, String childName) {
        XNode child = parent.getChild(childName);
        return child != null ? child.getText() : null;
    }
{% endif %}

    // ============================================================
    // UTILITY METHODS
    // ============================================================

    /**
     * Formats XML with indentation.
     *
     * @param xml the XML string
     * @return formatted XML
     */
    public String formatXML(String xml) {
{% if supports_jdom | default(value=true) %}
        try {
            SAXBuilder builder = new SAXBuilder();
            Document doc = builder.build(new StringReader(xml));
            XMLOutputter outputter = new XMLOutputter(Format.getPrettyFormat());
            return outputter.outputString(doc);
        } catch (Exception e) {
            return xml;
        }
{% else %}
        return xml;
{% endif %}
    }

    /**
     * Validates XML structure.
     *
     * @param xml the XML to validate
     * @return true if valid
     */
    public boolean isValidXML(String xml) {
{% if supports_jdom | default(value=true) %}
        try {
            SAXBuilder builder = new SAXBuilder();
            builder.build(new StringReader(xml));
            return true;
        } catch (Exception e) {
            return false;
        }
{% else %}
        return xml != null && xml.startsWith("<");
{% endif %}
    }

    // ============================================================
    // EXCEPTION
    // ============================================================

    /**
     * Thrown when serialization or deserialization fails.
     */
    public static class SerializationException extends Exception {
        public SerializationException(String message) {
            super(message);
        }

        public SerializationException(String message, Throwable cause) {
            super(message, cause);
        }
    }

    // ============================================================
    // OBJECT CONTRACT
    // ============================================================

    @Override
    public String toString() {
        return "{{ class_name }}[version=" + FORMAT_VERSION + "]";
    }
}
