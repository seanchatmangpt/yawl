{#
 State Transition Code Generation Template for YAWL State Machine

 Generates type-safe state transition methods with validation.
 Supports finite state machine patterns with defined transitions.

 Template Parameters:
   - class_name: Name of the generated transition class
   - package: Java package name
   - states: Array of state definitions with name and transitions
   - initial_state: The starting state name
   - supports_listeners: Enable state change listeners
   - supports_persistence: Enable state persistence

 Usage:
   tera -t transition.tera -c '{"class_name":"WorkItemTransition","package":"org.yawlfoundation.yawl.engine"}'
-#}
/*
 * Copyright (c) 2004-{{ "now" | date(format="%Y") }} The YAWL Foundation. All rights reserved.
 * The YAWL Foundation is a collaboration of individuals and
 * organisations who are committed to improving workflow technology.
 *
 * This file is part of YAWL. YAWL is free software: you can
 * redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation.
 *
 * YAWL is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
 * Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with YAWL. If not, see <http://www.gnu.org/licenses/>.
 *
 * GENERATED BY: yawl-state/transition.tera
 * GENERATION TIMESTAMP: {{ "now" | date(format="%Y-%m-%dT%H:%M:%SZ") }}
 */

package {{ package }};

import java.util.*;
{% if supports_listeners | default(value=true) %}
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Consumer;
{% endif %}
{% if supports_persistence | default(value=true) %}
import org.yawlfoundation.yawl.engine.YPersistenceManager;
import org.yawlfoundation.yawl.exceptions.YPersistenceException;
{% endif %}

/**
 * {{ class_name }} - Type-Safe State Machine with Validated Transitions
 *
 * Implements a finite state machine (FSM) with explicitly defined state
 * transitions. Each state declares its allowed successor states, ensuring
 * only valid transitions can occur.
 *
 * <h2>State Machine Model</h2>
 * <pre>
 *   M = (S, S0, T, F)
 *   S = set of states
 *   S0 = initial state
 *   T = transition function: S x Event -> S
 *   F = final states
 * </pre>
 *
 * <h2>Thread Safety</h2>
 * All state transitions are synchronized to ensure thread-safe operation.
 * Listeners are notified after successful transitions.
 *
 * @author YAWL Code Generator
 * @since {{ version | default(value="5.2") }}
 */
public class {{ class_name }} {

    private static final long serialVersionUID = 1L;

    // ============================================================
    // STATE DEFINITIONS
    // ============================================================

{% for state in states %}
    /**
     * {{ state.description | default(value=state.name + " state") }}
     * Allowed transitions: {% for target in state.transitions %}{{ target }}{% if not loop.last %}, {% endif %}{% endfor %}
     */
    public static final String STATE_{{ state.name | upper }} = "{{ state.name }}";

{% endfor %}
    /** All defined states */
    private static final Set<String> ALL_STATES = Collections.unmodifiableSet(
        new HashSet<>(Arrays.asList(
{% for state in states %}
            STATE_{{ state.name | upper }}{% if not loop.last %},{% endif %}

{% endfor %}
        ))
    );

    // ============================================================
    // TRANSITION TABLE
    // ============================================================

    /**
     * Defines valid state transitions: Map<FromState, Set<ToState>>
     */
    private static final Map<String, Set<String>> TRANSITION_TABLE;

    static {
        Map<String, Set<String>> table = new HashMap<>();

{% for state in states %}
        table.put(STATE_{{ state.name | upper }}, new HashSet<>(Arrays.asList(
{% for target in state.transitions %}
            STATE_{{ target | upper }}{% if not loop.last %},{% endif %}

{% endfor %}
        )));
{% endfor %}

        TRANSITION_TABLE = Collections.unmodifiableMap(table);
    }

    // ============================================================
    // INSTANCE FIELDS
    // ============================================================

    /** Current state */
    private volatile String _currentState;

    /** Previous state (for rollback support) */
    private String _previousState;

    /** Timestamp of last state change */
    private long _lastStateChangeTime;

    /** State change history (bounded) */
    private final LinkedList<StateChangeRecord> _history;

    /** Maximum history size */
    private static final int MAX_HISTORY_SIZE = 100;

{% if supports_listeners | default(value=true) %}
    /** State change listeners */
    private final List<StateChangeListener> _listeners;
{% endif %}

{% if supports_persistence | default(value=true) %}
    /** Persistence manager reference */
    private transient YPersistenceManager _pmgr;
{% endif %}

    // ============================================================
    // CONSTRUCTORS
    // ============================================================

    /**
     * Creates a new state machine instance with the initial state.
     */
    public {{ class_name }}() {
{% if initial_state %}
        _currentState = STATE_{{ initial_state | upper }};
{% else %}
        _currentState = STATE_{{ states[0].name | upper }};
{% endif %}
        _previousState = null;
        _lastStateChangeTime = System.currentTimeMillis();
        _history = new LinkedList<>();
{% if supports_listeners | default(value=true) %}
        _listeners = new CopyOnWriteArrayList<>();
{% endif %}
        recordStateChange(null, _currentState, "Initialization");
    }

{% if supports_persistence | default(value=true) %}
    /**
     * Creates a state machine with persistence support.
     *
     * @param pmgr the persistence manager
     */
    public {{ class_name }}(YPersistenceManager pmgr) {
        this();
        _pmgr = pmgr;
    }
{% endif %}

    // ============================================================
    // STATE ACCESSORS
    // ============================================================

    /**
     * Returns the current state.
     *
     * @return the current state name
     */
    public String getCurrentState() {
        return _currentState;
    }

    /**
     * Returns the previous state.
     *
     * @return the previous state name, or null if no transitions
     */
    public String getPreviousState() {
        return _previousState;
    }

    /**
     * Returns the timestamp of the last state change.
     *
     * @return epoch milliseconds
     */
    public long getLastStateChangeTime() {
        return _lastStateChangeTime;
    }

    /**
     * Checks if the machine is in a specific state.
     *
     * @param state the state to check
     * @return true if current state matches
     */
    public boolean isInState(String state) {
        return _currentState.equals(state);
    }

    /**
     * Checks if this is a final/terminal state.
     *
     * @return true if no transitions available
     */
    public boolean isFinalState() {
        Set<String> transitions = TRANSITION_TABLE.get(_currentState);
        return transitions == null || transitions.isEmpty();
    }

    /**
     * Returns all valid target states from current state.
     *
     * @return set of valid target states
     */
    public Set<String> getValidTransitions() {
        Set<String> transitions = TRANSITION_TABLE.get(_currentState);
        return transitions != null
            ? Collections.unmodifiableSet(transitions)
            : Collections.emptySet();
    }

    /**
     * Checks if a transition to the target state is valid.
     *
     * @param targetState the target state
     * @return true if transition is allowed
     */
    public boolean canTransitionTo(String targetState) {
        Set<String> validTransitions = TRANSITION_TABLE.get(_currentState);
        return validTransitions != null && validTransitions.contains(targetState);
    }

    // ============================================================
    // STATE TRANSITIONS
    // ============================================================

    /**
     * Attempts to transition to a new state.
     *
     * @param newState the target state
     * @return true if transition succeeded
     * @throws InvalidTransitionException if transition is not allowed
     */
    public synchronized boolean transitionTo(String newState) {
        return transitionTo(newState, null);
    }

    /**
     * Attempts to transition to a new state with a reason.
     *
     * @param newState the target state
     * @param reason optional reason for the transition
     * @return true if transition succeeded
     * @throws InvalidTransitionException if transition is not allowed
     */
    public synchronized boolean transitionTo(String newState, String reason) {
        // Validate target state
        if (!ALL_STATES.contains(newState)) {
            throw new InvalidTransitionException(
                "Unknown state: " + newState + ". Valid states: " + ALL_STATES);
        }

        // Check if same state (no-op)
        if (_currentState.equals(newState)) {
            return true;
        }

        // Validate transition
        if (!canTransitionTo(newState)) {
            throw new InvalidTransitionException(String.format(
                "Invalid transition: %s -> %s. Valid transitions: %s",
                _currentState, newState, getValidTransitions()));
        }

        // Record the transition
        String oldState = _currentState;
        _previousState = oldState;
        _currentState = newState;
        _lastStateChangeTime = System.currentTimeMillis();

        recordStateChange(oldState, newState, reason);

{% if supports_persistence | default(value=true) %}
        persistState();
{% endif %}

        // Notify listeners
        notifyListeners(oldState, newState, reason);

        return true;
    }

    /**
     * Forcefully sets the state without validation.
     * Use with caution - bypasses transition rules.
     *
     * @param newState the target state
     * @param reason reason for forced transition
     */
    public synchronized void forceState(String newState, String reason) {
        if (!ALL_STATES.contains(newState)) {
            throw new InvalidTransitionException("Unknown state: " + newState);
        }

        String oldState = _currentState;
        _previousState = oldState;
        _currentState = newState;
        _lastStateChangeTime = System.currentTimeMillis();

        recordStateChange(oldState, newState, "FORCED: " + reason);

{% if supports_persistence | default(value=true) %}
        persistState();
{% endif %}

        notifyListeners(oldState, newState, "FORCED: " + reason);
    }

    /**
     * Rolls back to the previous state.
     *
     * @return true if rollback succeeded
     */
    public synchronized boolean rollback() {
        if (_previousState == null) {
            return false;
        }

        String current = _currentState;
        _currentState = _previousState;
        _previousState = current;
        _lastStateChangeTime = System.currentTimeMillis();

        recordStateChange(current, _previousState, "Rollback");

{% if supports_persistence | default(value=true) %}
        persistState();
{% endif %}

        notifyListeners(current, _previousState, "Rollback");

        return true;
    }

    // ============================================================
    {% if supports_listeners | default(value=true) -%}
    // LISTENER SUPPORT
    // ============================================================

    /**
     * Adds a state change listener.
     *
     * @param listener the listener to add
     */
    public void addListener(StateChangeListener listener) {
        if (listener != null) {
            _listeners.add(listener);
        }
    }

    /**
     * Removes a state change listener.
     *
     * @param listener the listener to remove
     */
    public void removeListener(StateChangeListener listener) {
        _listeners.remove(listener);
    }

    /**
     * Removes all listeners.
     */
    public void clearListeners() {
        _listeners.clear();
    }

    /**
     * Notifies all listeners of a state change.
     */
    private void notifyListeners(String oldState, String newState, String reason) {
        if (_listeners.isEmpty()) {
            return;
        }

        StateChangeEvent event = new StateChangeEvent(
            this, oldState, newState, reason, _lastStateChangeTime);

        for (StateChangeListener listener : _listeners) {
            try {
                listener.onStateChange(event);
            } catch (Exception e) {
                // Log but don't propagate listener exceptions
                System.err.println("Listener exception: " + e.getMessage());
            }
        }
    }
    {% endif %}

    // ============================================================
    // HISTORY
    // ============================================================

    /**
     * Records a state change in history.
     */
    private void recordStateChange(String fromState, String toState, String reason) {
        _history.addFirst(new StateChangeRecord(
            fromState, toState, reason, System.currentTimeMillis()));

        // Trim history if too large
        while (_history.size() > MAX_HISTORY_SIZE) {
            _history.removeLast();
        }
    }

    /**
     * Returns the state change history.
     *
     * @return unmodifiable list of state changes (most recent first)
     */
    public List<StateChangeRecord> getHistory() {
        return Collections.unmodifiableList(_history);
    }

    /**
     * Clears the state history.
     */
    public void clearHistory() {
        _history.clear();
    }

{% if supports_persistence | default(value=true) %}
    // ============================================================
    // PERSISTENCE
    // ============================================================

    /**
     * Sets the persistence manager.
     *
     * @param pmgr the persistence manager
     */
    public void setPersistenceManager(YPersistenceManager pmgr) {
        _pmgr = pmgr;
    }

    /**
     * Persists the current state.
     */
    private void persistState() {
        if (_pmgr != null) {
            try {
                _pmgr.updateObjectExternal(this);
            } catch (YPersistenceException e) {
                System.err.println("Failed to persist state: " + e.getMessage());
            }
        }
    }
{% endif %}

    // ============================================================
    // STATE CHANGE RECORD
    // ============================================================

    /**
     * Represents a single state change event.
     */
    public static class StateChangeRecord {
        private final String fromState;
        private final String toState;
        private final String reason;
        private final long timestamp;

        public StateChangeRecord(String fromState, String toState, String reason, long timestamp) {
            this.fromState = fromState;
            this.toState = toState;
            this.reason = reason;
            this.timestamp = timestamp;
        }

        public String getFromState() { return fromState; }
        public String getToState() { return toState; }
        public String getReason() { return reason; }
        public long getTimestamp() { return timestamp; }

        @Override
        public String toString() {
            return String.format("StateChange[%s -> %s] at %d (%s)",
                fromState, toState, timestamp, reason);
        }
    }

{% if supports_listeners | default(value=true) %}
    // ============================================================
    // STATE CHANGE EVENT
    // ============================================================

    /**
     * Event object passed to state change listeners.
     */
    public static class StateChangeEvent {
        private final {{ class_name }} source;
        private final String oldState;
        private final String newState;
        private final String reason;
        private final long timestamp;

        public StateChangeEvent({{ class_name }} source, String oldState,
                                String newState, String reason, long timestamp) {
            this.source = source;
            this.oldState = oldState;
            this.newState = newState;
            this.reason = reason;
            this.timestamp = timestamp;
        }

        public {{ class_name }} getSource() { return source; }
        public String getOldState() { return oldState; }
        public String getNewState() { return newState; }
        public String getReason() { return reason; }
        public long getTimestamp() { return timestamp; }
    }

    // ============================================================
    // STATE CHANGE LISTENER
    // ============================================================

    /**
     * Interface for state change notifications.
     */
    @FunctionalInterface
    public interface StateChangeListener {
        void onStateChange(StateChangeEvent event);
    }
{% endif %}

    // ============================================================
    // EXCEPTION
    // ============================================================

    /**
     * Thrown when an invalid state transition is attempted.
     */
    public static class InvalidTransitionException extends RuntimeException {
        public InvalidTransitionException(String message) {
            super(message);
        }

        public InvalidTransitionException(String message, Throwable cause) {
            super(message, cause);
        }
    }

    // ============================================================
    // OBJECT CONTRACT
    // ============================================================

    @Override
    public String toString() {
        return String.format("{{ class_name }}[state=%s, previous=%s]",
            _currentState, _previousState);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof {{ class_name }})) return false;
        {{ class_name }} other = ({{ class_name }}) obj;
        return Objects.equals(_currentState, other._currentState);
    }

    @Override
    public int hashCode() {
        return Objects.hash(_currentState);
    }
}
