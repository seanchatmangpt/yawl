{#
 Internal Condition Code Generation Template for YAWL State Machine

 Generates multi-instance condition classes for YAWL tasks.
 Supports mi_active, mi_entered, mi_executing, mi_complete conditions.

 Template Parameters:
   - class_name: Name of the generated condition class
   - package: Java package name
   - condition_types: Array of condition type definitions
   - supports_persistence: Enable persistence support
   - supports_xml: Enable XML serialization

 Usage:
   tera -t internal-condition.tera -c '{"class_name":"YInternalCondition","package":"org.yawlfoundation.yawl.elements.state"}'
-#}
/*
 * Copyright (c) 2004-{{ "now" | date(format="%Y") }} The YAWL Foundation. All rights reserved.
 * The YAWL Foundation is a collaboration of individuals and
 * organisations who are committed to improving workflow technology.
 *
 * This file is part of YAWL. YAWL is free software: you can
 * redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation.
 *
 * YAWL is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
 * Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with YAWL. If not, see <http://www.gnu.org/licenses/>.
 *
 * GENERATED BY: yawl-state/internal-condition.tera
 * GENERATION TIMESTAMP: {{ "now" | date(format="%Y-%m-%dT%H:%M:%SZ") }}
 */

package {{ package }};

import org.yawlfoundation.yawl.elements.YConditionInterface;
import org.yawlfoundation.yawl.elements.YNetElement;
import org.yawlfoundation.yawl.elements.YTask;
import org.yawlfoundation.yawl.engine.YPersistenceManager;
import org.yawlfoundation.yawl.exceptions.YPersistenceException;
import org.yawlfoundation.yawl.exceptions.YStateException;
{% if supports_xml | default(value=true) %}
import org.yawlfoundation.yawl.util.XNode;
{% endif %}
import org.yawlfoundation.yawl.util.YIdentifierBag;

import java.util.List;
import java.util.Objects;

/**
 * {{ class_name }} - Multi-Instance Task Internal Condition
 *
 * Represents internal conditions used by multi-instance tasks to track
 * the lifecycle of instance execution. Each multi-instance task has four
 * internal conditions for managing token flow.
 *
 * <h2>Condition Types</h2>
 * <ul>
 *   <li><b>mi_active</b>: Tokens waiting to be processed</li>
 *   <li><b>mi_entered</b>: Tokens that have entered the task</li>
 *   <li><b>mi_executing</b>: Tokens currently executing</li>
 *   <li><b>mi_complete</b>: Tokens that have completed</li>
 * </ul>
 *
 * <h2>Multi-Instance Semantics</h2>
 * <pre>
 *   mi_active --[enable]--> mi_entered --[start]--> mi_executing --[complete]--> mi_complete
 *        |                                                          |
 *        +------------------[cancel]-------------------------------+
 * </pre>
 *
 * @author YAWL Code Generator
 * @since {{ version | default(value="5.2") }}
 */
public class {{ class_name }} extends YNetElement implements YConditionInterface {

    private static final long serialVersionUID = 1L;

    // ============================================================
    // CONDITION TYPE CONSTANTS
    // ============================================================

{% for condition in condition_types %}
    /**
     * {{ condition.description | default(value=condition.name + " condition") }}
     */
    public static final String {{ condition.name | upper }} = "{{ condition.name }}";

{% endfor %}
    /** Default condition types for multi-instance tasks */
    public static final String MI_ACTIVE = "mi_active";
    public static final String MI_ENTERED = "mi_entered";
    public static final String MI_EXECUTING = "mi_executing";
    public static final String MI_COMPLETE = "mi_complete";

    // ============================================================
    // INSTANCE FIELDS
    // ============================================================

    /** Bag holding the identifiers in this condition */
    private final YIdentifierBag _bag;

    /** The task that owns this condition */
    private final YTask _myTask;

    /** The type of this condition */
    private final String _conditionType;

    // ============================================================
    // CONSTRUCTORS
    // ============================================================

    /**
     * Creates a new internal condition for a task.
     *
     * @param id the unique identifier for this condition
     * @param myTask the owning task
     * @throws NullPointerException if id or myTask is null
     */
    public {{ class_name }}(String id, YTask myTask) {
        this(id, myTask, MI_ACTIVE);
    }

    /**
     * Creates a new internal condition with a specific type.
     *
     * @param id the unique identifier for this condition
     * @param myTask the owning task
     * @param conditionType the type of condition
     * @throws NullPointerException if any parameter is null
     */
    public {{ class_name }}(String id, YTask myTask, String conditionType) {
        super(id);
        Objects.requireNonNull(myTask, "Task cannot be null");
        Objects.requireNonNull(conditionType, "Condition type cannot be null");

        _bag = new YIdentifierBag(this);
        _myTask = myTask;
        _conditionType = conditionType;
    }

    // ============================================================
    // ACCESSORS
    // ============================================================

    /**
     * Returns the owning task.
     *
     * @return the task
     */
    public YTask getTask() {
        return _myTask;
    }

    /**
     * Returns the condition type.
     *
     * @return the condition type string
     */
    public String getConditionType() {
        return _conditionType;
    }

    /**
     * Checks if this is an active condition.
     *
     * @return true if mi_active type
     */
    public boolean isActiveCondition() {
        return MI_ACTIVE.equals(_conditionType);
    }

    /**
     * Checks if this is an entered condition.
     *
     * @return true if mi_entered type
     */
    public boolean isEnteredCondition() {
        return MI_ENTERED.equals(_conditionType);
    }

    /**
     * Checks if this is an executing condition.
     *
     * @return true if mi_executing type
     */
    public boolean isExecutingCondition() {
        return MI_EXECUTING.equals(_conditionType);
    }

    /**
     * Checks if this is a complete condition.
     *
     * @return true if mi_complete type
     */
    public boolean isCompleteCondition() {
        return MI_COMPLETE.equals(_conditionType);
    }

    // ============================================================
    // IDENTIFIER MANAGEMENT
    // ============================================================

    /**
     * Adds an identifier to this condition.
     *
     * @param pmgr the persistence manager (may be null)
     * @param identifier the identifier to add
     * @throws YPersistenceException if persistence fails
     * @throws NullPointerException if identifier is null
     */
    public void add(YPersistenceManager pmgr, YIdentifier identifier)
            throws YPersistenceException {
        Objects.requireNonNull(identifier, "Identifier cannot be null");
        _bag.addIdentifier(pmgr, identifier);
    }

    /**
     * Checks if this condition contains the identifier.
     *
     * @param identifier the identifier to check
     * @return true if contained
     */
    public boolean contains(YIdentifier identifier) {
        return _bag.contains(identifier);
    }

    /**
     * Checks if this condition contains any identifiers.
     *
     * @return true if not empty
     */
    public boolean containsIdentifier() {
        return !_bag.getIdentifiers().isEmpty();
    }

    /**
     * Returns the count of a specific identifier.
     *
     * @param identifier the identifier to count
     * @return the number of matching identifiers
     */
    public int getAmount(YIdentifier identifier) {
        return _bag.getAmount(identifier);
    }

    /**
     * Returns all identifiers in this condition.
     *
     * @return list of identifiers
     */
    public List<YIdentifier> getIdentifiers() {
        return _bag.getIdentifiers();
    }

    /**
     * Returns the total number of identifiers.
     *
     * @return identifier count
     */
    public int size() {
        return _bag.getIdentifiers().size();
    }

    /**
     * Checks if this condition is empty.
     *
     * @return true if no identifiers
     */
    public boolean isEmpty() {
        return _bag.getIdentifiers().isEmpty();
    }

    // ============================================================
    // IDENTIFIER REMOVAL
    // ============================================================

    /**
     * Removes and returns one identifier from this condition.
     *
     * @param pmgr the persistence manager
     * @return the removed identifier
     * @throws YPersistenceException if persistence fails
     * @throws IllegalStateException if condition is empty
     */
    public YIdentifier removeOne(YPersistenceManager pmgr) throws YPersistenceException {
        List<YIdentifier> identifiers = getIdentifiers();
        if (identifiers.isEmpty()) {
            throw new IllegalStateException("Cannot remove from empty condition");
        }

        YIdentifier id = identifiers.get(0);
        _bag.remove(pmgr, id, 1);
        return id;
    }

    /**
     * Removes one specific identifier from this condition.
     *
     * @param pmgr the persistence manager
     * @param identifier the identifier to remove
     * @throws YPersistenceException if persistence fails
     */
    public void removeOne(YPersistenceManager pmgr, YIdentifier identifier)
            throws YPersistenceException {
        _bag.remove(pmgr, identifier, 1);
    }

    /**
     * Removes a specific amount of identifiers.
     *
     * @param pmgr the persistence manager
     * @param identifier the identifier type to remove
     * @param amount the number to remove
     * @throws YStateException if amount exceeds available
     * @throws YPersistenceException if persistence fails
     */
    public void remove(YPersistenceManager pmgr, YIdentifier identifier, int amount)
            throws YStateException, YPersistenceException {
        _bag.remove(pmgr, identifier, amount);
    }

    /**
     * Removes all instances of a specific identifier.
     *
     * @param pmgr the persistence manager
     * @param identifier the identifier to remove all of
     * @throws YPersistenceException if persistence fails
     */
    public void removeAll(YPersistenceManager pmgr, YIdentifier identifier)
            throws YPersistenceException {
        _bag.remove(pmgr, identifier, _bag.getAmount(identifier));
    }

    /**
     * Removes all identifiers from this condition.
     *
     * @param pmgr the persistence manager
     * @throws YPersistenceException if persistence fails
     */
    public void removeAll(YPersistenceManager pmgr) throws YPersistenceException {
        _bag.removeAll(pmgr);
    }

    // ============================================================
    // TRANSFER OPERATIONS
    // ============================================================

    /**
     * Moves all identifiers to another condition.
     *
     * @param pmgr the persistence manager
     * @param target the target condition
     * @throws YPersistenceException if persistence fails
     */
    public void transferAllTo(YPersistenceManager pmgr, {{ class_name }} target)
            throws YPersistenceException {
        Objects.requireNonNull(target, "Target condition cannot be null");

        for (YIdentifier id : getIdentifiers()) {
            target.add(pmgr, id);
        }
        removeAll(pmgr);
    }

    /**
     * Moves one identifier to another condition.
     *
     * @param pmgr the persistence manager
     * @param target the target condition
     * @return the transferred identifier
     * @throws YPersistenceException if persistence fails
     */
    public YIdentifier transferOneTo(YPersistenceManager pmgr, {{ class_name }} target)
            throws YPersistenceException {
        YIdentifier id = removeOne(pmgr);
        target.add(pmgr, id);
        return id;
    }

    // ============================================================
    {% if supports_xml | default(value=true) -%}
    // XML SERIALIZATION
    // ============================================================

    /**
     * Returns XML representation of this condition.
     *
     * @return XML string
     */
    public String toXML() {
        return toXNode().toString();
    }

    /**
     * Returns XNode representation of this condition.
     *
     * @return XNode with condition data
     */
    public XNode toXNode() {
        XNode node = new XNode("internalCondition");
        node.addAttribute("id", toString());
        node.addAttribute("type", _conditionType);

        for (YIdentifier identifier : getIdentifiers()) {
            XNode idNode = node.addChild("identifier");
            idNode.addContent(identifier.toString());
        }

        return node;
    }
    {% endif %}

    // ============================================================
    // OBJECT CONTRACT
    // ============================================================

    @Override
    public String toString() {
        return getID() + "[" + _myTask.getID() + ":" + _conditionType + "]";
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof {{ class_name }})) return false;

        {{ class_name }} other = ({{ class_name }}) obj;
        return getID().equals(other.getID())
            && _myTask.getID().equals(other._myTask.getID());
    }

    @Override
    public int hashCode() {
        return Objects.hash(getID(), _myTask.getID());
    }

    // ============================================================
    // CONDITION FACTORY
    // ============================================================

    /**
     * Creates all four standard internal conditions for a task.
     *
     * @param task the task to create conditions for
     * @return map of condition type to condition instance
     */
    public static Map<String, {{ class_name }}> createStandardConditions(YTask task) {
        Map<String, {{ class_name }}> conditions = new java.util.LinkedHashMap<>();
        String taskID = task.getID();

        conditions.put(MI_ACTIVE,
            new {{ class_name }}(taskID + "_" + MI_ACTIVE, task, MI_ACTIVE));
        conditions.put(MI_ENTERED,
            new {{ class_name }}(taskID + "_" + MI_ENTERED, task, MI_ENTERED));
        conditions.put(MI_EXECUTING,
            new {{ class_name }}(taskID + "_" + MI_EXECUTING, task, MI_EXECUTING));
        conditions.put(MI_COMPLETE,
            new {{ class_name }}(taskID + "_" + MI_COMPLETE, task, MI_COMPLETE));

        return conditions;
    }

    /**
     * Gets a specific condition type from a map.
     *
     * @param conditions the conditions map
     * @param type the type to get
     * @return the condition or null
     */
    public static {{ class_name }} getCondition(Map<String, {{ class_name }}> conditions, String type) {
        return conditions.get(type);
    }

    /**
     * Returns all valid condition types.
     *
     * @return set of condition type names
     */
    public static Set<String> getValidConditionTypes() {
        return Collections.unmodifiableSet(
            new java.util.HashSet<>(Arrays.asList(
                MI_ACTIVE, MI_ENTERED, MI_EXECUTING, MI_COMPLETE
            ))
        );
    }
}
