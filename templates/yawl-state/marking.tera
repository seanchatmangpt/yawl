{#
 YMarking Code Generation Template for YAWL State Machine

 Generates immutable value objects representing Petri net markings.
 A marking is a multiset of tokens distributed across net locations.

 Template Parameters:
   - class_name: Name of the generated marking class
   - package: Java package name
   - locations_type: Type for location collection (List, Set, etc.)
   - net_element_type: Base type for net elements (YNetElement)
   - custom_methods: Array of additional method definitions
   - implements: Array of interfaces to implement

 Usage:
   tera -t marking.tera -c '{"class_name":"YMarking","package":"org.yawlfoundation.yawl.elements.state"}'
-#}
/*
 * Copyright (c) 2004-{{ "now" | date(format="%Y") }} The YAWL Foundation. All rights reserved.
 * The YAWL Foundation is a collaboration of individuals and
 * organisations who are committed to improving workflow technology.
 *
 * This file is part of YAWL. YAWL is free software: you can
 * redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation.
 *
 * YAWL is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
 * Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with YAWL. If not, see <http://www.gnu.org/licenses/>.
 *
 * GENERATED BY: yawl-state/marking.tera
 * GENERATION TIMESTAMP: {{ "now" | date(format="%Y-%m-%dT%H:%M:%SZ") }}
 */

package {{ package }};

import org.yawlfoundation.yawl.elements.YNetElement;
import org.yawlfoundation.yawl.elements.YExternalNetElement;
import org.yawlfoundation.yawl.elements.YCondition;
import org.yawlfoundation.yawl.elements.YTask;
import org.yawlfoundation.yawl.elements.YNet;

import java.util.*;
{% if implements contains "Serializable" %}
import java.io.Serializable;
{% endif %}

/**
 * {{ class_name }} - Immutable Petri Net Marking Value Object
 *
 * A marking represents the state of a Petri net by recording the distribution
 * of tokens across net locations (conditions and tasks). This is a multiset
 * representation where the same location may appear multiple times.
 *
 * <h2>Petri Net Semantics</h2>
 * <ul>
 *   <li>Marking M: P -> N (mapping from places to natural numbers)</li>
 *   <li>M0 = initial marking</li>
 *   <li>M[t> M' = marking M enables transition t, producing M'</li>
 * </ul>
 *
 * <h2>YAWL Extensions</h2>
 * <ul>
 *   <li>Locations can be conditions (places) or tasks (transitions in progress)</li>
 *   <li>Supports OR-join analysis through reachability calculations</li>
 *   <li>Enables deadlock detection for workflow verification</li>
 * </ul>
 *
 * @author YAWL Code Generator
 * @since {{ version | default(value="5.2") }}
 */
{% if implements is empty %}
public class {{ class_name }} {
{% else %}
public class {{ class_name }} implements {{ implements | join(sep=", ") }} {
{% endif %}

    private static final long serialVersionUID = 1L;

    /**
     * The multiset of locations containing tokens.
     * Using List to allow duplicate entries (multiset semantics).
     */
    private final List<{{ net_element_type | default(value="YNetElement") }}> _locations;

    // ============================================================
    // CONSTRUCTORS
    // ============================================================

    /**
     * Creates a marking from an identifier's current locations.
     *
     * @param identifier the identifier whose locations define this marking
     * @throws NullPointerException if identifier is null
     */
    public {{ class_name }}(YIdentifier identifier) {
        this(identifier.getLocations());
    }

    /**
     * Creates a marking from a collection of locations.
     * The collection is defensively copied to preserve immutability.
     *
     * @param locations the initial locations for this marking
     * @throws NullPointerException if locations is null
     */
    public {{ class_name }}(List<{{ net_element_type | default(value="YNetElement") }}> locations) {
        Objects.requireNonNull(locations, "Locations cannot be null");
        _locations = new ArrayList<>(locations);
    }

    /**
     * Creates an empty marking (no tokens).
     */
    public {{ class_name }}() {
        _locations = new ArrayList<>();
    }

    /**
     * Copy constructor for creating independent marking instances.
     *
     * @param other the marking to copy
     * @throws NullPointerException if other is null
     */
    public {{ class_name }}({{ class_name }} other) {
        Objects.requireNonNull(other, "Source marking cannot be null");
        _locations = new ArrayList<>(other._locations);
    }

    // ============================================================
    // ACCESSORS
    // ============================================================

    /**
     * Returns an unmodifiable view of the locations in this marking.
     *
     * @return unmodifiable list of locations
     */
    public List<{{ net_element_type | default(value="YNetElement") }}> getLocations() {
        return Collections.unmodifiableList(_locations);
    }

    /**
     * Returns the number of tokens in this marking.
     *
     * @return total token count across all locations
     */
    public int size() {
        return _locations.size();
    }

    /**
     * Checks if this marking has no tokens.
     *
     * @return true if no locations contain tokens
     */
    public boolean isEmpty() {
        return _locations.isEmpty();
    }

    /**
     * Checks if a specific location contains at least one token.
     *
     * @param location the location to check
     * @return true if location has one or more tokens
     */
    public boolean contains({{ net_element_type | default(value="YNetElement") }} location) {
        return _locations.contains(location);
    }

    /**
     * Counts the number of tokens at a specific location.
     *
     * @param location the location to count tokens for
     * @return the token count at the location
     */
    public int countTokens({{ net_element_type | default(value="YNetElement") }} location) {
        int count = 0;
        for ({{ net_element_type | default(value="YNetElement") }} loc : _locations) {
            if (loc.equals(location)) {
                count++;
            }
        }
        return count;
    }

    // ============================================================
    // MARKING OPERATIONS (Immutable - return new instances)
    // ============================================================

    /**
     * Returns a new marking with a token added to the specified location.
     *
     * @param location the location to add a token to
     * @return new marking with the added token
     * @throws NullPointerException if location is null
     */
    public {{ class_name }} withAddedLocation({{ net_element_type | default(value="YNetElement") }} location) {
        Objects.requireNonNull(location, "Location cannot be null");
        {{ class_name }} newMarking = new {{ class_name }}(this);
        newMarking._locations.add(location);
        return newMarking;
    }

    /**
     * Returns a new marking with a token removed from the specified location.
     * If the location is not present, returns this marking unchanged.
     *
     * @param location the location to remove a token from
     * @return new marking with the token removed
     */
    public {{ class_name }} withRemovedLocation({{ net_element_type | default(value="YNetElement") }} location) {
        if (!_locations.contains(location)) {
            return this;
        }
        {{ class_name }} newMarking = new {{ class_name }}(this);
        newMarking._locations.remove(location);
        return newMarking;
    }

    /**
     * Returns a new marking with all tokens from a collection removed.
     *
     * @param locations the locations to remove tokens from
     * @return new marking with tokens removed
     */
    public {{ class_name }} withAllRemoved(Collection<{{ net_element_type | default(value="YNetElement") }}> locations) {
        {{ class_name }} newMarking = new {{ class_name }}(this);
        newMarking._locations.removeAll(locations);
        return newMarking;
    }

    /**
     * Returns a new marking with all tokens from another marking added.
     *
     * @param other the marking to add
     * @return new marking with combined tokens
     */
    public {{ class_name }} plus({{ class_name }} other) {
        {{ class_name }} result = new {{ class_name }}(this);
        result._locations.addAll(other._locations);
        return result;
    }

    // ============================================================
    // REACHABILITY AND TASK ENABLEMENT
    // ============================================================

    /**
     * Calculates all markings reachable in one step by firing a task.
     *
     * @param task the task to fire
     * @param orJoin the OR-join being analyzed (for cycle detection)
     * @return set of reachable markings, or null if task not enabled
     */
    public YSetOfMarkings reachableInOneStep(YTask task, YTask orJoin) {
        YSetOfMarkings halfBakedSet;

        if (_locations.contains(task)) {
            {{ class_name }} aMarking = new {{ class_name }}(this);
            aMarking._locations.remove(task);
            halfBakedSet = new YSetOfMarkings();
            halfBakedSet.addMarking(aMarking);
        } else {
            halfBakedSet = calculatePreliminaryMarkingSet(task);
        }

        if (halfBakedSet == null) {
            return null;
        }

        // Apply cancellation set for each intermediate marking
        for ({{ class_name }} halfbakedMarking : halfBakedSet.getMarkings()) {
            halfbakedMarking._locations.removeAll(task.getRemoveSet());
        }

        Set<{{ class_name }}> iterableHalfBakedSet = halfBakedSet.getMarkings();
        YSetOfMarkings finishedSet = new YSetOfMarkings();
        Set<YExternalNetElement> postset = task.getPostsetElements();

        switch (task.getSplitType()) {
            case YTask._AND:
            case YTask._OR:
                for ({{ class_name }} marking : iterableHalfBakedSet) {
                    marking._locations.addAll(postset);
                    finishedSet.addMarking(marking);
                }
                break;

            case YTask._XOR:
                for ({{ class_name }} halfbakedMarking : iterableHalfBakedSet) {
                    for (YExternalNetElement element : postset) {
                        {{ class_name }} aFinalMarking = new {{ class_name }}(halfbakedMarking.getLocations());
                        aFinalMarking._locations.add((YCondition) element);
                        finishedSet.addMarking(aFinalMarking);
                    }
                }
                break;

            default:
                throw new IllegalStateException("Unknown split type: " + task.getSplitType());
        }

        return finishedSet;
    }

    /**
     * Checks if this marking enables a non-OR-join task.
     *
     * @param task the task to check
     * @return true if the task is enabled
     * @throws IllegalArgumentException if task has OR-join
     */
    public boolean nonOrJoinEnabled(YTask task) {
        if (_locations.contains(task)) {
            return true;
        }

        Set<YExternalNetElement> preset = task.getPresetElements();
        int joinType = task.getJoinType();

        switch (joinType) {
            case YTask._AND:
                return _locations.containsAll(preset);

            case YTask._OR:
                throw new IllegalArgumentException(
                    "nonOrJoinEnabled should never be called on an OR-Join");

            case YTask._XOR:
                for (YExternalNetElement element : preset) {
                    if (_locations.contains(element)) {
                        return true;
                    }
                }
                return false;

            default:
                return false;
        }
    }

    /**
     * Calculates preliminary marking set based on join type.
     */
    private YSetOfMarkings calculatePreliminaryMarkingSet(YTask task) {
        Set<YExternalNetElement> preset = task.getPresetElements();
        YSetOfMarkings markingSet = new YSetOfMarkings();
        int joinType = task.getJoinType();

        switch (joinType) {
            case YTask._AND:
                if (!nonOrJoinEnabled(task)) {
                    return null;
                }
                {{ class_name }} returnedMarking = new {{ class_name }}(this);
                for (YExternalNetElement element : preset) {
                    returnedMarking._locations.remove(element);
                }
                markingSet.addMarking(returnedMarking);
                break;

            case YTask._OR:
                throw new IllegalArgumentException(
                    "reachableInOneStep should handle OR-join differently");

            case YTask._XOR:
                if (!nonOrJoinEnabled(task)) {
                    return null;
                }
                for (YExternalNetElement element : preset) {
                    if (_locations.contains(element)) {
                        {{ class_name }} xorMarking = new {{ class_name }}(this);
                        xorMarking._locations.remove(element);
                        markingSet.addMarking(xorMarking);
                    }
                }
                break;
        }

        return markingSet;
    }

    // ============================================================
    // MARKING COMPARISON
    // ============================================================

    /**
     * Checks if this marking is equivalent to another (same multiset).
     *
     * @param marking the marking to compare
     * @return true if markings are equivalent
     */
    public boolean equivalentTo({{ class_name }} marking) {
        if (marking == null) return false;

        List<{{ net_element_type | default(value="YNetElement") }}> otherLocations =
            new ArrayList<>(marking.getLocations());

        // Short-circuit if sizes differ
        if (otherLocations.size() != _locations.size()) {
            return false;
        }

        // Sort and compare for equality
        List<{{ net_element_type | default(value="YNetElement") }}> thisLocations =
            new ArrayList<>(_locations);
        Collections.sort(otherLocations, Comparator.comparing(Object::hashCode));
        Collections.sort(thisLocations, Comparator.comparing(Object::hashCode));

        return thisLocations.equals(otherLocations);
    }

    /**
     * Checks if this marking is strictly greater than another.
     *
     * @param marking the marking to compare
     * @return true if this has more tokens (multiset comparison)
     */
    public boolean isBiggerThan({{ class_name }} marking) {
        if (marking == null) return false;

        List<{{ net_element_type | default(value="YNetElement") }}> otherLocations =
            new ArrayList<>(marking.getLocations());
        List<{{ net_element_type | default(value="YNetElement") }}> myLocations =
            new ArrayList<>(_locations);

        // c1+c2+c3 bigger than c1+c2
        if (myLocations.containsAll(otherLocations)
                && !otherLocations.containsAll(myLocations)) {
            return true;
        }

        // c1+2c2 bigger than c1+c2 (same elements, more total)
        if (myLocations.containsAll(otherLocations)
                && otherLocations.containsAll(myLocations)
                && myLocations.size() > otherLocations.size()) {
            return true;
        }

        return false;
    }

    /**
     * Checks if this marking is greater than or equal to another.
     *
     * @param marking the marking to compare
     * @return true if this is bigger or equivalent
     */
    public boolean isBiggerThanOrEqual({{ class_name }} marking) {
        return isBiggerThan(marking) || equivalentTo(marking);
    }

    /**
     * Checks if this marking is an enabling superset of another for OR-join analysis.
     *
     * @param marking the marking to compare
     * @param orJoin the OR-join task being analyzed
     * @return true if this has more tokens in the OR-join's preset
     */
    public boolean isBiggerEnablingMarkingThan({{ class_name }} marking, YTask orJoin) {
        Set<YExternalNetElement> preset = orJoin.getPresetElements();
        Set<YCondition> thisOccupied = new HashSet<>();
        Set<YCondition> otherOccupied = new HashSet<>();

        for (YExternalNetElement element : preset) {
            YCondition condition = (YCondition) element;
            if (_locations.contains(condition)) {
                thisOccupied.add(condition);
            }
            if (marking._locations.contains(condition)) {
                otherOccupied.add(condition);
            }
        }

        return thisOccupied.containsAll(otherOccupied)
            && !otherOccupied.containsAll(thisOccupied);
    }

    // ============================================================
    // DEADLOCK DETECTION
    // ============================================================

    /**
     * Checks if this marking represents a deadlock state.
     *
     * @param orJoin the OR-join being analyzed (excluded from deadlock check)
     * @return true if no progress is possible
     */
    public boolean deadLock(YTask orJoin) {
        // A busy task means not deadlocked
        for ({{ net_element_type | default(value="YNetElement") }} element : _locations) {
            if (element instanceof YTask) {
                return false;
            }
        }

        // Check if any postset task is enabled
        Set<YExternalNetElement> postset = YNet.getPostset(getLocationsAsSet());
        for (YExternalNetElement postElement : postset) {
            YTask task = (YTask) postElement;

            if (task.getJoinType() != YTask._OR) {
                if (nonOrJoinEnabled(task)) {
                    return false;
                }
            } else {
                // OR-join: check if any preset condition has a token (excluding the one being analyzed)
                for (YExternalNetElement preElement : task.getPresetElements()) {
                    YCondition condition = (YCondition) preElement;
                    if (_locations.contains(condition) && task != orJoin) {
                        return false;
                    }
                }
            }
        }

        return true;
    }

    private Set<YExternalNetElement> getLocationsAsSet() {
        Set<YExternalNetElement> set = new HashSet<>();
        for ({{ net_element_type | default(value="YNetElement") }} element : _locations) {
            set.add((YExternalNetElement) element);
        }
        return set;
    }

    // ============================================================
    // OBJECT CONTRACT
    // ============================================================

    @Override
    public int hashCode() {
        long hashCode = 0;
        for ({{ net_element_type | default(value="YNetElement") }} element : _locations) {
            hashCode += element.hashCode();
        }
        return (int) (hashCode % Integer.MAX_VALUE);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof {{ class_name }})) return false;

        {{ class_name }} other = ({{ class_name }}) obj;
        return equivalentTo(other);
    }

    @Override
    public String toString() {
        return _locations.toString();
    }

{% if custom_methods %}
    // ============================================================
    // CUSTOM METHODS
    // ============================================================
{% for method in custom_methods %}
    /**
     * {{ method.description | default(value="Custom method") }}
     */
    {{ method.visibility | default(value="public") }} {{ method.return_type }} {{ method.name }}({% for param in method.params %}{{ param.type }} {{ param.name }}{% if not loop.last %}, {% endif %}{% endfor %}) {
        {% if method.body %}{{ method.body }}{% else %}throw new UnsupportedOperationException("Method not implemented");{% endif %}
    }

{% endfor %}
{% endif %}
}
