{#
 YAWL Flow Template
 Generates YFlow subclass for control flow connections between net elements.

 Context Variables:
   - class_name: Name of the generated class (default: YFlow)
   - package: Java package name
   - has_predicate: boolean for XPath predicate support
   - has_ordering: boolean for evaluation ordering support
   - has_default_flow: boolean for default flow support
   - has_documentation: boolean for flow documentation
   - custom_fields: Array of additional field definitions
 #}
/*
 * Copyright (c) 2004-{{ "now" | date(format="%Y") }} The YAWL Foundation. All rights reserved.
 * The YAWL Foundation is a collaboration of individuals and
 * organisations who are committed to improving workflow technology.
 *
 * This file is part of YAWL. YAWL is free software: you can
 * redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation.
 *
 * YAWL is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
 * Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with YAWL. If not, see <http://www.gnu.org/licenses/>.
 */

package {{ package }};

import org.yawlfoundation.yawl.elements.YExternalNetElement;
import org.yawlfoundation.yawl.elements.YTask;
import org.yawlfoundation.yawl.elements.YCondition;
import org.yawlfoundation.yawl.elements.YInputCondition;
import org.yawlfoundation.yawl.elements.YOutputCondition;
import org.yawlfoundation.yawl.util.JDOMUtil;
import org.yawlfoundation.yawl.util.StringUtil;
import org.yawlfoundation.yawl.util.YVerificationHandler;

/**
 * {{ class_name | default(value="YFlow") }} - Auto-generated YAWL Flow
 *
 * Represents a control flow connection between two net elements.
{% if documentation %}
 * {{ documentation }}
{% endif %}
 *
 * @generated by yawl-java-templates
 */
public class {{ class_name | default(value="YFlow") }} implements Comparable<{{ class_name | default(value="YFlow") }}> {

    private YExternalNetElement _priorElement;
    private YExternalNetElement _nextElement;

    {% if has_predicate is defined and has_predicate %}
    private String _xpathPredicate;
    {% endif %}

    {% if has_ordering is defined and has_ordering %}
    private Integer _evalOrdering;
    {% endif %}

    {% if has_default_flow is defined and has_default_flow %}
    private boolean _isDefaultFlow;
    {% endif %}

    {% if has_documentation is defined and has_documentation %}
    private String _documentation;
    {% endif %}

    {% for field in custom_fields %}
    {{ field.modifier | default(value="private") }} {{ field.type }} _{{ field.name }};
    {% endfor %}

    // CONSTRUCTOR //

    /**
     * Creates a flow between two net elements.
     * @param priorElement the source element
     * @param nextElement the target element
     */
    public {{ class_name | default(value="YFlow") }}(YExternalNetElement priorElement, YExternalNetElement nextElement) {
        _priorElement = priorElement;
        _nextElement = nextElement;
    }

    /******************************************************************************/

    // GETTERS & SETTERS //

    public YExternalNetElement getPriorElement() {
        return _priorElement;
    }

    public YExternalNetElement getNextElement() {
        return _nextElement;
    }

    {% if has_predicate is defined and has_predicate %}
    public String getXpathPredicate() {
        return _xpathPredicate;
    }

    public void setXpathPredicate(String xpathPredicate) {
        _xpathPredicate = xpathPredicate;
    }
    {% endif %}

    {% if has_ordering is defined and has_ordering %}
    public Integer getEvalOrdering() {
        return _evalOrdering;
    }

    public void setEvalOrdering(Integer evalOrdering) {
        _evalOrdering = evalOrdering;
    }
    {% endif %}

    {% if has_default_flow is defined and has_default_flow %}
    public boolean isDefaultFlow() {
        return _isDefaultFlow;
    }

    public void setIsDefaultFlow(boolean isDefault) {
        _isDefaultFlow = isDefault;
    }
    {% endif %}

    {% if has_documentation is defined and has_documentation %}
    public String getDocumentation() {
        return _documentation;
    }

    public void setDocumentation(String documentation) {
        _documentation = documentation;
    }
    {% endif %}

    {% for field in custom_fields %}
    public {{ field.type }} get{{ field.name | capitalize }}() {
        return _{{ field.name }};
    }

    public void set{{ field.name | capitalize }}({{ field.type }} {{ field.name }}) {
        _{{ field.name }} = {{ field.name }};
    }

    {% endfor %}

    /******************************************************************************/

    // VERIFICATION //

    /**
     * Verifies the flow configuration according to YAWL semantics.
     * @param caller the calling element
     * @param handler the verification handler
     */
    public void verify(YExternalNetElement caller, YVerificationHandler handler) {
        if (_priorElement == null || _nextElement == null) {
            if (_priorElement == null) {
                handler.error(caller, caller + " [error] null prior element");
            }
            if (_nextElement == null) {
                handler.error(caller, caller + " [error] null next element");
            }
        }
        else if (_priorElement._net != _nextElement._net) {
            handler.error(caller, caller + " any flow from any Element [" +
                    _priorElement + "] to any Element [" + _nextElement + "] " +
                    "must occur within the bounds of the same net.");
        }

        // Verify task-specific flow rules
        if (_priorElement instanceof YTask) {
            verifyTaskFlow(caller, handler);
        }
        else {
            verifyConditionFlow(caller, handler);
        }

        // Verify boundary conditions
        if (_priorElement instanceof YOutputCondition) {
            handler.error(caller, caller +
                    " [error] any flow from an OutputCondition [" + _priorElement +
                    "] is not allowed.");
        }
        if (_nextElement instanceof YInputCondition) {
            handler.error(caller, caller +
                    " [error] any flow into an InputCondition [" + _nextElement +
                    "] is not allowed.");
        }
    }

    private void verifyTaskFlow(YExternalNetElement caller, YVerificationHandler handler) {
        YTask priorTask = (YTask) _priorElement;
        int splitType = priorTask.getSplitType();

        {% if has_predicate is defined and has_predicate %}
        // AND-split cannot have predicates
        if (splitType == YTask._AND && _xpathPredicate != null) {
            handler.error(caller, caller + " any flow from any AND-split [" +
                    _priorElement + "] may not have an xpath predicate.");
        }
        {% endif %}

        {% if has_default_flow is defined and has_default_flow %}
        // AND-split cannot have default flow
        if (splitType == YTask._AND && _isDefaultFlow) {
            handler.error(caller, caller + " any flow from any AND-split [" +
                    _priorElement + "] may not have a default flow.");
        }
        {% endif %}

        {% if has_ordering is defined and has_ordering %}
        // Non-XOR splits cannot have ordering
        if (splitType != YTask._XOR && _evalOrdering != null) {
            handler.error(caller, caller + " any flow from any non XOR-split [" +
                    _priorElement + "] may not have an evaluation ordering.");
        }
        {% endif %}

        // XOR and OR splits must have predicate or be default
        if (splitType != YTask._AND) {
            verifyConditionalFlow(caller, handler, splitType);
        }
    }

    private void verifyConditionalFlow(YExternalNetElement caller, YVerificationHandler handler, int splitType) {
        {% if has_predicate is defined and has_predicate %}
        {% if has_default_flow is defined and has_default_flow %}
        boolean hasPredicate = _xpathPredicate != null;
        boolean isDefault = _isDefaultFlow;

        if (!hasPredicate && !isDefault) {
            handler.error(caller, caller + " any flow from any XOR/OR-split [" +
                    _priorElement + "] must have either a predicate or be a default flow.");
        }
        {% endif %}

        if (splitType == YTask._XOR) {
            {% if has_default_flow is defined and has_default_flow %}
            // XOR: cannot be both predicate and default
            if (_xpathPredicate != null && _isDefaultFlow) {
                handler.error(caller, caller +
                        " any flow from any XOR-split [" + _priorElement +
                        "] must have either a predicate or be a default flow (cannot be both).");
            }
            {% endif %}

            {% if has_ordering is defined and has_ordering %}
            // XOR with predicate must have ordering
            if (_xpathPredicate != null && _evalOrdering == null) {
                handler.error(caller, caller +
                        " any flow from any XOR-split [" + _priorElement +
                        "] that has a predicate, must have an evaluation ordering.");
            }
            {% endif %}
        }
        else {
            // OR-split
            if (_xpathPredicate == null) {
                handler.error(caller, caller +
                        " any flow from any OR-split [" + _priorElement +
                        "] must have a predicate.");
            }
            {% if has_ordering is defined and has_ordering %}
            else if (_evalOrdering != null) {
                handler.error(caller, caller +
                        " any flow from any OR-split [" + _priorElement +
                        "] must not have an ordering.");
            }
            {% endif %}
        }
        {% endif %}
    }

    private void verifyConditionFlow(YExternalNetElement caller, YVerificationHandler handler) {
        {% if has_predicate is defined and has_predicate %}
        if (_xpathPredicate != null) {
            handler.error(caller, caller +
                    " [error] any flow from any condition [" + _priorElement +
                    "] may not contain a predicate.");
        }
        {% endif %}

        {% if has_ordering is defined and has_ordering %}
        if (_evalOrdering != null) {
            handler.error(caller, caller +
                    " [error] any flow from any condition [" + _priorElement +
                    "] may not contain an evaluation ordering.");
        }
        {% endif %}

        {% if has_default_flow is defined and has_default_flow %}
        if (_isDefaultFlow) {
            handler.error(caller, caller +
                    " [error] any flow from any condition [" + _priorElement +
                    "] may not be a default flow.");
        }
        {% endif %}

        if (_nextElement instanceof YCondition) {
            handler.error(caller, caller +
                    " [error] any flow from any condition [" + _priorElement +
                    "] to any other YConditionInterface [" + _nextElement +
                    "] is not allowed.");
        }
    }

    /******************************************************************************/

    // COMPARABLE //

    @Override
    public int compareTo({{ class_name | default(value="YFlow") }} other) {
        {% if has_ordering is defined and has_ordering %}
        if (this.getEvalOrdering() != null && other.getEvalOrdering() != null) {
            return this.getEvalOrdering().compareTo(other.getEvalOrdering());
        }
        {% endif %}

        {% if has_default_flow is defined and has_default_flow %}
        else if (this.isDefaultFlow() && other.isDefaultFlow()) {
            return 0;
        }
        else if (this.isDefaultFlow()) {
            return 1;
        }
        else if (other.isDefaultFlow()) {
            return -1;
        }
        {% endif %}

        return 0;
    }

    /******************************************************************************/

    // XML SERIALIZATION //

    public String toXML() {
        StringBuilder xml = new StringBuilder("<flowsInto>");
        xml.append("<nextElementRef id=\"")
           .append(_nextElement.getID())
           .append("\"/>");

        {% if has_predicate is defined and has_predicate %}
        if (_xpathPredicate != null) {
            xml.append("<predicate");
            {% if has_ordering is defined and has_ordering %}
            if (_evalOrdering != null) {
                xml.append(" ordering=\"")
                   .append(_evalOrdering)
                   .append("\"");
            }
            {% endif %}
            xml.append(">")
               .append(JDOMUtil.encodeEscapes(_xpathPredicate))
               .append("</predicate>");
        }
        {% endif %}

        {% if has_default_flow is defined and has_default_flow %}
        if (_isDefaultFlow) {
            xml.append("<isDefaultFlow/>");
        }
        {% endif %}

        {% if has_documentation is defined and has_documentation %}
        if (_documentation != null) {
            xml.append(StringUtil.wrap(_documentation, "documentation"));
        }
        {% endif %}

        xml.append("</flowsInto>");
        return xml.toString();
    }

    @Override
    public String toString() {
        String className = getClass().getName();
        return className.substring(className.lastIndexOf('.') + 2) +
                ":from[" + _priorElement + "]to[" + _nextElement + "]";
    }
}
