{#
 YAWL State Machine Template
 Generates state enums with transitions, validation, and helper methods.

 Context Variables:
   - class_name: Name of the generated enum class
   - package: Java package name
   - states: Array of state objects with name, display_name, description
   - transitions: Array of transition objects with from, to, trigger, guard
   - initial_state: Name of the initial state
   - final_states: Array of final state names
   - has_history: boolean for previous state tracking
   - has_visitor: boolean for visitor pattern support
 #}
/*
 * Copyright (c) 2004-{{ "now" | date(format="%Y") }} The YAWL Foundation. All rights reserved.
 * The YAWL Foundation is a collaboration of individuals and
 * organisations who are committed to improving workflow technology.
 *
 * This file is part of YAWL. YAWL is free software: you can
 * redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation.
 *
 * YAWL is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
 * Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with YAWL. If not, see <http://www.gnu.org/licenses/>.
 */

package {{ package }};

import java.util.*;

/**
 * {{ class_name }} - Auto-generated State Machine Enum
 *
{% if description %}
 * {{ description }}
{% endif %}
 *
 * States: {% for state in states %}{{ state.name }}{% if not loop.last %}, {% endif %}{% endfor %}
 *
 * @generated by yawl-java-templates
 */
public enum {{ class_name }} {

    {% for state in states %}
    {{ state.name }}("{{ state.display_name | default(value=state.name | capitalize) }}"){% if not loop.last %},{% else %};{% endif %}

    {% endfor %}

    private final String displayName;

    // TRANSITION MAP: from-state -> to-states
    private static final Map<{{ class_name }}, Set<{{ class_name }}>> TRANSITIONS = new EnumMap<>(\{{ class_name }}.class);

    // REVERSE LOOKUP MAP: display-name -> state
    private static final Map<String, {{ class_name }}> FROM_STRING_MAP = new HashMap<>({{ states | length }});

    // FINAL STATES
    private static final Set<{{ class_name }}> FINAL_STATES = EnumSet.of(
        {% for final in final_states %}
        {{ final }}{% if not loop.last %}, {% endif %}

        {% endfor %}
    );

    static {
        // Initialize reverse lookup map
        for ({{ class_name }} state : values()) {
            FROM_STRING_MAP.put(state.toString(), state);
        }

        // Initialize transition map
        {% for state in states %}
        TRANSITIONS.put({{ state.name }}, EnumSet.of(
            {% for trans in transitions %}
            {% if trans.from == state.name %}
            {{ trans.to }}{% if not loop.last %}, {% endif %}

            {% endif %}
            {% endfor %}
        ));
        {% endfor %}
    }

    // CONSTRUCTOR //

    {{ class_name }}(String displayName) {
        this.displayName = displayName;
    }

    /******************************************************************************/

    // DISPLAY NAME //

    @Override
    public String toString() {
        return displayName;
    }

    public String getDisplayName() {
        return displayName;
    }

    /******************************************************************************/

    // STATE LOOKUP //

    /**
     * Gets a state from its string representation.
     * @param s the string representation
     * @return the state, or null if not found
     */
    public static {{ class_name }} fromString(String s) {
        return (s != null) ? FROM_STRING_MAP.get(s) : null;
    }

    /**
     * Checks if the given state name is valid.
     * @param name the state name to check
     * @return true if valid, false otherwise
     */
    public static boolean isValidState(String name) {
        return FROM_STRING_MAP.containsKey(name);
    }

    /******************************************************************************/

    // TRANSITIONS //

    /**
     * Checks if a transition from this state to the target state is valid.
     * @param target the target state
     * @return true if the transition is valid
     */
    public boolean canTransitionTo({{ class_name }} target) {
        Set<{{ class_name }}> validTargets = TRANSITIONS.get(this);
        return validTargets != null && validTargets.contains(target);
    }

    /**
     * Gets all valid target states from this state.
     * @return an unmodifiable set of valid target states
     */
    public Set<{{ class_name }}> getValidTransitions() {
        Set<{{ class_name }}> targets = TRANSITIONS.get(this);
        return targets != null ? Collections.unmodifiableSet(targets) : Collections.emptySet();
    }

    /**
     * Attempts to transition to the target state.
     * @param target the target state
     * @return the new state
     * @throws IllegalStateException if the transition is not valid
     */
    public {{ class_name }} transitionTo({{ class_name }} target) {
        if (!canTransitionTo(target)) {
            throw new IllegalStateException(
                String.format("Invalid state transition from '%s' to '%s'. Valid targets: %s",
                    this, target, getValidTransitions()));
        }
        return target;
    }

    /******************************************************************************/

    // STATE CATEGORIES //

    /**
     * Checks if this state is the initial state.
     * @return true if this is the initial state
     */
    public boolean isInitial() {
        return this == {{ initial_state }};
    }

    /**
     * Checks if this state is a final (terminal) state.
     * @return true if this is a final state
     */
    public boolean isFinal() {
        return FINAL_STATES.contains(this);
    }

    /**
     * Checks if this state allows further transitions.
     * @return true if transitions are possible
     */
    public boolean canTransition() {
        Set<{{ class_name }}> targets = TRANSITIONS.get(this);
        return targets != null && !targets.isEmpty();
    }

    /**
     * Gets the initial state.
     * @return the initial state
     */
    public static {{ class_name }} getInitialState() {
        return {{ initial_state }};
    }

    /**
     * Gets all final states.
     * @return an unmodifiable set of final states
     */
    public static Set<{{ class_name }}> getFinalStates() {
        return Collections.unmodifiableSet(FINAL_STATES);
    }

    /******************************************************************************/

    // STATE GROUPS //

    {% for group in state_groups %}
    /**
     * Checks if this state is in the {{ group.name }} group.
     * @return true if in group
     */
    public boolean is{{ group.name | capitalize }}() {
        return {{ group.name | upper }}_STATES.contains(this);
    }

    /**
     * Gets all states in the {{ group.name }} group.
     * @return the states in the group
     */
    public static Set<{{ class_name }}> get{{ group.name | capitalize }}States() {
        return Collections.unmodifiableSet({{ group.name | upper }}_STATES);
    }

    {% endfor %}

    {% if has_visitor %}
    /******************************************************************************/

    // VISITOR PATTERN //

    /**
     * Accepts a visitor for state-specific processing.
     * @param visitor the visitor
     * @param <T> the return type
     * @return the visitor result
     */
    public <T> T accept({{ class_name }}Visitor<T> visitor) {
        switch (this) {
            {% for state in states %}
            case {{ state.name }}:
                return visitor.visit{{ state.name }}(this);
            {% endfor %}
            default:
                throw new AssertionError("Unknown state: " + this);
        }
    }

    /**
     * Visitor interface for state-specific processing.
     */
    public interface {{ class_name }}Visitor<T> {
        {% for state in states %}
        T visit{{ state.name }}({{ class_name }} state);
        {% endfor %}
    }
    {% endif %}

    /******************************************************************************/

    // UTILITY //

    /**
     * Gets all possible states.
     * @return all states
     */
    public static Set<{{ class_name }}> allStates() {
        return EnumSet.allOf({{ class_name }}.class);
    }

    /**
     * Gets all non-final states.
     * @return all non-final states
     */
    public static Set<{{ class_name }}> getNonFinalStates() {
        Set<{{ class_name }}> result = EnumSet.copyOf(allStates());
        result.removeAll(FINAL_STATES);
        return result;
    }
}
