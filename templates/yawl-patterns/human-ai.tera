{#
  Template: YHumanAITeamworkTask.java
  Pattern: WCP-63 - Human-AI Teamwork
  Description: Coordinates human and AI activities in a workflow
#}
/**
 * YHumanAITeamworkTask - WCP-63 Human-AI Teamwork Pattern
 *
 * Coordinates human and AI activities in a workflow. AI handles routine decisions;
 * humans review edge cases or low-confidence predictions.
 *
 * Formalism:
 *   HumanAI(prediction, confidence) = {
 *     if confidence >= autoThreshold: autoApprove()
 *     elif confidence >= reviewThreshold: humanReview() // AI-assisted
 *     else: humanDecide() // No AI input shown
 *   }
 *
 * @generated by ggen from ontology
 * @pattern WCP-63
 */

package org.yawlfoundation.yawl.patterns.extended;

import org.yawlfoundation.yawl.elements.YTask;
import org.yawlfoundation.yawl.elements.YNet;
import org.yawlfoundation.yawl.exceptions.YHumanAIException;

import java.util.*;
import java.util.concurrent.*;
import java.util.function.Function;

/**
 * AI Decision result.
 */
public class YAIResult {
    private final String prediction;
    private final double confidence;
    private final String modelId;
    private final String modelVersion;
    private final Map<String, Object> explanation;
    private final Instant timestamp;
    private final Map<String, Double> alternatives;

    public YAIResult(String prediction, double confidence, String modelId,
                     String modelVersion, Map<String, Object> explanation,
                     Map<String, Double> alternatives) {
        this.prediction = prediction;
        this.confidence = confidence;
        this.modelId = modelId;
        this.modelVersion = modelVersion;
        this.explanation = explanation != null ? explanation : new HashMap<>();
        this.alternatives = alternatives != null ? alternatives : new HashMap<>();
        this.timestamp = Instant.now();
    }

    // Getters
    public String getPrediction() { return prediction; }
    public double getConfidence() { return confidence; }
    public String getModelId() { return modelId; }
    public String getModelVersion() { return modelVersion; }
    public Map<String, Object> getExplanation() { return explanation; }
    public Instant getTimestamp() { return timestamp; }
    public Map<String, Double> getAlternatives() { return alternatives; }
}

/**
 * Human decision record.
 */
public class YHumanDecision {
    private final String decision;
    private final String reason;
    private final String userId;
    private final boolean shownAIPrediction;
    private final String aiPrediction;
    private final boolean agreedWithAI;
    private final Instant timestamp;
    private final Duration reviewDuration;

    public YHumanDecision(String decision, String reason, String userId,
                          boolean shownAIPrediction, String aiPrediction,
                          boolean agreedWithAI, Duration reviewDuration) {
        this.decision = decision;
        this.reason = reason;
        this.userId = userId;
        this.shownAIPrediction = shownAIPrediction;
        this.aiPrediction = aiPrediction;
        this.agreedWithAI = agreedWithAI;
        this.reviewDuration = reviewDuration;
        this.timestamp = Instant.now();
    }

    // Getters
    public String getDecision() { return decision; }
    public String getReason() { return reason; }
    public String getUserId() { return userId; }
    public boolean wasShownAIPrediction() { return shownAIPrediction; }
    public String getAiPrediction() { return aiPrediction; }
    public boolean agreedWithAI() { return agreedWithAI; }
    public Duration getReviewDuration() { return reviewDuration; }
    public Instant getTimestamp() { return timestamp; }
}

/**
 * Decision routing based on confidence.
 */
public enum YDecisionRoute {
    AUTO_APPROVED,      // High confidence - AI decides automatically
    AI_ASSISTED,        // Medium confidence - AI assists human reviewer
    HUMAN_ONLY,         // Low confidence - Human decides without AI input
    ESCALATED           // Complex case - escalated to expert
}

/**
 * Human-AI Teamwork Task - Implements WCP-63 pattern.
 *
 * Use Cases:
 * - Content moderation with AI filtering
 * - Document review and classification
 * - Customer support routing
 * - Fraud detection with human oversight
 */
public class YHumanAITeamworkTask extends YTask {

    // Configuration
    private final double autoApproveThreshold;
    private final double aiAssistedThreshold;
    private final boolean showAIPrediction;
    private final boolean showAIConfidence;
    private final boolean requireHumanReason;
    private final Duration humanTimeout;

    // ML Model integration
    private final Function<Map<String, Object>, YAIResult> modelInvoker;
    private final String modelEndpoint;
    private final String modelVersion;

    // Callbacks
    private final Function<Map<String, Object>, YHumanDecision> humanReviewer;

    // Metrics
    private final AtomicInteger autoApprovedCount = new AtomicInteger(0);
    private final AtomicInteger aiAssistedCount = new AtomicInteger(0);
    private final AtomicInteger humanOnlyCount = new AtomicInteger(0);
    private final AtomicInteger escalatedCount = new AtomicInteger(0);
    private final AtomicInteger humanAIAgreementCount = new AtomicInteger(0);

    public YHumanAITeamworkTask(String taskId, String taskName, YNet parentNet,
                                double autoApproveThreshold, double aiAssistedThreshold,
                                boolean showAIPrediction, boolean showAIConfidence,
                                boolean requireHumanReason, Duration humanTimeout,
                                String modelEndpoint, String modelVersion,
                                Function<Map<String, Object>, YAIResult> modelInvoker,
                                Function<Map<String, Object>, YHumanDecision> humanReviewer) {
        super(taskId, taskName, parentNet);
        this.autoApproveThreshold = autoApproveThreshold;
        this.aiAssistedThreshold = aiAssistedThreshold;
        this.showAIPrediction = showAIPrediction;
        this.showAIConfidence = showAIConfidence;
        this.requireHumanReason = requireHumanReason;
        this.humanTimeout = humanTimeout;
        this.modelEndpoint = modelEndpoint;
        this.modelVersion = modelVersion;
        this.modelInvoker = modelInvoker;
        this.humanReviewer = humanReviewer;
    }

    /**
     * Create with typical configuration.
     */
    public static YHumanAITeamworkTask create(String taskId, YNet parentNet,
                                              String modelEndpoint,
                                              Function<Map<String, Object>, YAIResult> modelInvoker,
                                              Function<Map<String, Object>, YHumanDecision> humanReviewer) {
        return new YHumanAITeamworkTask(
            taskId,
            "HumanAITeamwork",
            parentNet,
            0.95,           // autoApproveThreshold
            0.70,           // aiAssistedThreshold
            true,           // showAIPrediction
            true,           // showAIConfidence
            true,           // requireHumanReason
            Duration.ofHours(24), // humanTimeout
            modelEndpoint,
            "1.0.0",
            modelInvoker,
            humanReviewer
        );
    }

    {% if config %}
    /**
     * Configuration from ontology:
     * Auto-approve threshold: {{ config.autoApproveThreshold | default(value=0.95) }}
     * AI-assisted threshold: {{ config.aiAssistedThreshold | default(value=0.70) }}
     * Show AI prediction: {{ config.showAIPrediction | default(value=true) }}
     * Show AI confidence: {{ config.showAIConfidence | default(value=true) }}
     */
    {% endif %}

    /**
     * Execute the Human-AI decision workflow.
     *
     * @param inputData Input data for decision
     * @return The final decision (auto or human)
     * @throws YHumanAIException if processing fails
     */
    public Object execute(Map<String, Object> inputData) throws YHumanAIException {
        // Step 1: Get AI prediction
        YAIResult aiResult = null;
        try {
            if (modelInvoker != null) {
                aiResult = modelInvoker.apply(inputData);
            }
        } catch (Exception e) {
            // Model invocation failed - fall back to human decision
            return handleHumanOnly(inputData, null, e.getMessage());
        }

        if (aiResult == null) {
            return handleHumanOnly(inputData, null, "No AI result available");
        }

        // Step 2: Route based on confidence
        YDecisionRoute route = determineRoute(aiResult.getConfidence());

        switch (route) {
            case AUTO_APPROVED:
                return handleAutoApproved(inputData, aiResult);

            case AI_ASSISTED:
                return handleAIAssisted(inputData, aiResult);

            case HUMAN_ONLY:
                return handleHumanOnly(inputData, aiResult, null);

            case ESCALATED:
                return handleEscalated(inputData, aiResult);

            default:
                throw new YHumanAIException("Unknown decision route: " + route);
        }
    }

    /**
     * Determine routing based on confidence thresholds.
     */
    private YDecisionRoute determineRoute(double confidence) {
        if (confidence >= autoApproveThreshold) {
            return YDecisionRoute.AUTO_APPROVED;
        } else if (confidence >= aiAssistedThreshold) {
            return YDecisionRoute.AI_ASSISTED;
        } else if (confidence >= 0.3) {
            return YDecisionRoute.HUMAN_ONLY;
        } else {
            return YDecisionRoute.ESCALATED;
        }
    }

    /**
     * Handle auto-approved case (high confidence).
     */
    private YAIResult handleAutoApproved(Map<String, Object> inputData, YAIResult aiResult) {
        autoApprovedCount.incrementAndGet();
        return aiResult;
    }

    /**
     * Handle AI-assisted human review.
     */
    private YHumanDecision handleAIAssisted(Map<String, Object> inputData, YAIResult aiResult)
            throws YHumanAIException {
        aiAssistedCount.incrementAndGet();

        // Prepare context with AI information
        Map<String, Object> reviewContext = new HashMap<>(inputData);
        if (showAIPrediction) {
            reviewContext.put("_aiPrediction", aiResult.getPrediction());
        }
        if (showAIConfidence) {
            reviewContext.put("_aiConfidence", aiResult.getConfidence());
        }
        reviewContext.put("_aiExplanation", aiResult.getExplanation());
        reviewContext.put("_aiAlternatives", aiResult.getAlternatives());

        // Get human decision
        YHumanDecision decision = getHumanDecision(reviewContext);

        // Track agreement
        if (aiResult.getPrediction().equals(decision.getDecision())) {
            humanAIAgreementCount.incrementAndGet();
        }

        return decision;
    }

    /**
     * Handle human-only decision (low confidence).
     */
    private YHumanDecision handleHumanOnly(Map<String, Object> inputData,
                                           YAIResult aiResult, String errorReason)
            throws YHumanAIException {
        humanOnlyCount.incrementAndGet();

        Map<String, Object> reviewContext = new HashMap<>(inputData);
        // Don't show AI prediction for human-only cases
        if (errorReason != null) {
            reviewContext.put("_aiError", errorReason);
        }

        return getHumanDecision(reviewContext);
    }

    /**
     * Handle escalated case (very low confidence or complex).
     */
    private YHumanDecision handleEscalated(Map<String, Object> inputData, YAIResult aiResult)
            throws YHumanAIException {
        escalatedCount.incrementAndGet();

        Map<String, Object> reviewContext = new HashMap<>(inputData);
        reviewContext.put("_escalated", true);
        reviewContext.put("_escalationReason", "Very low AI confidence: " + aiResult.getConfidence());

        return getHumanDecision(reviewContext);
    }

    /**
     * Get human decision with timeout.
     */
    private YHumanDecision getHumanDecision(Map<String, Object> context)
            throws YHumanAIException {
        if (humanReviewer == null) {
            throw new YHumanAIException("No human reviewer configured");
        }

        try {
            CompletableFuture<YHumanDecision> future = CompletableFuture.supplyAsync(
                () -> humanReviewer.apply(context)
            );

            return future.get(humanTimeout.toMillis(), TimeUnit.MILLISECONDS);

        } catch (TimeoutException e) {
            throw new YHumanAIException("Human review timed out after " + humanTimeout);
        } catch (ExecutionException e) {
            throw new YHumanAIException("Human review failed", e.getCause());
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new YHumanAIException("Human review interrupted", e);
        }
    }

    /**
     * Get Human-AI metrics.
     */
    public HumanAIMetrics getMetrics() {
        int total = autoApprovedCount.get() + aiAssistedCount.get() +
                   humanOnlyCount.get() + escalatedCount.get();
        return new HumanAIMetrics(
            getTaskId(),
            total,
            autoApprovedCount.get(),
            aiAssistedCount.get(),
            humanOnlyCount.get(),
            escalatedCount.get(),
            humanAIAgreementCount.get(),
            total > 0 ? (double) humanAIAgreementCount.get() / total : 0.0
        );
    }

    /**
     * Metrics data class.
     */
    public static class HumanAIMetrics {
        private final String taskId;
        private final int totalDecisions;
        private final int autoApprovedCount;
        private final int aiAssistedCount;
        private final int humanOnlyCount;
        private final int escalatedCount;
        private final int humanAIAgreementCount;
        private final double agreementRate;

        public HumanAIMetrics(String taskId, int totalDecisions,
                              int autoApprovedCount, int aiAssistedCount,
                              int humanOnlyCount, int escalatedCount,
                              int humanAIAgreementCount, double agreementRate) {
            this.taskId = taskId;
            this.totalDecisions = totalDecisions;
            this.autoApprovedCount = autoApprovedCount;
            this.aiAssistedCount = aiAssistedCount;
            this.humanOnlyCount = humanOnlyCount;
            this.escalatedCount = escalatedCount;
            this.humanAIAgreementCount = humanAIAgreementCount;
            this.agreementRate = agreementRate;
        }

        // Getters
        public String getTaskId() { return taskId; }
        public int getTotalDecisions() { return totalDecisions; }
        public int getAutoApprovedCount() { return autoApprovedCount; }
        public int getAiAssistedCount() { return aiAssistedCount; }
        public int getHumanOnlyCount() { return humanOnlyCount; }
        public int getEscalatedCount() { return escalatedCount; }
        public int getHumanAIAgreementCount() { return humanAIAgreementCount; }
        public double getAgreementRate() { return agreementRate; }
        public double getAutoApproveRate() {
            return totalDecisions > 0 ? (double) autoApprovedCount / totalDecisions : 0.0;
        }
    }
}
