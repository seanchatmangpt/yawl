{#
  Template: YScatterGatherTask.java
  Pattern: WCP-57 - Scatter-Gather
  Description: Broadcasts a message to multiple recipients and collects responses
#}
/**
 * YScatterGatherTask - WCP-57 Scatter-Gather Pattern
 *
 * Broadcasts a message to multiple recipients (scatter) and collects responses (gather).
 * Continues when all or threshold responses received.
 *
 * Formalism:
 *   Scatter(message, recipients) → for each r ∈ recipients: send(message, r)
 *   Gather(responses, condition) → wait until condition(responses)
 *   Continue with aggregated response
 *
 * @generated by ggen from ontology
 * @pattern WCP-57
 */

package org.yawlfoundation.yawl.patterns.extended;

import org.yawlfoundation.yawl.elements.YTask;
import org.yawlfoundation.yawl.elements.YNet;
import org.yawlfoundation.yawl.exceptions.YScatterGatherException;

import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.*;

/**
 * Recipient definition for scatter.
 */
public class YRecipient {
    private final String recipientId;
    private final String endpoint;
    private final int timeout;
    private final int priority;
    private final boolean required;

    public YRecipient(String recipientId, String endpoint, int timeout, int priority, boolean required) {
        this.recipientId = recipientId;
        this.endpoint = endpoint;
        this.timeout = timeout;
        this.priority = priority;
        this.required = required;
    }

    // Getters
    public String getRecipientId() { return recipientId; }
    public String getEndpoint() { return endpoint; }
    public int getTimeout() { return timeout; }
    public int getPriority() { return priority; }
    public boolean isRequired() { return required; }
}

/**
 * Response from a single recipient.
 */
public class YRecipientResponse<T> {
    private final String recipientId;
    private final T response;
    private final Throwable error;
    private final Duration duration;
    private final Instant timestamp;

    public YRecipientResponse(String recipientId, T response, Duration duration) {
        this.recipientId = recipientId;
        this.response = response;
        this.error = null;
        this.duration = duration;
        this.timestamp = Instant.now();
    }

    public YRecipientResponse(String recipientId, Throwable error, Duration duration) {
        this.recipientId = recipientId;
        this.response = null;
        this.error = error;
        this.duration = duration;
        this.timestamp = Instant.now();
    }

    // Getters
    public String getRecipientId() { return recipientId; }
    public T getResponse() { return response; }
    public Throwable getError() { return error; }
    public Duration getDuration() { return duration; }
    public Instant getTimestamp() { return timestamp; }
    public boolean isSuccess() { return error == null; }
}

/**
 * Aggregated scatter-gather result.
 */
public class YScatterGatherResult<T> {
    private final Map<String, YRecipientResponse<T>> responses;
    private final Set<String> timedOut;
    private final Set<String> failed;
    private final Duration totalDuration;
    private final boolean complete;

    public YScatterGatherResult(Map<String, YRecipientResponse<T>> responses,
                                 Set<String> timedOut, Set<String> failed,
                                 Duration totalDuration, boolean complete) {
        this.responses = responses;
        this.timedOut = timedOut;
        this.failed = failed;
        this.totalDuration = totalDuration;
        this.complete = complete;
    }

    // Getters
    public Map<String, YRecipientResponse<T>> getResponses() { return responses; }
    public Set<String> getTimedOut() { return timedOut; }
    public Set<String> getFailed() { return failed; }
    public Duration getTotalDuration() { return totalDuration; }
    public boolean isComplete() { return complete; }

    public List<T> getSuccessfulResponses() {
        List<T> results = new ArrayList<>();
        for (YRecipientResponse<T> resp : responses.values()) {
            if (resp.isSuccess()) {
                results.add(resp.getResponse());
            }
        }
        return results;
    }

    public int getSuccessCount() {
        return (int) responses.values().stream().filter(YRecipientResponse::isSuccess).count();
    }

    public int getFailureCount() {
        return timedOut.size() + failed.size();
    }
}

/**
 * Aggregation strategy interface.
 */
public interface YAggregationStrategy<T, R> {
    R aggregate(List<T> responses);
}

/**
 * Scatter-Gather Task - Implements WCP-57 pattern.
 *
 * Use Cases:
 * - Price comparison across multiple vendors
 * - Parallel API calls to multiple services
 * - Fan-out processing with result collection
 * - Distributed search across multiple sources
 */
public class YScatterGatherTask<T> extends YTask {

    private final List<YRecipient> recipients;
    private final Function<YRecipient, T> sender;
    private final Duration gatherTimeout;
    private final int minimumResponses;
    private final boolean discardLateResponses;
    private final YAggregationStrategy<T, ?> aggregationStrategy;
    private final ExecutorService executor;

    // Metrics
    private final AtomicInteger totalScatters = new AtomicInteger(0);
    private final AtomicInteger successfulGathers = new AtomicInteger(0);
    private final AtomicInteger partialGathers = new AtomicInteger(0);
    private final AtomicInteger failedGathers = new AtomicInteger(0);

    public YScatterGatherTask(String taskId, String taskName, YNet parentNet,
                              List<YRecipient> recipients,
                              Function<YRecipient, T> sender,
                              Duration gatherTimeout,
                              int minimumResponses,
                              boolean discardLateResponses,
                              YAggregationStrategy<T, ?> aggregationStrategy) {
        super(taskId, taskName, parentNet);
        this.recipients = new ArrayList<>(recipients);
        this.sender = sender;
        this.gatherTimeout = gatherTimeout;
        this.minimumResponses = minimumResponses;
        this.discardLateResponses = discardLateResponses;
        this.aggregationStrategy = aggregationStrategy;
        this.executor = Executors.newFixedThreadPool(recipients.size());
    }

    {% for recipient in recipients %}
    /**
     * Recipient {{ loop.index }}: {{ recipient.recipientId }}
     * Endpoint: {{ recipient.endpoint }}
     * Required: {{ recipient.required | default(value=true) }}
     */
    public void addRecipient{{ loop.index }}() {
        recipients.add(new YRecipient(
            "{{ recipient.recipientId }}",
            "{{ recipient.endpoint }}",
            {{ recipient.timeout | default(value=5000) }},
            {{ recipient.priority | default(value=0) }},
            {{ recipient.required | default(value=true) }}
        ));
    }
    {% endfor %}

    /**
     * Execute scatter-gather operation.
     *
     * @return Aggregated result from all recipients
     * @throws YScatterGatherException if minimum responses not received
     */
    public YScatterGatherResult<T> execute() throws YScatterGatherException {
        totalScatters.incrementAndGet();
        Instant startTime = Instant.now();

        // Track responses
        Map<String, YRecipientResponse<T>> responses = new ConcurrentHashMap<>();
        Set<String> timedOut = ConcurrentHashMap.newKeySet();
        Set<String> failed = ConcurrentHashMap.newKeySet();
        CountDownLatch latch = new CountDownLatch(recipients.size());

        // Scatter: send to all recipients in parallel
        List<CompletableFuture<Void>> futures = new ArrayList<>();

        for (YRecipient recipient : recipients) {
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                Instant requestStart = Instant.now();
                try {
                    T response = sender.apply(recipient);
                    Duration duration = Duration.between(requestStart, Instant.now());
                    responses.put(recipient.getRecipientId(),
                                 new YRecipientResponse<>(recipient.getRecipientId(), response, duration));
                } catch (Exception e) {
                    Duration duration = Duration.between(requestStart, Instant.now());
                    failed.add(recipient.getRecipientId());
                    responses.put(recipient.getRecipientId(),
                                 new YRecipientResponse<>(recipient.getRecipientId(), e, duration));
                } finally {
                    latch.countDown();
                }
            }, executor);

            // Apply individual timeout
            future.orTimeout(recipient.getTimeout(), TimeUnit.MILLISECONDS);
            futures.add(future);
        }

        // Gather: wait for all or timeout
        boolean completed;
        try {
            completed = latch.await(gatherTimeout.toMillis(), TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new YScatterGatherException("Scatter-gather interrupted", e);
        }

        // Identify timed out recipients
        for (YRecipient recipient : recipients) {
            if (!responses.containsKey(recipient.getRecipientId())) {
                timedOut.add(recipient.getRecipientId());
            }
        }

        Duration totalDuration = Duration.between(startTime, Instant.now());
        int successCount = (int) responses.values().stream()
                                          .filter(YRecipientResponse::isSuccess)
                                          .count();

        // Check minimum responses
        boolean meetsMinimum = successCount >= minimumResponses;

        if (!meetsMinimum) {
            failedGathers.incrementAndGet();
            throw new YScatterGatherException(
                String.format("Minimum responses not met: %d/%d required",
                             successCount, minimumResponses)
            );
        }

        // Update metrics
        if (completed && failed.isEmpty() && timedOut.isEmpty()) {
            successfulGathers.incrementAndGet();
        } else {
            partialGathers.incrementAndGet();
        }

        return new YScatterGatherResult<>(
            responses, timedOut, failed, totalDuration, completed
        );
    }

    /**
     * Execute and aggregate results.
     */
    public <R> R executeAndAggregate(YAggregationStrategy<T, R> strategy)
            throws YScatterGatherException {
        YScatterGatherResult<T> result = execute();
        return strategy.aggregate(result.getSuccessfulResponses());
    }

    /**
     * Execute with default aggregation strategy.
     */
    public Object executeWithAggregation() throws YScatterGatherException {
        YScatterGatherResult<T> result = execute();
        if (aggregationStrategy != null) {
            return aggregationStrategy.aggregate(result.getSuccessfulResponses());
        }
        return result;
    }

    /**
     * Execute async.
     */
    public CompletableFuture<YScatterGatherResult<T>> executeAsync() {
        return CompletableFuture.supplyAsync(this::execute, executor);
    }

    /**
     * Add a recipient dynamically.
     */
    public void addRecipient(YRecipient recipient) {
        recipients.add(recipient);
    }

    /**
     * Remove a recipient.
     */
    public void removeRecipient(String recipientId) {
        recipients.removeIf(r -> r.getRecipientId().equals(recipientId));
    }

    /**
     * Get scatter-gather metrics.
     */
    public ScatterGatherMetrics getMetrics() {
        return new ScatterGatherMetrics(
            getTaskId(),
            recipients.size(),
            totalScatters.get(),
            successfulGathers.get(),
            partialGathers.get(),
            failedGathers.get()
        );
    }

    /**
     * Metrics data class.
     */
    public static class ScatterGatherMetrics {
        private final String taskId;
        private final int recipientCount;
        private final int totalScatters;
        private final int successfulGathers;
        private final int partialGathers;
        private final int failedGathers;

        public ScatterGatherMetrics(String taskId, int recipientCount, int totalScatters,
                                     int successfulGathers, int partialGathers, int failedGathers) {
            this.taskId = taskId;
            this.recipientCount = recipientCount;
            this.totalScatters = totalScatters;
            this.successfulGathers = successfulGathers;
            this.partialGathers = partialGathers;
            this.failedGathers = failedGathers;
        }

        // Getters
        public String getTaskId() { return taskId; }
        public int getRecipientCount() { return recipientCount; }
        public int getTotalScatters() { return totalScatters; }
        public int getSuccessfulGathers() { return successfulGathers; }
        public int getPartialGathers() { return partialGathers; }
        public int getFailedGathers() { return failedGathers; }

        public double getSuccessRate() {
            int total = successfulGathers + partialGathers + failedGathers;
            return total > 0 ? (double) (successfulGathers + partialGathers) / total : 0.0;
        }
    }

    @Override
    public void dispose() {
        executor.shutdown();
        try {
            if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
        super.dispose();
    }
}
