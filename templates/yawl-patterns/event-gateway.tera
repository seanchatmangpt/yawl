{#
  Template: YEventGatewayTask.java
  Pattern: WCP-51 - Event Gateway
  Description: Waits for one or more events from external sources before proceeding
#}
/**
 * YEventGatewayTask - WCP-51 Event Gateway Pattern
 *
 * Waits for one or more events from external sources before proceeding.
 * Events can be messages, signals, timers, or condition changes.
 *
 * Formalism:
 *   EventGateway = ⋃ᵢ Eventᵢ → Actionᵢ
 *   Wait for: first event (exclusive) OR all events (parallel) OR n of m events
 *
 * @generated by ggen from ontology
 * @pattern WCP-51
 */

package org.yawlfoundation.yawl.patterns.extended;

import org.yawlfoundation.yawl.elements.YTask;
import org.yawlfoundation.yawl.elements.YNet;
import org.yawlfoundation.yawl.exceptions.YEventGatewayException;

import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.Consumer;

/**
 * Event types supported by the gateway.
 */
public enum YEventType {
    MESSAGE,    // Incoming message from external system
    SIGNAL,     // Broadcast signal
    TIMER,      // Time-based trigger
    CONDITION,  // State condition change
    API,        // REST API callback
    WEBHOOK     // HTTP webhook
}

/**
 * Event subscription definition.
 */
public class YEventSubscription {
    private final String subscriptionId;
    private final YEventType eventType;
    private final String eventSource;
    private final String correlationKey;
    private final Duration timeout;
    private final Consumer<Map<String, Object>> onEventHandler;
    private volatile boolean triggered;
    private Instant triggeredAt;
    private Map<String, Object> eventData;

    public YEventSubscription(String subscriptionId, YEventType eventType,
                              String eventSource, String correlationKey,
                              Duration timeout,
                              Consumer<Map<String, Object>> onEventHandler) {
        this.subscriptionId = subscriptionId;
        this.eventType = eventType;
        this.eventSource = eventSource;
        this.correlationKey = correlationKey;
        this.timeout = timeout;
        this.onEventHandler = onEventHandler;
        this.triggered = false;
    }

    // Getters
    public String getSubscriptionId() { return subscriptionId; }
    public YEventType getEventType() { return eventType; }
    public String getEventSource() { return eventSource; }
    public String getCorrelationKey() { return correlationKey; }
    public Duration getTimeout() { return timeout; }
    public boolean isTriggered() { return triggered; }
    public Instant getTriggeredAt() { return triggeredAt; }
    public Map<String, Object> getEventData() { return eventData; }

    /**
     * Trigger this subscription with event data.
     */
    public void trigger(Map<String, Object> data) {
        if (!triggered) {
            synchronized (this) {
                if (!triggered) {
                    this.triggered = true;
                    this.triggeredAt = Instant.now();
                    this.eventData = data;
                    if (onEventHandler != null) {
                        onEventHandler.accept(data);
                    }
                }
            }
        }
    }
}

/**
 * Gateway wait strategy.
 */
public enum YEventGatewayStrategy {
    EXCLUSIVE,      // Wait for first event (race)
    PARALLEL,       // Wait for all events
    THRESHOLD,      // Wait for N of M events
    SEQUENCED       // Wait for events in specific order
}

/**
 * Event Gateway Task - Implements WCP-51 pattern.
 *
 * Use Cases:
 * - Waiting for payment confirmation from multiple providers
 * - Approval response from any authorized person
 * - System alert from monitoring services
 * - Webhook callback from external services
 */
public class YEventGatewayTask extends YTask {

    private final Map<String, YEventSubscription> subscriptions;
    private final YEventGatewayStrategy strategy;
    private final int threshold; // For THRESHOLD strategy: how many events needed
    private final Duration globalTimeout;
    private final ExecutorService executor;

    // State tracking
    private final CountDownLatch completionLatch;
    private final List<YEventSubscription> triggeredSubscriptions;
    private final List<YEventSubscription> pendingSubscriptions;

    public YEventGatewayTask(String taskId, String taskName, YNet parentNet,
                             YEventGatewayStrategy strategy, int threshold,
                             Duration globalTimeout) {
        super(taskId, taskName, parentNet);
        this.subscriptions = new ConcurrentHashMap<>();
        this.strategy = strategy;
        this.threshold = threshold;
        this.globalTimeout = globalTimeout;
        this.executor = Executors.newCachedThreadPool();
        this.completionLatch = new CountDownLatch(1);
        this.triggeredSubscriptions = Collections.synchronizedList(new ArrayList<>());
        this.pendingSubscriptions = Collections.synchronizedList(new ArrayList<>());
    }

    {% for event in events %}
    /**
     * Event {{ loop.index }}: {{ event.eventType }}
     * Source: {{ event.eventSource }}
     * Correlation Key: {{ event.correlationKey }}
     */
    public YEventSubscription subscribe{{ loop.index }}(String caseId) {
        return subscribe(
            "{{ event.subscriptionId }}",
            YEventType.{{ event.eventType }},
            "{{ event.eventSource }}",
            "{{ event.correlationKey }}",
            Duration.parse("{{ event.timeout | default(value="PT5M") }}")
        );
    }
    {% endfor %}

    /**
     * Create a static factory for typical configurations.
     */
    public static YEventGatewayTask createExclusive(String taskId, YNet parentNet,
                                                     Duration timeout) {
        return new YEventGatewayTask(taskId, "EventGateway", parentNet,
                                     YEventGatewayStrategy.EXCLUSIVE, 1, timeout);
    }

    public static YEventGatewayTask createParallel(String taskId, YNet parentNet,
                                                    int expectedEvents, Duration timeout) {
        return new YEventGatewayTask(taskId, "EventGateway", parentNet,
                                     YEventGatewayStrategy.PARALLEL, expectedEvents, timeout);
    }

    public static YEventGatewayTask createThreshold(String taskId, YNet parentNet,
                                                     int threshold, Duration timeout) {
        return new YEventGatewayTask(taskId, "EventGateway", parentNet,
                                     YEventGatewayStrategy.THRESHOLD, threshold, timeout);
    }

    /**
     * Subscribe to an event.
     *
     * @param subscriptionId Unique subscription identifier
     * @param eventType Type of event to wait for
     * @param eventSource Source URI or identifier
     * @param correlationKey Key for correlating events to this gateway instance
     * @param timeout Subscription-level timeout
     * @return The created subscription
     */
    public YEventSubscription subscribe(String subscriptionId, YEventType eventType,
                                        String eventSource, String correlationKey,
                                        Duration timeout) {
        YEventSubscription subscription = new YEventSubscription(
            subscriptionId, eventType, eventSource, correlationKey, timeout,
            data -> handleEventTriggered(subscriptionId, data)
        );
        subscriptions.put(subscriptionId, subscription);
        pendingSubscriptions.add(subscription);
        return subscription;
    }

    /**
     * Handle an incoming event.
     *
     * @param subscriptionId The subscription that was triggered
     * @param eventData The event payload
     */
    public void handleEventTriggered(String subscriptionId, Map<String, Object> eventData) {
        YEventSubscription subscription = subscriptions.get(subscriptionId);
        if (subscription == null || subscription.isTriggered()) {
            return;
        }

        subscription.trigger(eventData);
        triggeredSubscriptions.add(subscription);
        pendingSubscriptions.remove(subscription);

        // Check if gateway completion condition is met
        if (shouldComplete()) {
            completionLatch.countDown();
        }
    }

    /**
     * Check if the gateway completion condition is met.
     */
    private boolean shouldComplete() {
        int triggeredCount = triggeredSubscriptions.size();

        switch (strategy) {
            case EXCLUSIVE:
                // Complete on first event
                return triggeredCount >= 1;

            case PARALLEL:
                // Complete when all subscriptions triggered
                return triggeredCount >= subscriptions.size();

            case THRESHOLD:
                // Complete when N events received
                return triggeredCount >= threshold;

            case SEQUENCED:
                // Check if triggered in correct order (handled separately)
                return checkSequenceOrder();

            default:
                return false;
        }
    }

    /**
     * Check if events were triggered in correct sequence order.
     */
    private boolean checkSequenceOrder() {
        // This is simplified; full implementation would track order
        return triggeredSubscriptions.size() >= threshold;
    }

    /**
     * Execute the event gateway.
     *
     * @return List of triggered subscriptions with their data
     * @throws YEventGatewayException if timeout or error occurs
     */
    public List<YEventSubscription> execute() throws YEventGatewayException {
        try {
            boolean completed = completionLatch.await(
                globalTimeout.toMillis(), TimeUnit.MILLISECONDS
            );

            if (!completed) {
                throw new YEventGatewayException(
                    "Event gateway timed out after " + globalTimeout +
                    ". Triggered: " + triggeredSubscriptions.size() +
                    "/" + subscriptions.size()
                );
            }

            return new ArrayList<>(triggeredSubscriptions);

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new YEventGatewayException("Event gateway interrupted", e);
        }
    }

    /**
     * Execute with async callback.
     */
    public CompletableFuture<List<YEventSubscription>> executeAsync() {
        return CompletableFuture.supplyAsync(() -> execute(), executor);
    }

    /**
     * Get all subscriptions.
     */
    public Collection<YEventSubscription> getSubscriptions() {
        return Collections.unmodifiableCollection(subscriptions.values());
    }

    /**
     * Get triggered subscriptions.
     */
    public List<YEventSubscription> getTriggeredSubscriptions() {
        return Collections.unmodifiableList(triggeredSubscriptions);
    }

    /**
     * Get pending subscriptions.
     */
    public List<YEventSubscription> getPendingSubscriptions() {
        return Collections.unmodifiableList(pendingSubscriptions);
    }

    /**
     * Cancel all pending subscriptions.
     */
    public void cancelAll() {
        for (YEventSubscription subscription : pendingSubscriptions) {
            // Mark as triggered to prevent further processing
            subscription.trigger(Collections.singletonMap("cancelled", true));
        }
        completionLatch.countDown();
    }

    /**
     * Get gateway status.
     */
    public EventGatewayStatus getStatus() {
        return new EventGatewayStatus(
            getTaskId(),
            strategy.name(),
            subscriptions.size(),
            triggeredSubscriptions.size(),
            pendingSubscriptions.size()
        );
    }

    /**
     * Status data class.
     */
    public static class EventGatewayStatus {
        private final String gatewayId;
        private final String strategy;
        private final int totalSubscriptions;
        private final int triggeredCount;
        private final int pendingCount;

        public EventGatewayStatus(String gatewayId, String strategy,
                                  int totalSubscriptions, int triggeredCount,
                                  int pendingCount) {
            this.gatewayId = gatewayId;
            this.strategy = strategy;
            this.totalSubscriptions = totalSubscriptions;
            this.triggeredCount = triggeredCount;
            this.pendingCount = pendingCount;
        }

        // Getters
        public String getGatewayId() { return gatewayId; }
        public String getStrategy() { return strategy; }
        public int getTotalSubscriptions() { return totalSubscriptions; }
        public int getTriggeredCount() { return triggeredCount; }
        public int getPendingCount() { return pendingCount; }
        public boolean isComplete() { return pendingCount == 0; }
    }

    @Override
    public void dispose() {
        cancelAll();
        executor.shutdown();
        super.dispose();
    }
}
