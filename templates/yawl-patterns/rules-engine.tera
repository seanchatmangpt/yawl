{#
  Template: YRulesEngineTask.java
  Pattern: WCP-60 - Rules Engine
  Description: Executes business rules to determine workflow paths
#}
/**
 * YRulesEngineTask - WCP-60 Rules Engine Pattern
 *
 * Executes business rules to determine workflow paths. Rules are declarative
 * and can be updated independently of workflow definition.
 *
 * Formalism:
 *   RulesEngine = {
 *     rules: Set[Rule],
 *     facts: Set[Fact],
 *     execute() → Apply rules to facts → Produce actions
 *   }
 *   Rule: IF condition THEN action
 *
 * @generated by ggen from ontology
 * @pattern WCP-60
 */

package org.yawlfoundation.yawl.patterns.extended;

import org.yawlfoundation.yawl.elements.YTask;
import org.yawlfoundation.yawl.elements.YNet;
import org.yawlfoundation.yawl.exceptions.YRulesEngineException;

import java.time.Instant;
import java.util.*;
import java.util.concurrent.*;

/**
 * Rule definition.
 */
public class YRule {
    private final String ruleId;
    private final String ruleName;
    private final String condition;
    private final String action;
    private final int priority;
    private final boolean enabled;
    private final Instant effectiveFrom;
    private final Instant effectiveTo;
    private final String description;

    public YRule(String ruleId, String ruleName, String condition, String action,
                 int priority, boolean enabled, Instant effectiveFrom,
                 Instant effectiveTo, String description) {
        this.ruleId = ruleId;
        this.ruleName = ruleName;
        this.condition = condition;
        this.action = action;
        this.priority = priority;
        this.enabled = enabled;
        this.effectiveFrom = effectiveFrom;
        this.effectiveTo = effectiveTo;
        this.description = description;
    }

    // Getters
    public String getRuleId() { return ruleId; }
    public String getRuleName() { return ruleName; }
    public String getCondition() { return condition; }
    public String getAction() { return action; }
    public int getPriority() { return priority; }
    public boolean isEnabled() { return enabled; }
    public Instant getEffectiveFrom() { return effectiveFrom; }
    public Instant getEffectiveTo() { return effectiveTo; }
    public String getDescription() { return description; }

    /**
     * Check if rule is currently effective.
     */
    public boolean isEffective() {
        Instant now = Instant.now();
        if (effectiveFrom != null && now.isBefore(effectiveFrom)) return false;
        if (effectiveTo != null && now.isAfter(effectiveTo)) return false;
        return true;
    }
}

/**
 * Fact for rule evaluation.
 */
public class YFact {
    private final String name;
    private final Object value;
    private final String type;

    public YFact(String name, Object value) {
        this.name = name;
        this.value = value;
        this.type = value != null ? value.getClass().getSimpleName() : "null";
    }

    // Getters
    public String getName() { return name; }
    public Object getValue() { return value; }
    public String getType() { return type; }

    public String getValueAsString() {
        return value != null ? value.toString() : null;
    }

    public Number getValueAsNumber() {
        if (value instanceof Number) return (Number) value;
        try {
            return Double.parseDouble(value.toString());
        } catch (Exception e) {
            return 0;
        }
    }

    public boolean getValueAsBoolean() {
        if (value instanceof Boolean) return (Boolean) value;
        return Boolean.parseBoolean(value.toString());
    }
}

/**
 * Rule execution result.
 */
public class YRuleResult {
    private final List<YRule> matchedRules;
    private final List<String> actions;
    private final Map<String, Object> outputFacts;
    private final Duration evaluationTime;
    private final boolean haltRequested;

    public YRuleResult(List<YRule> matchedRules, List<String> actions,
                       Map<String, Object> outputFacts, Duration evaluationTime,
                       boolean haltRequested) {
        this.matchedRules = matchedRules;
        this.actions = actions;
        this.outputFacts = outputFacts;
        this.evaluationTime = evaluationTime;
        this.haltRequested = haltRequested;
    }

    // Getters
    public List<YRule> getMatchedRules() { return matchedRules; }
    public List<String> getActions() { return actions; }
    public Map<String, Object> getOutputFacts() { return outputFacts; }
    public Duration getEvaluationTime() { return evaluationTime; }
    public boolean isHaltRequested() { return haltRequested; }
    public int getMatchCount() { return matchedRules.size(); }
}

/**
 * Rules Engine Task - Implements WCP-60 pattern.
 *
 * Use Cases:
 * - Loan approval based on credit score and income
 * - Pricing rules for products
 * - Eligibility checks for services
 * - Compliance rule evaluation
 */
public class YRulesEngineTask extends YTask {

    private final Map<String, YRule> rules;
    private final List<YRule> orderedRules;
    private final ConflictResolutionStrategy conflictStrategy;
    private final int maxRulesPerEvaluation;
    private final boolean haltOnFirstMatch;

    // Metrics
    private final AtomicInteger totalEvaluations = new AtomicInteger(0);
    private final AtomicInteger totalRulesMatched = new AtomicInteger(0);
    private final AtomicInteger totalActionsExecuted = new AtomicInteger(0);

    public enum ConflictResolutionStrategy {
        PRIORITY,       // Highest priority rule wins
        FIRST_MATCH,    // First matching rule wins
        ALL_MATCHES,    // Execute all matching rules
        SPECIFICITY     // Most specific rule wins
    }

    public YRulesEngineTask(String taskId, String taskName, YNet parentNet,
                            ConflictResolutionStrategy conflictStrategy,
                            int maxRulesPerEvaluation,
                            boolean haltOnFirstMatch) {
        super(taskId, taskName, parentNet);
        this.rules = new ConcurrentHashMap<>();
        this.orderedRules = new ArrayList<>();
        this.conflictStrategy = conflictStrategy;
        this.maxRulesPerEvaluation = maxRulesPerEvaluation;
        this.haltOnFirstMatch = haltOnFirstMatch;
    }

    public YRulesEngineTask(String taskId, YNet parentNet) {
        this(taskId, "RulesEngine", parentNet,
             ConflictResolutionStrategy.PRIORITY, 100, false);
    }

    {% for rule in rules %}
    /**
     * Rule {{ loop.index }}: {{ rule.ruleName }}
     * Condition: {{ rule.condition }}
     * Action: {{ rule.action }}
     * Priority: {{ rule.priority | default(value=0) }}
     */
    public void addRule{{ loop.index }}() {
        addRule(new YRule(
            "{{ rule.ruleId }}",
            "{{ rule.ruleName }}",
            "{{ rule.condition }}",
            "{{ rule.action }}",
            {{ rule.priority | default(value=0) }},
            {{ rule.enabled | default(value=true) }},
            {% if rule.effectiveFrom %}Instant.parse("{{ rule.effectiveFrom }}"){% else %}null{% endif %},
            {% if rule.effectiveTo %}Instant.parse("{{ rule.effectiveTo }}"){% else %}null{% endif %},
            "{{ rule.description | default(value="") }}"
        ));
    }
    {% endfor %}

    /**
     * Add a rule to the engine.
     */
    public void addRule(YRule rule) {
        rules.put(rule.getRuleId(), rule);
        rebuildOrderedRules();
    }

    /**
     * Remove a rule.
     */
    public void removeRule(String ruleId) {
        rules.remove(ruleId);
        rebuildOrderedRules();
    }

    /**
     * Enable/disable a rule.
     */
    public void setRuleEnabled(String ruleId, boolean enabled) {
        YRule existing = rules.get(ruleId);
        if (existing != null) {
            YRule updated = new YRule(
                existing.getRuleId(), existing.getRuleName(),
                existing.getCondition(), existing.getAction(),
                existing.getPriority(), enabled,
                existing.getEffectiveFrom(), existing.getEffectiveTo(),
                existing.getDescription()
            );
            rules.put(ruleId, updated);
            rebuildOrderedRules();
        }
    }

    /**
     * Rebuild ordered rules list (sorted by priority).
     */
    private void rebuildOrderedRules() {
        orderedRules.clear();
        orderedRules.addAll(rules.values());
        orderedRules.sort((a, b) -> Integer.compare(b.getPriority(), a.getPriority()));
    }

    /**
     * Evaluate rules against facts.
     *
     * @param facts Input facts for evaluation
     * @return Rule execution result with matched rules and actions
     */
    public YRuleResult evaluate(Map<String, Object> facts) {
        Instant startTime = Instant.now();
        totalEvaluations.incrementAndGet();

        // Convert facts
        Map<String, YFact> factMap = new HashMap<>();
        for (Map.Entry<String, Object> entry : facts.entrySet()) {
            factMap.put(entry.getKey(), new YFact(entry.getKey(), entry.getValue()));
        }

        List<YRule> matchedRules = new ArrayList<>();
        List<String> actions = new ArrayList<>();
        Map<String, Object> outputFacts = new HashMap<>(facts);
        boolean halt = false;

        // Get effective and enabled rules
        List<YRule> effectiveRules = new ArrayList<>();
        for (YRule rule : orderedRules) {
            if (rule.isEnabled() && rule.isEffective()) {
                effectiveRules.add(rule);
            }
        }

        // Evaluate rules based on conflict strategy
        for (YRule rule : effectiveRules) {
            if (matchedRules.size() >= maxRulesPerEvaluation) break;
            if (halt) break;

            try {
                boolean matches = evaluateCondition(rule.getCondition(), factMap, outputFacts);
                if (matches) {
                    matchedRules.add(rule);
                    actions.add(rule.getAction());
                    totalRulesMatched.incrementAndGet();
                    totalActionsExecuted.incrementAndGet();

                    // Execute action (may modify output facts)
                    executeAction(rule.getAction(), outputFacts);

                    // Check halt condition
                    if (haltOnFirstMatch ||
                        "HALT".equals(outputFacts.get("_control"))) {
                        halt = true;
                    }
                }
            } catch (Exception e) {
                // Log and continue
                logger.warn("Rule {} evaluation failed: {}", rule.getRuleId(), e.getMessage());
            }
        }

        Duration evaluationTime = Duration.between(startTime, Instant.now());
        return new YRuleResult(matchedRules, actions, outputFacts, evaluationTime, halt);
    }

    /**
     * Evaluate a condition against facts.
     * Supports simple expressions: property op value, AND, OR, NOT
     */
    private boolean evaluateCondition(String condition, Map<String, YFact> facts,
                                       Map<String, Object> outputFacts) {
        if (condition == null || condition.trim().isEmpty()) {
            return true;
        }

        String cond = condition.trim();

        // Handle AND
        if (cond.toUpperCase().contains(" AND ")) {
            String[] parts = cond.split("(?i) AND ");
            for (String part : parts) {
                if (!evaluateCondition(part.trim(), facts, outputFacts)) {
                    return false;
                }
            }
            return true;
        }

        // Handle OR
        if (cond.toUpperCase().contains(" OR ")) {
            String[] parts = cond.split("(?i) OR ");
            for (String part : parts) {
                if (evaluateCondition(part.trim(), facts, outputFacts)) {
                    return true;
                }
            }
            return false;
        }

        // Handle NOT
        if (cond.toUpperCase().startsWith("NOT ")) {
            return !evaluateCondition(cond.substring(4).trim(), facts, outputFacts);
        }

        // Handle comparison operators
        if (cond.contains("!=")) {
            String[] parts = cond.split("!=");
            return compareValues(parts[0].trim(), parts[1].trim(), facts, "!=");
        } else if (cond.contains(">=")) {
            String[] parts = cond.split(">=");
            return compareValues(parts[0].trim(), parts[1].trim(), facts, ">=");
        } else if (cond.contains("<=")) {
            String[] parts = cond.split("<=");
            return compareValues(parts[0].trim(), parts[1].trim(), facts, "<=");
        } else if (cond.contains(">")) {
            String[] parts = cond.split(">");
            return compareValues(parts[0].trim(), parts[1].trim(), facts, ">");
        } else if (cond.contains("<")) {
            String[] parts = cond.split("<");
            return compareValues(parts[0].trim(), parts[1].trim(), facts, "<");
        } else if (cond.contains("=")) {
            String[] parts = cond.split("=");
            return compareValues(parts[0].trim(), parts[1].trim(), facts, "=");
        }

        // Just check if property is truthy
        YFact fact = facts.get(cond);
        return fact != null && isTruthy(fact.getValue());
    }

    private boolean compareValues(String left, String right, Map<String, YFact> facts, String op) {
        Object leftVal = resolveValue(left, facts);
        Object rightVal = resolveValue(right, facts);

        switch (op) {
            case "=":
                return Objects.equals(leftVal, rightVal);
            case "!=":
                return !Objects.equals(leftVal, rightVal);
            case ">":
            case ">=":
            case "<":
            case "<=":
                if (leftVal instanceof Number && rightVal instanceof Number) {
                    double l = ((Number) leftVal).doubleValue();
                    double r = ((Number) rightVal).doubleValue();
                    switch (op) {
                        case ">": return l > r;
                        case ">=": return l >= r;
                        case "<": return l < r;
                        case "<=": return l <= r;
                    }
                }
                // String comparison
                int cmp = String.valueOf(leftVal).compareTo(String.valueOf(rightVal));
                switch (op) {
                    case ">": return cmp > 0;
                    case ">=": return cmp >= 0;
                    case "<": return cmp < 0;
                    case "<=": return cmp <= 0;
                }
        }
        return false;
    }

    private Object resolveValue(String expr, Map<String, YFact> facts) {
        // Check if it's a fact reference
        YFact fact = facts.get(expr);
        if (fact != null) {
            return fact.getValue();
        }

        // Check for string literal
        if (expr.startsWith("'") && expr.endsWith("'")) {
            return expr.substring(1, expr.length() - 1);
        }
        if (expr.startsWith("\"") && expr.endsWith("\"")) {
            return expr.substring(1, expr.length() - 1);
        }

        // Try to parse as number
        try {
            if (expr.contains(".")) {
                return Double.parseDouble(expr);
            }
            return Long.parseLong(expr);
        } catch (NumberFormatException e) {
            // Not a number
        }

        // Check for boolean
        if ("true".equalsIgnoreCase(expr)) return true;
        if ("false".equalsIgnoreCase(expr)) return false;
        if ("null".equalsIgnoreCase(expr)) return null;

        return expr;
    }

    private boolean isTruthy(Object value) {
        if (value == null) return false;
        if (value instanceof Boolean) return (Boolean) value;
        if (value instanceof Number) return ((Number) value).doubleValue() != 0;
        if (value instanceof String) return !((String) value).isEmpty();
        return true;
    }

    /**
     * Execute an action (may modify output facts).
     */
    private void executeAction(String action, Map<String, Object> outputFacts) {
        if (action == null || action.isEmpty()) return;

        // Simple action format: "SET property = value"
        if (action.toUpperCase().startsWith("SET ")) {
            String assignment = action.substring(4);
            int eqIdx = assignment.indexOf('=');
            if (eqIdx > 0) {
                String prop = assignment.substring(0, eqIdx).trim();
                String val = assignment.substring(eqIdx + 1).trim();
                outputFacts.put(prop, parseValue(val));
            }
        }
        // HALT action
        else if (action.equalsIgnoreCase("HALT")) {
            outputFacts.put("_control", "HALT");
        }
        // LOG action
        else if (action.toUpperCase().startsWith("LOG ")) {
            String message = action.substring(4);
            logger.info("RulesEngine action: {}", message);
        }
    }

    private Object parseValue(String val) {
        if (val.startsWith("'") && val.endsWith("'")) {
            return val.substring(1, val.length() - 1);
        }
        try {
            return Double.parseDouble(val);
        } catch (NumberFormatException e) {
            return val;
        }
    }

    /**
     * Get all rules.
     */
    public Collection<YRule> getRules() {
        return Collections.unmodifiableCollection(rules.values());
    }

    /**
     * Get rules engine metrics.
     */
    public RulesEngineMetrics getMetrics() {
        return new RulesEngineMetrics(
            getTaskId(),
            rules.size(),
            totalEvaluations.get(),
            totalRulesMatched.get(),
            totalActionsExecuted.get()
        );
    }

    /**
     * Metrics data class.
     */
    public static class RulesEngineMetrics {
        private final String taskId;
        private final int ruleCount;
        private final int totalEvaluations;
        private final int totalRulesMatched;
        private final int totalActionsExecuted;

        public RulesEngineMetrics(String taskId, int ruleCount, int totalEvaluations,
                                   int totalRulesMatched, int totalActionsExecuted) {
            this.taskId = taskId;
            this.ruleCount = ruleCount;
            this.totalEvaluations = totalEvaluations;
            this.totalRulesMatched = totalRulesMatched;
            this.totalActionsExecuted = totalActionsExecuted;
        }

        // Getters
        public String getTaskId() { return taskId; }
        public int getRuleCount() { return ruleCount; }
        public int getTotalEvaluations() { return totalEvaluations; }
        public int getTotalRulesMatched() { return totalRulesMatched; }
        public int getTotalActionsExecuted() { return totalActionsExecuted; }

        public double getAverageRulesMatched() {
            return totalEvaluations > 0 ?
                (double) totalRulesMatched / totalEvaluations : 0.0;
        }
    }
}
