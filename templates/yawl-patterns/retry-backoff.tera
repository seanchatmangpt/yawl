{#
  Template: YRetryWithBackoffTask.java
  Pattern: WCP-48 - Retry with Exponential Backoff
  Description: Automatically retries failed operations with exponentially increasing delays
#}
/**
 * YRetryWithBackoffTask - WCP-48 Retry with Exponential Backoff Pattern
 *
 * Automatically retries failed operations with exponentially increasing delays
 * between attempts to avoid overwhelming struggling services.
 *
 * Formalism:
 *   delay(n) = min(initialDelay × 2ⁿ, maxDelay) + jitter
 *   where n = attempt number (0-indexed)
 *   Retry until: success OR (attempts > maxRetries) OR (totalTime > maxTime)
 *
 * @generated by ggen from ontology
 * @pattern WCP-48
 */

package org.yawlfoundation.yawl.patterns.extended;

import org.yawlfoundation.yawl.elements.YTask;
import org.yawlfoundation.yawl.elements.YNet;
import org.yawlfoundation.yawl.exceptions.YRetryException;

import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.Supplier;

/**
 * Retry policy configuration.
 */
public class YRetryPolicy {
    private final Duration initialDelay;
    private final Duration maxDelay;
    private final int maxRetries;
    private final Duration maxTotalTime;
    private final double jitterFactor;
    private final Set<Class<? extends Throwable>> retryableExceptions;
    private final BackoffStrategy backoffStrategy;

    public enum BackoffStrategy {
        EXPONENTIAL,   // delay × 2ⁿ
        LINEAR,        // delay × n
        FIXED,         // delay
        EXPONENTIAL_WITH_JITTER  // (delay × 2ⁿ) + jitter
    }

    private YRetryPolicy(Builder builder) {
        this.initialDelay = builder.initialDelay;
        this.maxDelay = builder.maxDelay;
        this.maxRetries = builder.maxRetries;
        this.maxTotalTime = builder.maxTotalTime;
        this.jitterFactor = builder.jitterFactor;
        this.retryableExceptions = builder.retryableExceptions;
        this.backoffStrategy = builder.backoffStrategy;
    }

    public static Builder builder() {
        return new Builder();
    }

    // Getters
    public Duration getInitialDelay() { return initialDelay; }
    public Duration getMaxDelay() { return maxDelay; }
    public int getMaxRetries() { return maxRetries; }
    public Duration getMaxTotalTime() { return maxTotalTime; }
    public double getJitterFactor() { return jitterFactor; }
    public Set<Class<? extends Throwable>> getRetryableExceptions() { return retryableExceptions; }
    public BackoffStrategy getBackoffStrategy() { return backoffStrategy; }

    public static class Builder {
        private Duration initialDelay = Duration.ofMillis(100);
        private Duration maxDelay = Duration.ofSeconds(60);
        private int maxRetries = 5;
        private Duration maxTotalTime = Duration.ofMinutes(5);
        private double jitterFactor = 0.5;
        private Set<Class<? extends Throwable>> retryableExceptions = new HashSet<>();
        private BackoffStrategy backoffStrategy = BackoffStrategy.EXPONENTIAL_WITH_JITTER;

        public Builder initialDelay(Duration delay) {
            this.initialDelay = delay;
            return this;
        }

        public Builder maxDelay(Duration delay) {
            this.maxDelay = delay;
            return this;
        }

        public Builder maxRetries(int retries) {
            this.maxRetries = retries;
            return this;
        }

        public Builder maxTotalTime(Duration time) {
            this.maxTotalTime = time;
            return this;
        }

        public Builder jitterFactor(double factor) {
            this.jitterFactor = factor;
            return this;
        }

        @SafeVarargs
        public final Builder retryableExceptions(Class<? extends Throwable>... exceptions) {
            Collections.addAll(this.retryableExceptions, exceptions);
            return this;
        }

        public Builder backoffStrategy(BackoffStrategy strategy) {
            this.backoffStrategy = strategy;
            return this;
        }

        public YRetryPolicy build() {
            return new YRetryPolicy(this);
        }
    }
}

/**
 * Retry execution result.
 */
public class YRetryResult<T> {
    private final T result;
    private final Throwable finalError;
    private final int attempts;
    private final Duration totalDuration;
    private final List<Duration> delays;
    private final boolean success;

    private YRetryResult(T result, Throwable error, int attempts, Duration duration, List<Duration> delays) {
        this.result = result;
        this.finalError = error;
        this.attempts = attempts;
        this.totalDuration = duration;
        this.delays = delays;
        this.success = error == null;
    }

    public static <T> YRetryResult<T> success(T result, int attempts, Duration duration, List<Duration> delays) {
        return new YRetryResult<>(result, null, attempts, duration, delays);
    }

    public static <T> YRetryResult<T> failure(Throwable error, int attempts, Duration duration, List<Duration> delays) {
        return new YRetryResult<>(null, error, attempts, duration, delays);
    }

    // Getters
    public T getResult() { return result; }
    public Throwable getFinalError() { return finalError; }
    public int getAttempts() { return attempts; }
    public Duration getTotalDuration() { return totalDuration; }
    public List<Duration> getDelays() { return delays; }
    public boolean isSuccess() { return success; }
}

/**
 * Retry with Backoff Task - Implements WCP-48 pattern.
 *
 * Use Cases:
 * - Network requests with transient failures
 * - Database operations under load
 * - External API calls with rate limiting
 * - Cloud service requests
 */
public class YRetryWithBackoffTask extends YTask {

    private final YRetryPolicy policy;
    private final Random random;
    private final ExecutorService executor;

    // Metrics
    private final AtomicInteger totalAttempts = new AtomicInteger(0);
    private final AtomicInteger successOnFirstTry = new AtomicInteger(0);
    private final AtomicInteger successAfterRetry = new AtomicInteger(0);
    private final AtomicInteger exhaustedRetries = new AtomicInteger(0);

    public YRetryWithBackoffTask(String taskId, String taskName, YNet parentNet,
                                 YRetryPolicy policy) {
        super(taskId, taskName, parentNet);
        this.policy = policy;
        this.random = new Random();
        this.executor = Executors.newCachedThreadPool();
    }

    public YRetryWithBackoffTask(String taskId, YNet parentNet) {
        this(taskId, "RetryWithBackoff", parentNet, YRetryPolicy.builder().build());
    }

    /**
     * Execute an operation with retry logic.
     *
     * @param operation The operation to execute
     * @param <T> Return type
     * @return Retry result containing success/failure and metadata
     */
    public <T> YRetryResult<T> execute(Supplier<T> operation) {
        return execute(operation, null);
    }

    /**
     * Execute an operation with retry logic and custom error handler.
     *
     * @param operation The operation to execute
     * @param onError Callback for each error (for logging/metrics)
     * @param <T> Return type
     * @return Retry result
     */
    public <T> YRetryResult<T> execute(Supplier<T> operation,
                                        Consumer<Throwable> onError) {
        Instant startTime = Instant.now();
        List<Duration> delays = new ArrayList<>();
        Throwable lastError = null;
        int attempt = 0;

        while (true) {
            attempt++;
            totalAttempts.incrementAndGet();

            // Check max total time
            Duration elapsed = Duration.between(startTime, Instant.now());
            if (elapsed.compareTo(policy.getMaxTotalTime()) > 0) {
                exhaustedRetries.incrementAndGet();
                return YRetryResult.failure(
                    new YRetryException("Max total time exceeded: " + elapsed),
                    attempt, elapsed, delays
                );
            }

            // Check max retries
            if (attempt > policy.getMaxRetries() + 1) {
                exhaustedRetries.incrementAndGet();
                return YRetryResult.failure(
                    new YRetryException("Max retries exceeded: " + policy.getMaxRetries(),
                                       lastError),
                    attempt - 1, elapsed, delays
                );
            }

            // Try the operation
            try {
                T result = operation.get();

                if (attempt == 1) {
                    successOnFirstTry.incrementAndGet();
                } else {
                    successAfterRetry.incrementAndGet();
                }

                return YRetryResult.success(result, attempt, elapsed, delays);

            } catch (Throwable e) {
                lastError = e;

                // Notify error handler
                if (onError != null) {
                    onError.accept(e);
                }

                // Check if exception is retryable
                if (!isRetryable(e)) {
                    return YRetryResult.failure(e, attempt, elapsed, delays);
                }

                // Calculate delay for next attempt
                if (attempt <= policy.getMaxRetries()) {
                    Duration delay = calculateDelay(attempt - 1);
                    delays.add(delay);

                    try {
                        Thread.sleep(delay.toMillis());
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        return YRetryResult.failure(
                            new YRetryException("Retry interrupted", ie),
                            attempt, elapsed, delays
                        );
                    }
                }
            }
        }
    }

    /**
     * Execute async with retry.
     */
    public <T> CompletableFuture<YRetryResult<T>> executeAsync(Supplier<T> operation) {
        return CompletableFuture.supplyAsync(() -> execute(operation), executor);
    }

    /**
     * Execute with void return.
     */
    public YRetryResult<Void> executeVoid(Runnable operation) {
        return execute(() -> {
            operation.run();
            return null;
        });
    }

    /**
     * Check if an exception is retryable.
     */
    private boolean isRetryable(Throwable error) {
        if (policy.getRetryableExceptions().isEmpty()) {
            // Default: retry on all exceptions except these
            return !(error instanceof Error) &&
                   !(error instanceof InterruptedException);
        }

        for (Class<? extends Throwable> retryable : policy.getRetryableExceptions()) {
            if (retryable.isInstance(error)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Calculate delay for a given attempt number.
     */
    private Duration calculateDelay(int attemptNumber) {
        long delayMs;

        switch (policy.getBackoffStrategy()) {
            case FIXED:
                delayMs = policy.getInitialDelay().toMillis();
                break;

            case LINEAR:
                delayMs = policy.getInitialDelay().toMillis() * (attemptNumber + 1);
                break;

            case EXPONENTIAL:
                delayMs = (long) (policy.getInitialDelay().toMillis() *
                                  Math.pow(2, attemptNumber));
                break;

            case EXPONENTIAL_WITH_JITTER:
            default:
                delayMs = (long) (policy.getInitialDelay().toMillis() *
                                  Math.pow(2, attemptNumber));
                // Add jitter
                long jitter = (long) (delayMs * policy.getJitterFactor() *
                                      random.nextDouble());
                delayMs = delayMs + jitter - (long)(jitter / 2.0);
                break;
        }

        // Cap at max delay
        return Duration.ofMillis(Math.min(delayMs, policy.getMaxDelay().toMillis()));
    }

    /**
     * Get retry metrics.
     */
    public RetryMetrics getMetrics() {
        return new RetryMetrics(
            getTaskId(),
            totalAttempts.get(),
            successOnFirstTry.get(),
            successAfterRetry.get(),
            exhaustedRetries.get()
        );
    }

    /**
     * Metrics data class.
     */
    public static class RetryMetrics {
        private final String taskId;
        private final int totalAttempts;
        private final int successOnFirstTry;
        private final int successAfterRetry;
        private final int exhaustedRetries;

        public RetryMetrics(String taskId, int totalAttempts, int successOnFirstTry,
                            int successAfterRetry, int exhaustedRetries) {
            this.taskId = taskId;
            this.totalAttempts = totalAttempts;
            this.successOnFirstTry = successOnFirstTry;
            this.successAfterRetry = successAfterRetry;
            this.exhaustedRetries = exhaustedRetries;
        }

        // Getters
        public String getTaskId() { return taskId; }
        public int getTotalAttempts() { return totalAttempts; }
        public int getSuccessOnFirstTry() { return successOnFirstTry; }
        public int getSuccessAfterRetry() { return successAfterRetry; }
        public int getExhaustedRetries() { return exhaustedRetries; }

        public int getTotalSuccesses() {
            return successOnFirstTry + successAfterRetry;
        }

        public double getSuccessRate() {
            int total = getTotalSuccesses() + exhaustedRetries;
            return total > 0 ? (double) getTotalSuccesses() / total : 0.0;
        }

        public double getFirstTrySuccessRate() {
            int total = getTotalSuccesses() + exhaustedRetries;
            return total > 0 ? (double) successOnFirstTry / total : 0.0;
        }
    }

    @Override
    public void dispose() {
        executor.shutdown();
        try {
            if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
        super.dispose();
    }
}
