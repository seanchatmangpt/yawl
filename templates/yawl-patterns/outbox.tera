{#
  Template: YOutboxPatternTask.java
  Pattern: WCP-54 - Outbox Pattern
  Description: Ensures reliable message delivery with transactional outbox
#}
/**
 * YOutboxPatternTask - WCP-54 Outbox Pattern
 *
 * Ensures reliable message delivery by storing outgoing messages in an outbox
 * table within the same transaction as state changes, then publishing asynchronously.
 *
 * Formalism:
 *   Transaction:
 *     1. Update workflow state
 *     2. Insert message into outbox
 *   Async Publisher:
 *     3. Read unpublished messages
 *     4. Publish to message broker
 *     5. Mark as published
 *
 * @generated by ggen from ontology
 * @pattern WCP-54
 */

package org.yawlfoundation.yawl.patterns.extended;

import org.yawlfoundation.yawl.elements.YTask;
import org.yawlfoundation.yawl.elements.YNet;
import org.yawlfoundation.yawl.exceptions.YOutboxException;

import javax.sql.DataSource;
import java.sql.*;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.*;

/**
 * Outbox message representation.
 */
public class YOutboxMessage {
    private final String messageId;
    private final String aggregateType;
    private final String aggregateId;
    private final String eventType;
    private final String payload;
    private final Instant createdAt;
    private Instant publishedAt;
    private int retryCount;
    private String lastError;

    public YOutboxMessage(String messageId, String aggregateType, String aggregateId,
                          String eventType, String payload) {
        this.messageId = messageId;
        this.aggregateType = aggregateType;
        this.aggregateId = aggregateId;
        this.eventType = eventType;
        this.payload = payload;
        this.createdAt = Instant.now();
        this.retryCount = 0;
    }

    // Getters and setters
    public String getMessageId() { return messageId; }
    public String getAggregateType() { return aggregateType; }
    public String getAggregateId() { return aggregateId; }
    public String getEventType() { return eventType; }
    public String getPayload() { return payload; }
    public Instant getCreatedAt() { return createdAt; }
    public Instant getPublishedAt() { return publishedAt; }
    public void setPublishedAt(Instant publishedAt) { this.publishedAt = publishedAt; }
    public int getRetryCount() { return retryCount; }
    public void incrementRetry() { this.retryCount++; }
    public String getLastError() { return lastError; }
    public void setLastError(String error) { this.lastError = error; }
}

/**
 * Message publisher interface.
 */
public interface YMessagePublisher {
    void publish(YOutboxMessage message) throws Exception;
}

/**
 * Outbox Pattern Task - Implements WCP-54 pattern.
 *
 * Use Cases:
 * - Event sourcing with reliable delivery
 * - Microservices communication
 * - Audit trails with guaranteed delivery
 * - Domain event publishing
 */
public class YOutboxPatternTask extends YTask {

    private final DataSource dataSource;
    private final YMessagePublisher publisher;
    private final String outboxTable;
    private final int maxRetries;
    private final Duration retryDelay;
    private final int batchSize;
    private final ScheduledExecutorService scheduler;

    // State
    private volatile boolean running;
    private ScheduledFuture<?> publisherTask;

    // Metrics
    private final AtomicInteger totalPublished = new AtomicInteger(0);
    private final AtomicInteger totalFailed = new AtomicInteger(0);
    private final AtomicInteger currentPending = new AtomicInteger(0);

    public YOutboxPatternTask(String taskId, String taskName, YNet parentNet,
                              DataSource dataSource, YMessagePublisher publisher,
                              String outboxTable, int maxRetries, Duration retryDelay,
                              int batchSize, Duration pollInterval) {
        super(taskId, taskName, parentNet);
        this.dataSource = dataSource;
        this.publisher = publisher;
        this.outboxTable = outboxTable;
        this.maxRetries = maxRetries;
        this.retryDelay = retryDelay;
        this.batchSize = batchSize;
        this.scheduler = Executors.newSingleThreadScheduledExecutor();

        // Start the publisher task
        if (pollInterval != null && pollInterval.toMillis() > 0) {
            startPublisher(pollInterval);
        }
    }

    /**
     * Create the outbox table if it doesn't exist.
     */
    public void initializeSchema() throws SQLException {
        String createTable = String.format("""
            CREATE TABLE IF NOT EXISTS %s (
                message_id VARCHAR(64) PRIMARY KEY,
                aggregate_type VARCHAR(128) NOT NULL,
                aggregate_id VARCHAR(128) NOT NULL,
                event_type VARCHAR(128) NOT NULL,
                payload CLOB NOT NULL,
                created_at TIMESTAMP NOT NULL,
                published_at TIMESTAMP,
                retry_count INTEGER DEFAULT 0,
                last_error VARCHAR(512)
            )
            """, outboxTable);

        try (Connection conn = dataSource.getConnection();
             Statement stmt = conn.createStatement()) {
            stmt.execute(createTable);
        }
    }

    /**
     * Save a message to the outbox within the current transaction.
     *
     * @param message The message to save
     * @param connection The current transaction connection
     */
    public void saveToOutbox(YOutboxMessage message, Connection connection)
            throws SQLException {
        String insert = String.format("""
            INSERT INTO %s (message_id, aggregate_type, aggregate_id, event_type,
                           payload, created_at, retry_count)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            """, outboxTable);

        try (PreparedStatement stmt = connection.prepareStatement(insert)) {
            stmt.setString(1, message.getMessageId());
            stmt.setString(2, message.getAggregateType());
            stmt.setString(3, message.getAggregateId());
            stmt.setString(4, message.getEventType());
            stmt.setString(5, message.getPayload());
            stmt.setTimestamp(6, Timestamp.from(message.getCreatedAt()));
            stmt.setInt(7, message.getRetryCount());
            stmt.executeUpdate();
        }

        currentPending.incrementAndGet();
    }

    /**
     * Save a message to the outbox (new transaction).
     */
    public void saveToOutbox(YOutboxMessage message) throws SQLException {
        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);
            try {
                saveToOutbox(message, conn);
                conn.commit();
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        }
    }

    /**
     * Save multiple messages atomically.
     */
    public void saveAllToOutbox(List<YOutboxMessage> messages) throws SQLException {
        try (Connection conn = dataSource.getConnection()) {
            conn.setAutoCommit(false);
            try {
                for (YOutboxMessage message : messages) {
                    saveToOutbox(message, conn);
                }
                conn.commit();
            } catch (SQLException e) {
                conn.rollback();
                throw e;
            }
        }
    }

    /**
     * Start the background publisher task.
     */
    private void startPublisher(Duration pollInterval) {
        running = true;
        publisherTask = scheduler.scheduleAtFixedRate(
            this::publishPendingMessages,
            0,
            pollInterval.toMillis(),
            TimeUnit.MILLISECONDS
        );
    }

    /**
     * Publish pending messages.
     */
    public void publishPendingMessages() {
        List<YOutboxMessage> messages = fetchPendingMessages();

        for (YOutboxMessage message : messages) {
            try {
                publisher.publish(message);
                markAsPublished(message);
                totalPublished.incrementAndGet();
                currentPending.decrementAndGet();

            } catch (Exception e) {
                handlePublishFailure(message, e);
            }
        }
    }

    /**
     * Fetch pending messages from outbox.
     */
    private List<YOutboxMessage> fetchPendingMessages() {
        List<YOutboxMessage> messages = new ArrayList<>();

        String query = String.format("""
            SELECT message_id, aggregate_type, aggregate_id, event_type, payload,
                   created_at, retry_count, last_error
            FROM %s
            WHERE published_at IS NULL AND retry_count < ?
            ORDER BY created_at
            LIMIT ?
            """, outboxTable);

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setInt(1, maxRetries);
            stmt.setInt(2, batchSize);

            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    YOutboxMessage message = new YOutboxMessage(
                        rs.getString("message_id"),
                        rs.getString("aggregate_type"),
                        rs.getString("aggregate_id"),
                        rs.getString("event_type"),
                        rs.getString("payload")
                    );
                    message.setPublishedAt(rs.getTimestamp("published_at") != null ?
                        rs.getTimestamp("published_at").toInstant() : null);
                    // retryCount set via reflection or additional setter
                    message.setLastError(rs.getString("last_error"));
                    messages.add(message);
                }
            }
        } catch (SQLException e) {
            logger.error("Failed to fetch pending messages: {}", e.getMessage());
        }

        return messages;
    }

    /**
     * Mark a message as published.
     */
    private void markAsPublished(YOutboxMessage message) {
        String update = String.format("""
            UPDATE %s SET published_at = ? WHERE message_id = ?
            """, outboxTable);

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(update)) {
            stmt.setTimestamp(1, Timestamp.from(Instant.now()));
            stmt.setString(2, message.getMessageId());
            stmt.executeUpdate();
        } catch (SQLException e) {
            logger.error("Failed to mark message as published: {}", e.getMessage());
        }
    }

    /**
     * Handle publish failure.
     */
    private void handlePublishFailure(YOutboxMessage message, Exception error) {
        message.incrementRetry();
        message.setLastError(error.getMessage());

        String update = String.format("""
            UPDATE %s SET retry_count = ?, last_error = ? WHERE message_id = ?
            """, outboxTable);

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(update)) {
            stmt.setInt(1, message.getRetryCount());
            stmt.setString(2, error.getMessage());
            stmt.setString(3, message.getMessageId());
            stmt.executeUpdate();
        } catch (SQLException e) {
            logger.error("Failed to update message retry count: {}", e.getMessage());
        }

        if (message.getRetryCount() >= maxRetries) {
            totalFailed.incrementAndGet();
            currentPending.decrementAndGet();
            logger.error("Message {} exceeded max retries: {}", message.getMessageId(), error.getMessage());
        }
    }

    /**
     * Get outbox metrics.
     */
    public OutboxMetrics getMetrics() {
        int pending = countPending();
        int failed = countFailed();
        return new OutboxMetrics(
            getTaskId(),
            pending,
            totalPublished.get(),
            totalFailed.get(),
            failed
        );
    }

    private int countPending() {
        String query = String.format(
            "SELECT COUNT(*) FROM %s WHERE published_at IS NULL AND retry_count < ?",
            outboxTable
        );
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setInt(1, maxRetries);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) return rs.getInt(1);
            }
        } catch (SQLException e) {
            logger.error("Failed to count pending: {}", e.getMessage());
        }
        return 0;
    }

    private int countFailed() {
        String query = String.format(
            "SELECT COUNT(*) FROM %s WHERE retry_count >= ?",
            outboxTable
        );
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(query)) {
            stmt.setInt(1, maxRetries);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) return rs.getInt(1);
            }
        } catch (SQLException e) {
            logger.error("Failed to count failed: {}", e.getMessage());
        }
        return 0;
    }

    /**
     * Stop the publisher task.
     */
    public void stop() {
        running = false;
        if (publisherTask != null) {
            publisherTask.cancel(false);
        }
    }

    /**
     * Metrics data class.
     */
    public static class OutboxMetrics {
        private final String outboxId;
        private final int pendingCount;
        private final int publishedCount;
        private final int failedCount;
        private final int deadLetterCount;

        public OutboxMetrics(String outboxId, int pendingCount, int publishedCount,
                             int failedCount, int deadLetterCount) {
            this.outboxId = outboxId;
            this.pendingCount = pendingCount;
            this.publishedCount = publishedCount;
            this.failedCount = failedCount;
            this.deadLetterCount = deadLetterCount;
        }

        // Getters
        public String getOutboxId() { return outboxId; }
        public int getPendingCount() { return pendingCount; }
        public int getPublishedCount() { return publishedCount; }
        public int getFailedCount() { return failedCount; }
        public int getDeadLetterCount() { return deadLetterCount; }
    }

    @Override
    public void dispose() {
        stop();
        scheduler.shutdown();
        try {
            if (!scheduler.awaitTermination(30, TimeUnit.SECONDS)) {
                scheduler.shutdownNow();
            }
        } catch (InterruptedException e) {
            scheduler.shutdownNow();
            Thread.currentThread().interrupt();
        }
        super.dispose();
    }
}
