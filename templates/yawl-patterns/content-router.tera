{#
  Template: YContentBasedRouterTask.java
  Pattern: WCP-58 - Content-Based Router
  Description: Routes messages to different recipients based on message content
#}
/**
 * YContentBasedRouterTask - WCP-58 Content-Based Router Pattern
 *
 * Routes messages to different recipients based on message content.
 * Evaluates content against routing rules.
 *
 * Formalism:
 *   Route(message) = recipientᵢ where:
 *     ruleᵢ(message) == true AND
 *     ∀j < i: ruleⱼ(message) == false
 *
 * @generated by ggen from ontology
 * @pattern WCP-58
 */

package org.yawlfoundation.yawl.patterns.extended;

import org.yawlfoundation.yawl.elements.YTask;
import org.yawlfoundation.yawl.elements.YNet;
import org.yawlfoundation.yawl.exceptions.YRoutingException;

import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathFactory;
import javax.xml.xpath.XPathExpression;
import javax.xml.parsers.DocumentBuilderFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Node;

import java.util.*;
import java.util.function.Function;
import java.util.function.Predicate;

/**
 * Routing rule definition.
 */
public class YRoutingRule {
    private final String ruleId;
    private final int ruleOrder;
    private final String condition;
    private final String destination;
    private final String description;
    private final Predicate<Map<String, Object>> evaluator;
    private final RoutingRuleType ruleType;

    public enum RoutingRuleType {
        XPATH,      // XPath expression against XML content
        JSONPATH,   // JSONPath expression against JSON content
        GROOVY,     // Groovy script expression
        JAVA,       // Java predicate
        SIMPLE      // Simple property matching
    }

    public YRoutingRule(String ruleId, int ruleOrder, String condition,
                        String destination, String description,
                        RoutingRuleType ruleType,
                        Predicate<Map<String, Object>> evaluator) {
        this.ruleId = ruleId;
        this.ruleOrder = ruleOrder;
        this.condition = condition;
        this.destination = destination;
        this.description = description;
        this.ruleType = ruleType;
        this.evaluator = evaluator;
    }

    // Getters
    public String getRuleId() { return ruleId; }
    public int getRuleOrder() { return ruleOrder; }
    public String getCondition() { return condition; }
    public String getDestination() { return destination; }
    public String getDescription() { return description; }
    public RoutingRuleType getRuleType() { return ruleType; }

    /**
     * Evaluate this rule against message content.
     */
    public boolean matches(Map<String, Object> content) {
        if (evaluator != null) {
            return evaluator.test(content);
        }
        return false;
    }
}

/**
 * Content-Based Router Task - Implements WCP-58 pattern.
 *
 * Use Cases:
 * - Order routing by type (electronic, physical, subscription)
 * - Priority-based processing (urgent, normal, low)
 * - Region-based service selection
 * - Type-based handler dispatch
 */
public class YContentBasedRouterTask extends YTask {

    private final List<YRoutingRule> rules;
    private final String defaultDestination;
    private final Function<Map<String, Object>, String> defaultRouter;
    private final boolean stopOnFirstMatch;

    // Metrics
    private final Map<String, AtomicInteger> routingCounts;
    private final AtomicInteger totalRouted;
    private final AtomicInteger unroutableCount;

    public YContentBasedRouterTask(String taskId, String taskName, YNet parentNet,
                                   String defaultDestination, boolean stopOnFirstMatch) {
        super(taskId, taskName, parentNet);
        this.rules = new ArrayList<>();
        this.defaultDestination = defaultDestination;
        this.defaultRouter = null;
        this.stopOnFirstMatch = stopOnFirstMatch;
        this.routingCounts = new ConcurrentHashMap<>();
        this.totalRouted = new AtomicInteger(0);
        this.unroutableCount = new AtomicInteger(0);
    }

    {% for rule in rules %}
    /**
     * Rule {{ loop.index }}: {{ rule.description }}
     * Condition: {{ rule.condition }}
     * Destination: {{ rule.destination }}
     */
    public void addRule{{ loop.index }}() {
        addRule(
            "{{ rule.ruleId }}",
            {{ rule.ruleOrder | default(value=loop.index) }},
            "{{ rule.condition }}",
            "{{ rule.destination }}",
            "{{ rule.description }}",
            YRoutingRule.RoutingRuleType.{{ rule.ruleType | default(value="SIMPLE") }}
        );
    }
    {% endfor %}

    /**
     * Add a routing rule.
     *
     * @param ruleId Unique rule identifier
     * @param ruleOrder Order/priority of rule (lower = higher priority)
     * @param condition Condition expression
     * @param destination Destination task/endpoint
     * @param description Human-readable description
     * @param ruleType Type of condition evaluation
     */
    public void addRule(String ruleId, int ruleOrder, String condition,
                        String destination, String description,
                        YRoutingRule.RoutingRuleType ruleType) {
        Predicate<Map<String, Object>> evaluator = createEvaluator(condition, ruleType);
        rules.add(new YRoutingRule(ruleId, ruleOrder, condition, destination,
                                  description, ruleType, evaluator));
        rules.sort(Comparator.comparingInt(YRoutingRule::getRuleOrder));
        routingCounts.putIfAbsent(destination, new AtomicInteger(0));
    }

    /**
     * Add a rule with custom Java predicate.
     */
    public void addRule(String ruleId, int ruleOrder, String destination,
                        String description, Predicate<Map<String, Object>> evaluator) {
        rules.add(new YRoutingRule(ruleId, ruleOrder, "JAVA", destination,
                                  description, YRoutingRule.RoutingRuleType.JAVA, evaluator));
        rules.sort(Comparator.comparingInt(YRoutingRule::getRuleOrder));
        routingCounts.putIfAbsent(destination, new AtomicInteger(0));
    }

    /**
     * Create an evaluator for the given condition and type.
     */
    private Predicate<Map<String, Object>> createEvaluator(String condition,
                                                           YRoutingRule.RoutingRuleType type) {
        switch (type) {
            case SIMPLE:
                // Format: "property=value" or "property>value"
                return createSimpleEvaluator(condition);

            case XPATH:
                return createXPathEvaluator(condition);

            case JSONPATH:
                return createJsonPathEvaluator(condition);

            case GROOVY:
                return createGroovyEvaluator(condition);

            default:
                return content -> false;
        }
    }

    /**
     * Simple property matching evaluator.
     * Supports: property=value, property!=value, property>value, property<value
     */
    private Predicate<Map<String, Object>> createSimpleEvaluator(String condition) {
        return content -> {
            if (condition == null || condition.isEmpty()) {
                return false;
            }

            // Parse condition
            String[] parts;
            String operator;
            if (condition.contains("!=")) {
                parts = condition.split("!=");
                operator = "!=";
            } else if (condition.contains(">=")) {
                parts = condition.split(">=");
                operator = ">=";
            } else if (condition.contains("<=")) {
                parts = condition.split("<=");
                operator = "<=";
            } else if (condition.contains(">")) {
                parts = condition.split(">");
                operator = ">";
            } else if (condition.contains("<")) {
                parts = condition.split("<");
                operator = "<";
            } else if (condition.contains("=")) {
                parts = condition.split("=");
                operator = "=";
            } else {
                // Just check if property exists and is truthy
                Object value = content.get(condition);
                return isTruthy(value);
            }

            if (parts.length != 2) return false;

            String property = parts[0].trim();
            String expectedValue = parts[1].trim();
            Object actualValue = content.get(property);

            if (actualValue == null) return false;

            return evaluateCondition(actualValue.toString(), expectedValue, operator);
        };
    }

    private boolean evaluateCondition(String actual, String expected, String operator) {
        switch (operator) {
            case "=":
                return actual.equals(expected);
            case "!=":
                return !actual.equals(expected);
            case ">":
                return compareNumeric(actual, expected) > 0;
            case "<":
                return compareNumeric(actual, expected) < 0;
            case ">=":
                return compareNumeric(actual, expected) >= 0;
            case "<=":
                return compareNumeric(actual, expected) <= 0;
            default:
                return false;
        }
    }

    private int compareNumeric(String a, String b) {
        try {
            return Double.compare(Double.parseDouble(a), Double.parseDouble(b));
        } catch (NumberFormatException e) {
            return a.compareTo(b);
        }
    }

    private boolean isTruthy(Object value) {
        if (value == null) return false;
        if (value instanceof Boolean) return (Boolean) value;
        if (value instanceof Number) return ((Number) value).doubleValue() != 0;
        if (value instanceof String) return !((String) value).isEmpty();
        return true;
    }

    /**
     * Create XPath evaluator (simplified implementation).
     */
    private Predicate<Map<String, Object>> createXPathEvaluator(String xpath) {
        // Full implementation would use javax.xml.xpath
        return content -> {
            Object value = content.get("_xpathResult");
            return value != null && Boolean.parseBoolean(value.toString());
        };
    }

    /**
     * Create JSONPath evaluator (simplified implementation).
     */
    private Predicate<Map<String, Object>> createJsonPathEvaluator(String jsonPath) {
        // Full implementation would use a JSONPath library
        return content -> {
            // Navigate nested maps using dot notation
            String[] parts = jsonPath.split("\\.");
            Object current = content;
            for (String part : parts) {
                if (current instanceof Map) {
                    current = ((Map<?, ?>) current).get(part);
                } else {
                    return false;
                }
            }
            return isTruthy(current);
        };
    }

    /**
     * Create Groovy evaluator (placeholder).
     */
    private Predicate<Map<String, Object>> createGroovyEvaluator(String script) {
        // Full implementation would use Groovy scripting
        return content -> false;
    }

    /**
     * Route a message to the appropriate destination.
     *
     * @param content The message content to evaluate
     * @return The destination task/endpoint identifier
     * @throws YRoutingException if no matching rule and no default
     */
    public String route(Map<String, Object> content) throws YRoutingException {
        totalRouted.incrementAndGet();

        List<String> matchedDestinations = new ArrayList<>();

        for (YRoutingRule rule : rules) {
            if (rule.matches(content)) {
                matchedDestinations.add(rule.getDestination());

                if (stopOnFirstMatch) {
                    routingCounts.get(rule.getDestination()).incrementAndGet();
                    return rule.getDestination();
                }
            }
        }

        // If not stopping on first match, return all matched or default
        if (!matchedDestinations.isEmpty()) {
            // Return first match (could also return all for multicast)
            String destination = matchedDestinations.get(0);
            routingCounts.get(destination).incrementAndGet();
            return destination;
        }

        // No match - use default
        if (defaultDestination != null) {
            routingCounts.get(defaultDestination).incrementAndGet();
            return defaultDestination;
        }

        if (defaultRouter != null) {
            String destination = defaultRouter.apply(content);
            routingCounts.computeIfAbsent(destination, k -> new AtomicInteger(0))
                        .incrementAndGet();
            return destination;
        }

        unroutableCount.incrementAndGet();
        throw new YRoutingException("No matching route found for content: " + content);
    }

    /**
     * Route to multiple destinations (multicast).
     */
    public List<String> routeAll(Map<String, Object> content) {
        totalRouted.incrementAndGet();
        List<String> destinations = new ArrayList<>();

        for (YRoutingRule rule : rules) {
            if (rule.matches(content)) {
                destinations.add(rule.getDestination());
                routingCounts.get(rule.getDestination()).incrementAndGet();
            }
        }

        if (destinations.isEmpty() && defaultDestination != null) {
            destinations.add(defaultDestination);
            routingCounts.get(defaultDestination).incrementAndGet();
        }

        return destinations;
    }

    /**
     * Get routing metrics.
     */
    public RoutingMetrics getMetrics() {
        Map<String, Integer> counts = new HashMap<>();
        routingCounts.forEach((k, v) -> counts.put(k, v.get()));
        return new RoutingMetrics(getTaskId(), totalRouted.get(), unroutableCount.get(), counts);
    }

    /**
     * Get all configured rules.
     */
    public List<YRoutingRule> getRules() {
        return Collections.unmodifiableList(rules);
    }

    /**
     * Metrics data class.
     */
    public static class RoutingMetrics {
        private final String routerId;
        private final int totalRouted;
        private final int unroutableCount;
        private final Map<String, Integer> destinationCounts;

        public RoutingMetrics(String routerId, int totalRouted, int unroutableCount,
                              Map<String, Integer> destinationCounts) {
            this.routerId = routerId;
            this.totalRouted = totalRouted;
            this.unroutableCount = unroutableCount;
            this.destinationCounts = destinationCounts;
        }

        // Getters
        public String getRouterId() { return routerId; }
        public int getTotalRouted() { return totalRouted; }
        public int getUnroutableCount() { return unroutableCount; }
        public Map<String, Integer> getDestinationCounts() { return destinationCounts; }
    }
}
