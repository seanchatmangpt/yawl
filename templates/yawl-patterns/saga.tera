{#
  Template: YSagaOrchestrationTask.java
  Pattern: WCP-44 - Saga Orchestration
  Description: Coordinates a sequence of local transactions with compensating actions
#}
/**
 * YSagaOrchestrationTask - WCP-44 Saga Orchestration Pattern
 *
 * Coordinates a sequence of local transactions across multiple services with
 * compensating actions for rollback. A central orchestrator manages the saga lifecycle.
 *
 * Formalism:
 *   Saga = (T₁ × C₁) → (T₂ × C₂) → ... → (Tₙ × Cₙ)
 *   where Tᵢ = forward transaction, Cᵢ = compensating transaction
 *   Rollback: ∀i ∈ [k+1..n]: execute Cᵢ if Tₖ fails
 *
 * @generated by ggen from ontology
 * @pattern WCP-44
 */

package org.yawlfoundation.yawl.patterns.extended;

import org.yawlfoundation.yawl.engine.YEngine;
import org.yawlfoundation.yawl.elements.YTask;
import org.yawlfoundation.yawl.elements.YNet;
import org.yawlfoundation.yawl.elements.YDecomposition;
import org.yawlfoundation.yawl.exceptions.YSagaException;
import org.yawlfoundation.yawl.state.YState;

import java.util.*;
import java.util.concurrent.*;
import java.time.Duration;
import java.time.Instant;

/**
 * Represents a single step in a saga with forward and compensating actions.
 */
public class YSagaStep {
    private final String stepId;
    private final String stepName;
    private final YTask forwardAction;
    private final YTask compensatingAction;
    private final boolean compensatable;
    private final int retryLimit;
    private final Duration timeout;
    private YSagaStepStatus status;
    private Instant startedAt;
    private Instant completedAt;
    private Throwable failureCause;

    public enum YSagaStepStatus {
        PENDING, RUNNING, COMPLETED, COMPENSATED, FAILED, COMPENSATING
    }

    public YSagaStep(String stepId, String stepName, YTask forwardAction,
                     YTask compensatingAction, boolean compensatable,
                     int retryLimit, Duration timeout) {
        this.stepId = stepId;
        this.stepName = stepName;
        this.forwardAction = forwardAction;
        this.compensatingAction = compensatingAction;
        this.compensatable = compensatable;
        this.retryLimit = retryLimit;
        this.timeout = timeout;
        this.status = YSagaStepStatus.PENDING;
    }

    // Getters and setters
    public String getStepId() { return stepId; }
    public String getStepName() { return stepName; }
    public YTask getForwardAction() { return forwardAction; }
    public YTask getCompensatingAction() { return compensatingAction; }
    public boolean isCompensatable() { return compensatable; }
    public int getRetryLimit() { return retryLimit; }
    public Duration getTimeout() { return timeout; }
    public YSagaStepStatus getStatus() { return status; }
    public void setStatus(YSagaStepStatus status) { this.status = status; }
    public Throwable getFailureCause() { return failureCause; }
    public void setFailureCause(Throwable cause) { this.failureCause = cause; }
}

/**
 * Tracks the execution state of a saga.
 */
public class YSagaState {
    private final String sagaId;
    private YSagaStatus status;
    private int currentStep;
    private final List<YSagaStep> steps;
    private final Set<Integer> completedSteps;
    private Integer failedStep;
    private final Map<String, Object> context;

    public enum YSagaStatus {
        RUNNING, COMPENSATING, COMPLETED, FAILED, COMPENSATED
    }

    public YSagaState(String sagaId, List<YSagaStep> steps) {
        this.sagaId = sagaId;
        this.steps = steps;
        this.status = YSagaStatus.RUNNING;
        this.currentStep = 0;
        this.completedSteps = new LinkedHashSet<>();
        this.context = new HashMap<>();
    }

    public String getSagaId() { return sagaId; }
    public YSagaStatus getStatus() { return status; }
    public void setStatus(YSagaStatus status) { this.status = status; }
    public int getCurrentStep() { return currentStep; }
    public void setCurrentStep(int step) { this.currentStep = step; }
    public List<YSagaStep> getSteps() { return Collections.unmodifiableList(steps); }
    public Set<Integer> getCompletedSteps() { return Collections.unmodifiableSet(completedSteps); }
    public void markCompleted(int stepIndex) { completedSteps.add(stepIndex); }
    public Integer getFailedStep() { return failedStep; }
    public void setFailedStep(Integer step) { this.failedStep = step; }
    public Map<String, Object> getContext() { return context; }
}

/**
 * Saga Orchestration Task - Implements WCP-44 pattern.
 *
 * Use Cases:
 * - Order processing with inventory, payment, and shipping services
 * - Multi-service transaction coordination
 * - Long-running business processes with rollback support
 */
public class YSagaOrchestrationTask extends YTask {

    private final List<YSagaStep> sagaSteps;
    private final Duration globalTimeout;
    private final boolean continueOnCompensationFailure;
    private final ExecutorService executor;

    // State tracking
    private final Map<String, YSagaState> activeSagas;
    private final int maxConcurrentSagas;

    public YSagaOrchestrationTask(String taskId, String taskName, YNet parentNet) {
        super(taskId, taskName, parentNet);
        this.sagaSteps = new ArrayList<>();
        this.globalTimeout = Duration.ofMinutes(30);
        this.continueOnCompensationFailure = false;
        this.executor = Executors.newFixedThreadPool(10);
        this.activeSagas = new ConcurrentHashMap<>();
        this.maxConcurrentSagas = 100;
    }

    /**
     * Add a step to the saga.
     *
     * @param stepId Unique identifier for the step
     * @param stepName Human-readable name
     * @param forwardAction The forward transaction task
     * @param compensatingAction The compensating transaction task (null if not compensatable)
     * @param compensatable Whether this step can be compensated
     * @param retryLimit Maximum retry attempts
     * @param timeout Step-level timeout
     */
    public void addStep(String stepId, String stepName, YTask forwardAction,
                       YTask compensatingAction, boolean compensatable,
                       int retryLimit, Duration timeout) {
        sagaSteps.add(new YSagaStep(stepId, stepName, forwardAction,
                                   compensatingAction, compensatable,
                                   retryLimit, timeout));
    }

    {% for step in steps %}
    /**
     * Step {{ loop.index }}: {{ step.stepName }}
     * {% if step.isCompensatable %}Compensatable: Yes{% else %}Compensatable: No{% endif %}
     * Timeout: {{ step.timeout | default(value="PT30S") }}
     * Retry Limit: {{ step.retryLimit | default(value=3) }}
     */
    public YSagaStep createStep{{ loop.index }}(YNet net) {
        YTask forwardAction = net.getTask("{{ step.forwardActionId }}");
        YTask compensateAction = {% if step.compensatingActionId %}net.getTask("{{ step.compensatingActionId }}"){% else %}null{% endif %};
        return new YSagaStep(
            "{{ step.stepId }}",
            "{{ step.stepName }}",
            forwardAction,
            compensateAction,
            {{ step.isCompensatable | default(value=true) }},
            {{ step.retryLimit | default(value=3) }},
            Duration.parse("{{ step.timeout | default(value="PT30S") }}")
        );
    }
    {% endfor %}

    /**
     * Execute the saga orchestration.
     *
     * @param caseId The case identifier
     * @param initialContext Initial context data for the saga
     * @return YSagaState containing execution results
     * @throws YSagaException if saga fails
     */
    public YSagaState execute(String caseId, Map<String, Object> initialContext)
            throws YSagaException {

        if (activeSagas.size() >= maxConcurrentSagas) {
            throw new YSagaException("Maximum concurrent sagas exceeded: " + maxConcurrentSagas);
        }

        YSagaState state = new YSagaState(caseId, new ArrayList<>(sagaSteps));
        if (initialContext != null) {
            state.getContext().putAll(initialContext);
        }
        activeSagas.put(caseId, state);

        try {
            // Execute forward transactions
            for (int i = 0; i < sagaSteps.size(); i++) {
                YSagaStep step = sagaSteps.get(i);
                state.setCurrentStep(i);

                try {
                    executeStep(step, state);
                    state.markCompleted(i);
                    step.setStatus(YSagaStep.YSagaStepStatus.COMPLETED);

                } catch (Exception e) {
                    step.setStatus(YSagaStep.YSagaStepStatus.FAILED);
                    step.setFailureCause(e);
                    state.setFailedStep(i);

                    // Start compensation
                    compensate(state, i);
                    throw new YSagaException("Saga failed at step " + step.getStepName(), e);
                }
            }

            state.setStatus(YSagaState.YSagaStatus.COMPLETED);
            return state;

        } finally {
            activeSagas.remove(caseId);
        }
    }

    /**
     * Execute a single saga step with retry logic.
     */
    private void executeStep(YSagaStep step, YSagaState state) throws Exception {
        step.setStatus(YSagaStep.YSagaStepStatus.RUNNING);

        int attempts = 0;
        Exception lastException = null;

        while (attempts <= step.getRetryLimit()) {
            try {
                CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                    try {
                        step.getForwardAction().execute();
                    } catch (Exception e) {
                        throw new CompletionException(e);
                    }
                }, executor);

                future.get(step.getTimeout().toMillis(), TimeUnit.MILLISECONDS);
                return; // Success

            } catch (TimeoutException e) {
                lastException = new YSagaException("Step timeout: " + step.getStepName());
                attempts++;
            } catch (ExecutionException e) {
                lastException = (Exception) e.getCause();
                attempts++;
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                throw new YSagaException("Saga interrupted", e);
            }

            if (attempts <= step.getRetryLimit()) {
                // Exponential backoff before retry
                long backoffMs = (long) (100 * Math.pow(2, attempts - 1));
                Thread.sleep(Math.min(backoffMs, 10000));
            }
        }

        throw lastException != null ? lastException :
            new YSagaException("Step failed after " + attempts + " attempts");
    }

    /**
     * Compensate completed steps in reverse order.
     *
     * @param state The saga state
     * @param failedAtIndex Index of the failed step
     */
    private void compensate(YSagaState state, int failedAtIndex) {
        state.setStatus(YSagaState.YSagaStatus.COMPENSATING);

        // Get completed steps in reverse order
        List<Integer> toCompensate = new ArrayList<>(state.getCompletedSteps());
        Collections.sort(toCompensate, Collections.reverseOrder());

        for (Integer stepIndex : toCompensate) {
            YSagaStep step = state.getSteps().get(stepIndex);

            if (!step.isCompensatable() || step.getCompensatingAction() == null) {
                continue;
            }

            try {
                step.setStatus(YSagaStep.YSagaStepStatus.COMPENSATING);
                step.getCompensatingAction().execute();
                step.setStatus(YSagaStep.YSagaStepStatus.COMPENSATED);

            } catch (Exception e) {
                // Log compensation failure
                logger.error("Compensation failed for step {}: {}",
                           step.getStepName(), e.getMessage());

                if (!continueOnCompensationFailure) {
                    state.setStatus(YSagaState.YSagaStatus.FAILED);
                    return;
                }
            }
        }

        state.setStatus(YSagaState.YSagaStatus.COMPENSATED);
    }

    /**
     * Get active saga count.
     */
    public int getActiveSagaCount() {
        return activeSagas.size();
    }

    /**
     * Get saga state by case ID.
     */
    public Optional<YSagaState> getSagaState(String caseId) {
        return Optional.ofNullable(activeSagas.get(caseId));
    }

    @Override
    public void dispose() {
        executor.shutdown();
        try {
            if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
        super.dispose();
    }
}
