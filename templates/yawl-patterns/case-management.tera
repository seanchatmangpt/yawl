{#
  Template: YCaseManagementTask.java
  Pattern: WCP-68 - Case Management
  Description: Manages a case with dynamic activities that can be added at runtime
#}
/**
 * YCaseManagementTask - WCP-68 Case Management Pattern
 *
 * Manages a case with dynamic activities that can be added, removed, or reordered
 * at runtime based on case state and context.
 *
 * Formalism:
 *   Case = {
 *     state: CaseState,
 *     activities: Set[Activity],
 *     milestones: Set[Milestone],
 *     stage: Stage,
 *     addActivity(a) if stage.allows(a),
 *     completeMilestone(m) if m.preconditionsMet()
 *   }
 *
 * @generated by ggen from ontology
 * @pattern WCP-68
 */

package org.yawlfoundation.yawl.patterns.extended;

import org.yawlfoundation.yawl.elements.YTask;
import org.yawlfoundation.yawl.elements.YNet;
import org.yawlfoundation.yawl.exceptions.YCaseException;

import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.*;

/**
 * Case state enumeration.
 */
public enum YCaseState {
    CREATED,
    ACTIVE,
    SUSPENDED,
    COMPLETED,
    TERMINATED,
    ARCHIVED
}

/**
 * Case stage definition.
 */
public class YCaseStage {
    private final String stageName;
    private final List<String> allowedActivities;
    private final String entryCondition;
    private final String exitCondition;
    private final boolean autoComplete;
    private final int order;

    public YCaseStage(String stageName, List<String> allowedActivities,
                      String entryCondition, String exitCondition,
                      boolean autoComplete, int order) {
        this.stageName = stageName;
        this.allowedActivities = new ArrayList<>(allowedActivities);
        this.entryCondition = entryCondition;
        this.exitCondition = exitCondition;
        this.autoComplete = autoComplete;
        this.order = order;
    }

    // Getters
    public String getStageName() { return stageName; }
    public List<String> getAllowedActivities() { return Collections.unmodifiableList(allowedActivities); }
    public String getEntryCondition() { return entryCondition; }
    public String getExitCondition() { return exitCondition; }
    public boolean isAutoComplete() { return autoComplete; }
    public int getOrder() { return order; }

    public boolean allowsActivity(String activityId) {
        return allowedActivities.contains(activityId);
    }
}

/**
 * Case milestone definition.
 */
public class YCaseMilestone {
    private final String milestoneName;
    private final String achievementCondition;
    private final boolean required;
    private final YTask onAchieveTask;
    private volatile boolean achieved;
    private Instant achievedAt;

    public YCaseMilestone(String milestoneName, String achievementCondition,
                          boolean required, YTask onAchieveTask) {
        this.milestoneName = milestoneName;
        this.achievementCondition = achievementCondition;
        this.required = required;
        this.onAchieveTask = onAchieveTask;
        this.achieved = false;
    }

    // Getters
    public String getMilestoneName() { return milestoneName; }
    public String getAchievementCondition() { return achievementCondition; }
    public boolean isRequired() { return required; }
    public YTask getOnAchieveTask() { return onAchieveTask; }
    public boolean isAchieved() { return achieved; }
    public Instant getAchievedAt() { return achievedAt; }

    public void setAchieved(boolean achieved) {
        this.achieved = achieved;
        if (achieved && achievedAt == null) {
            achievedAt = Instant.now();
        }
    }
}

/**
 * Case activity with execution tracking.
 */
public class YCaseActivity {
    private final String activityId;
    private final String activityName;
    private final YTask task;
    private final int minExecutions;
    private final int maxExecutions;
    private final String orderingConstraint;
    private volatile int executionCount;
    private volatile boolean completed;
    private final List<Instant> executionTimestamps;

    public YCaseActivity(String activityId, String activityName, YTask task,
                         int minExecutions, int maxExecutions, String orderingConstraint) {
        this.activityId = activityId;
        this.activityName = activityName;
        this.task = task;
        this.minExecutions = minExecutions;
        this.maxExecutions = maxExecutions;
        this.orderingConstraint = orderingConstraint;
        this.executionCount = 0;
        this.completed = false;
        this.executionTimestamps = new ArrayList<>();
    }

    // Getters
    public String getActivityId() { return activityId; }
    public String getActivityName() { return activityName; }
    public YTask getTask() { return task; }
    public int getMinExecutions() { return minExecutions; }
    public int getMaxExecutions() { return maxExecutions; }
    public String getOrderingConstraint() { return orderingConstraint; }
    public int getExecutionCount() { return executionCount; }
    public boolean isCompleted() { return completed; }
    public List<Instant> getExecutionTimestamps() { return Collections.unmodifiableList(executionTimestamps); }

    public boolean canExecute() {
        return !completed && (maxExecutions < 0 || executionCount < maxExecutions);
    }

    public boolean isMandatorySatisfied() {
        return executionCount >= minExecutions;
    }

    public void recordExecution() {
        executionCount++;
        executionTimestamps.add(Instant.now());
        if (maxExecutions > 0 && executionCount >= maxExecutions) {
            completed = true;
        }
    }

    public void markCompleted() {
        this.completed = true;
    }
}

/**
 * Case instance.
 */
public class YCaseInstance {
    private final String caseId;
    private final String caseType;
    private YCaseState state;
    private YCaseStage currentStage;
    private final List<YCaseStage> stages;
    private final Map<String, YCaseActivity> activities;
    private final Map<String, YCaseMilestone> milestones;
    private final Map<String, Object> caseData;
    private final List<String> history;
    private final Instant createdAt;
    private Instant completedAt;

    public YCaseInstance(String caseId, String caseType, List<YCaseStage> stages) {
        this.caseId = caseId;
        this.caseType = caseType;
        this.state = YCaseState.CREATED;
        this.stages = new ArrayList<>(stages);
        this.stages.sort(Comparator.comparingInt(YCaseStage::getOrder));
        this.activities = new LinkedHashMap<>();
        this.milestones = new LinkedHashMap<>();
        this.caseData = new ConcurrentHashMap<>();
        this.history = new ArrayList<>();
        this.createdAt = Instant.now();

        if (!this.stages.isEmpty()) {
            this.currentStage = this.stages.get(0);
        }
    }

    // Getters
    public String getCaseId() { return caseId; }
    public String getCaseType() { return caseType; }
    public YCaseState getState() { return state; }
    public YCaseStage getCurrentStage() { return currentStage; }
    public List<YCaseStage> getStages() { return Collections.unmodifiableList(stages); }
    public Map<String, YCaseActivity> getActivities() { return Collections.unmodifiableMap(activities); }
    public Map<String, YCaseMilestone> getMilestones() { return Collections.unmodifiableMap(milestones); }
    public Map<String, Object> getCaseData() { return caseData; }
    public List<String> getHistory() { return Collections.unmodifiableList(history); }
    public Instant getCreatedAt() { return createdAt; }
    public Instant getCompletedAt() { return completedAt; }

    public void setState(YCaseState state) {
        this.state = state;
        recordHistory("State changed to " + state);
    }

    public void addActivity(YCaseActivity activity) {
        if (currentStage == null || currentStage.allowsActivity(activity.getActivityId())) {
            activities.put(activity.getActivityId(), activity);
            recordHistory("Activity added: " + activity.getActivityName());
        } else {
            throw new IllegalStateException("Activity not allowed in current stage: " + currentStage.getStageName());
        }
    }

    public void addMilestone(YCaseMilestone milestone) {
        milestones.put(milestone.getMilestoneName(), milestone);
        recordHistory("Milestone defined: " + milestone.getMilestoneName());
    }

    public void setCaseData(String key, Object value) {
        caseData.put(key, value);
    }

    public void recordHistory(String entry) {
        history.add(Instant.now() + ": " + entry);
    }

    public void complete() {
        this.state = YCaseState.COMPLETED;
        this.completedAt = Instant.now();
        recordHistory("Case completed");
    }
}

/**
 * Case Management Task - Implements WCP-68 pattern.
 *
 * Use Cases:
 * - Legal case management
 * - Insurance claims processing
 * - Customer onboarding workflows
 * - Adaptive process management
 */
public class YCaseManagementTask extends YTask {

    private final String caseType;
    private final List<YCaseStage> stages;
    private final Map<String, YCaseInstance> activeCases;
    private final ExecutorService executor;

    // Metrics
    private final AtomicInteger totalCasesCreated = new AtomicInteger(0);
    private final AtomicInteger totalCasesCompleted = new AtomicInteger(0);
    private final AtomicInteger totalCasesTerminated = new AtomicInteger(0);

    public YCaseManagementTask(String taskId, String taskName, YNet parentNet,
                               String caseType, List<YCaseStage> stages) {
        super(taskId, taskName, parentNet);
        this.caseType = caseType;
        this.stages = new ArrayList<>(stages);
        this.activeCases = new ConcurrentHashMap<>();
        this.executor = Executors.newCachedThreadPool();
    }

    {% for stage in stages %}
    /**
     * Stage {{ loop.index }}: {{ stage.stageName }}
     * Allowed Activities: {{ stage.allowedActivities | join(", ") }}
     * Auto-complete: {{ stage.autoComplete | default(value=false) }}
     */
    public YCaseStage createStage{{ loop.index }}() {
        return new YCaseStage(
            "{{ stage.stageName }}",
            Arrays.asList({% for act in stage.allowedActivities %}"{{ act }}"{% if not loop.last %}, {% endif %}{% endfor %}),
            "{{ stage.entryCondition | default(value="true") }}",
            "{{ stage.exitCondition | default(value="false") }}",
            {{ stage.autoComplete | default(value=false) }},
            {{ loop.index }}
        );
    }
    {% endfor %}

    /**
     * Create a new case instance.
     *
     * @param caseId Unique case identifier
     * @param initialData Initial case data
     * @return The created case instance
     */
    public YCaseInstance createCase(String caseId, Map<String, Object> initialData) {
        YCaseInstance caseInstance = new YCaseInstance(caseId, caseType, stages);

        if (initialData != null) {
            initialData.forEach(caseInstance::setCaseData);
        }

        caseInstance.setState(YCaseState.ACTIVE);
        activeCases.put(caseId, caseInstance);
        totalCasesCreated.incrementAndGet();

        return caseInstance;
    }

    /**
     * Get a case instance by ID.
     */
    public Optional<YCaseInstance> getCase(String caseId) {
        return Optional.ofNullable(activeCases.get(caseId));
    }

    /**
     * Add an activity to a case.
     *
     * @param caseId Case to add activity to
     * @param activity Activity to add
     */
    public void addActivity(String caseId, YCaseActivity activity) {
        YCaseInstance caseInstance = activeCases.get(caseId);
        if (caseInstance == null) {
            throw new YCaseException("Case not found: " + caseId);
        }
        caseInstance.addActivity(activity);
    }

    /**
     * Execute an activity in a case.
     *
     * @param caseId Case ID
     * @param activityId Activity to execute
     * @return Activity execution result
     */
    public Object executeActivity(String caseId, String activityId) {
        YCaseInstance caseInstance = activeCases.get(caseId);
        if (caseInstance == null) {
            throw new YCaseException("Case not found: " + caseId);
        }

        if (caseInstance.getState() != YCaseState.ACTIVE) {
            throw new YCaseException("Case is not active: " + caseInstance.getState());
        }

        YCaseActivity activity = caseInstance.getActivities().get(activityId);
        if (activity == null) {
            throw new YCaseException("Activity not found in case: " + activityId);
        }

        if (!activity.canExecute()) {
            throw new YCaseException("Activity cannot be executed: " + activityId);
        }

        try {
            Object result = activity.getTask().execute();
            activity.recordExecution();
            caseInstance.recordHistory("Activity executed: " + activity.getActivityName());

            // Check milestones after activity execution
            checkMilestones(caseInstance);

            // Check stage completion
            checkStageCompletion(caseInstance);

            return result;

        } catch (Exception e) {
            caseInstance.recordHistory("Activity failed: " + activity.getActivityName() + " - " + e.getMessage());
            throw new YCaseException("Activity execution failed", e);
        }
    }

    /**
     * Check and update milestones.
     */
    private void checkMilestones(YCaseInstance caseInstance) {
        for (YCaseMilestone milestone : caseInstance.getMilestones().values()) {
            if (!milestone.isAchieved()) {
                boolean achieved = evaluateCondition(
                    milestone.getAchievementCondition(),
                    caseInstance.getCaseData()
                );
                if (achieved) {
                    milestone.setAchieved(true);
                    caseInstance.recordHistory("Milestone achieved: " + milestone.getMilestoneName());

                    // Execute on-achieve task
                    if (milestone.getOnAchieveTask() != null) {
                        executor.submit(() -> {
                            try {
                                milestone.getOnAchieveTask().execute();
                            } catch (Exception e) {
                                logger.warn("Milestone task failed: {}", e.getMessage());
                            }
                        });
                    }
                }
            }
        }
    }

    /**
     * Check if current stage should complete.
     */
    private void checkStageCompletion(YCaseInstance caseInstance) {
        YCaseStage stage = caseInstance.getCurrentStage();
        if (stage == null) return;

        // Check exit condition
        boolean shouldExit = evaluateCondition(stage.getExitCondition(), caseInstance.getCaseData());

        // Check if all required milestones achieved
        if (!shouldExit) {
            shouldExit = caseInstance.getMilestones().values().stream()
                .filter(YCaseMilestone::isRequired)
                .allMatch(YCaseMilestone::isAchieved);
        }

        // Check if all mandatory activities satisfied
        if (!shouldExit && stage.isAutoComplete()) {
            shouldExit = caseInstance.getActivities().values().stream()
                .allMatch(YCaseActivity::isMandatorySatisfied);
        }

        if (shouldExit) {
            advanceStage(caseInstance);
        }
    }

    /**
     * Advance to the next stage.
     */
    private void advanceStage(YCaseInstance caseInstance) {
        int currentIndex = caseInstance.getStages().indexOf(caseInstance.getCurrentStage());

        if (currentIndex < caseInstance.getStages().size() - 1) {
            YCaseStage nextStage = caseInstance.getStages().get(currentIndex + 1);
            caseInstance.recordHistory("Stage advanced to: " + nextStage.getStageName());
            // Note: In full implementation, would need setter for currentStage

            // Check if this completes the case
            if (currentIndex + 1 == caseInstance.getStages().size() - 1) {
                // Last stage - check for completion
                checkCaseCompletion(caseInstance);
            }
        }
    }

    /**
     * Check if case should complete.
     */
    private void checkCaseCompletion(YCaseInstance caseInstance) {
        // All required milestones must be achieved
        boolean allRequiredMilestones = caseInstance.getMilestones().values().stream()
            .filter(YCaseMilestone::isRequired)
            .allMatch(YCaseMilestone::isAchieved);

        // All mandatory activities must be satisfied
        boolean allMandatoryActivities = caseInstance.getActivities().values().stream()
            .allMatch(YCaseActivity::isMandatorySatisfied);

        if (allRequiredMilestones && allMandatoryActivities) {
            completeCase(caseInstance.getCaseId());
        }
    }

    /**
     * Complete a case.
     */
    public void completeCase(String caseId) {
        YCaseInstance caseInstance = activeCases.get(caseId);
        if (caseInstance == null) return;

        caseInstance.complete();
        totalCasesCompleted.incrementAndGet();
    }

    /**
     * Terminate a case.
     */
    public void terminateCase(String caseId, String reason) {
        YCaseInstance caseInstance = activeCases.get(caseId);
        if (caseInstance == null) return;

        caseInstance.setState(YCaseState.TERMINATED);
        caseInstance.recordHistory("Case terminated: " + reason);
        totalCasesTerminated.incrementAndGet();
    }

    /**
     * Suspend a case.
     */
    public void suspendCase(String caseId) {
        YCaseInstance caseInstance = activeCases.get(caseId);
        if (caseInstance == null) return;

        caseInstance.setState(YCaseState.SUSPENDED);
    }

    /**
     * Resume a suspended case.
     */
    public void resumeCase(String caseId) {
        YCaseInstance caseInstance = activeCases.get(caseId);
        if (caseInstance == null || caseInstance.getState() != YCaseState.SUSPENDED) return;

        caseInstance.setState(YCaseState.ACTIVE);
    }

    /**
     * Simple condition evaluation.
     */
    private boolean evaluateCondition(String condition, Map<String, Object> data) {
        if (condition == null || condition.isEmpty() || "true".equalsIgnoreCase(condition)) {
            return true;
        }
        if ("false".equalsIgnoreCase(condition)) {
            return false;
        }

        // Simple property check
        Object value = data.get(condition);
        if (value instanceof Boolean) {
            return (Boolean) value;
        }
        return value != null;
    }

    /**
     * Get all active cases.
     */
    public Collection<YCaseInstance> getActiveCases() {
        return Collections.unmodifiableCollection(activeCases.values());
    }

    /**
     * Get case metrics.
     */
    public CaseMetrics getMetrics() {
        return new CaseMetrics(
            getTaskId(),
            caseType,
            activeCases.size(),
            totalCasesCreated.get(),
            totalCasesCompleted.get(),
            totalCasesTerminated.get()
        );
    }

    /**
     * Metrics data class.
     */
    public static class CaseMetrics {
        private final String taskId;
        private final String caseType;
        private final int activeCount;
        private final int totalCreated;
        private final int totalCompleted;
        private final int totalTerminated;

        public CaseMetrics(String taskId, String caseType, int activeCount,
                           int totalCreated, int totalCompleted, int totalTerminated) {
            this.taskId = taskId;
            this.caseType = caseType;
            this.activeCount = activeCount;
            this.totalCreated = totalCreated;
            this.totalCompleted = totalCompleted;
            this.totalTerminated = totalTerminated;
        }

        // Getters
        public String getTaskId() { return taskId; }
        public String getCaseType() { return caseType; }
        public int getActiveCount() { return activeCount; }
        public int getTotalCreated() { return totalCreated; }
        public int getTotalCompleted() { return totalCompleted; }
        public int getTotalTerminated() { return totalTerminated; }

        public double getCompletionRate() {
            return totalCreated > 0 ? (double) totalCompleted / totalCreated : 0.0;
        }
    }

    @Override
    public void dispose() {
        executor.shutdown();
        try {
            if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
        super.dispose();
    }
}
