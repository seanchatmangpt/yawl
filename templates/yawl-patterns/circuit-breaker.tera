{#
  Template: YCircuitBreakerTask.java
  Pattern: WCP-47 - Circuit Breaker
  Description: Prevents cascade failures by failing fast when a service is unavailable
#}
/**
 * YCircuitBreakerTask - WCP-47 Circuit Breaker Pattern
 *
 * Prevents cascade failures by failing fast when a service is unavailable.
 * Has three states: Closed (normal), Open (failing), Half-Open (testing).
 *
 * Formalism:
 *   States: CLOSED, OPEN, HALF_OPEN
 *   CLOSED → OPEN: failure_count > threshold
 *   OPEN → HALF_OPEN: after timeout
 *   HALF_OPEN → CLOSED: success
 *   HALF_OPEN → OPEN: failure
 *
 * @generated by ggen from ontology
 * @pattern WCP-47
 */

package org.yawlfoundation.yawl.patterns.extended;

import org.yawlfoundation.yawl.elements.YTask;
import org.yawlfoundation.yawl.elements.YNet;
import org.yawlfoundation.yawl.exceptions.YCircuitBreakerException;

import java.time.Duration;
import java.time.Instant;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Supplier;

/**
 * Circuit Breaker State Machine.
 */
public class YCircuitBreakerState {

    public enum State {
        CLOSED,      // Normal operation - requests flow through
        OPEN,        // Failing - requests are rejected immediately
        HALF_OPEN    // Testing - allowing limited requests to test recovery
    }

    private final String circuitId;
    private final AtomicReference<State> currentState;
    private final AtomicInteger failureCount;
    private final AtomicInteger successCount;
    private final int failureThreshold;
    private final Duration timeout;
    private final int halfOpenMaxCalls;
    private volatile Instant lastFailureTime;

    public YCircuitBreakerState(String circuitId, int failureThreshold,
                                Duration timeout, int halfOpenMaxCalls) {
        this.circuitId = circuitId;
        this.currentState = new AtomicReference<>(State.CLOSED);
        this.failureCount = new AtomicInteger(0);
        this.successCount = new AtomicInteger(0);
        this.failureThreshold = failureThreshold;
        this.timeout = timeout;
        this.halfOpenMaxCalls = halfOpenMaxCalls;
        this.lastFailureTime = null;
    }

    public State getCurrentState() {
        return currentState.get();
    }

    public int getFailureCount() {
        return failureCount.get();
    }

    public int getSuccessCount() {
        return successCount.get();
    }

    public Instant getLastFailureTime() {
        return lastFailureTime;
    }

    /**
     * Record a successful call.
     */
    public void recordSuccess() {
        successCount.incrementAndGet();

        State state = currentState.get();
        if (state == State.HALF_OPEN) {
            // Reset to closed after successful test in half-open
            currentState.compareAndSet(State.HALF_OPEN, State.CLOSED);
            failureCount.set(0);
        }
    }

    /**
     * Record a failed call.
     */
    public void recordFailure() {
        failureCount.incrementAndGet();
        lastFailureTime = Instant.now();

        State state = currentState.get();
        if (state == State.HALF_OPEN) {
            // Immediately open on failure in half-open
            currentState.compareAndSet(State.HALF_OPEN, State.OPEN);
        } else if (state == State.CLOSED && failureCount.get() >= failureThreshold) {
            // Open when threshold exceeded
            currentState.compareAndSet(State.CLOSED, State.OPEN);
        }
    }

    /**
     * Check if a call should be allowed.
     */
    public boolean allowRequest() {
        State state = currentState.get();

        switch (state) {
            case CLOSED:
                return true;

            case OPEN:
                // Check if timeout has elapsed to transition to half-open
                if (lastFailureTime != null &&
                    Duration.between(lastFailureTime, Instant.now()).compareTo(timeout) > 0) {
                    currentState.compareAndSet(State.OPEN, State.HALF_OPEN);
                    successCount.set(0);
                    return true;
                }
                return false;

            case HALF_OPEN:
                // Allow limited requests in half-open state
                return successCount.get() < halfOpenMaxCalls;

            default:
                return false;
        }
    }

    /**
     * Force state transition (for admin/testing).
     */
    public void forceState(State newState) {
        currentState.set(newState);
        if (newState == State.CLOSED) {
            failureCount.set(0);
        }
    }
}

/**
 * Circuit Breaker Task - Implements WCP-47 pattern.
 *
 * Use Cases:
 * - External API calls with automatic fail-fast
 * - Database connection protection
 * - Microservice invocation resilience
 */
public class YCircuitBreakerTask extends YTask {

    private final YCircuitBreakerState circuitState;
    private final Supplier<Object> protectedAction;
    private final Supplier<Object> fallbackAction;
    private final Duration callTimeout;

    // Metrics
    private final AtomicInteger totalCalls = new AtomicInteger(0);
    private final AtomicInteger successfulCalls = new AtomicInteger(0);
    private final AtomicInteger failedCalls = new AtomicInteger(0);
    private final AtomicInteger rejectedCalls = new AtomicInteger(0);

    public YCircuitBreakerTask(String taskId, String taskName, YNet parentNet,
                               int failureThreshold, Duration timeout,
                               int halfOpenMaxCalls, Duration callTimeout) {
        super(taskId, taskName, parentNet);
        this.circuitState = new YCircuitBreakerState(
            taskId + "-circuit", failureThreshold, timeout, halfOpenMaxCalls
        );
        this.protectedAction = null; // Set via setter
        this.fallbackAction = null;  // Optional fallback
        this.callTimeout = callTimeout;
    }

    {% if threshold %}
    /**
     * Configure circuit breaker threshold: {{ threshold }}
     * Timeout: {{ timeout | default(value="PT30S") }}
     */
    {% endif %}
    public static YCircuitBreakerTask create(String taskId, YNet parentNet) {
        return new YCircuitBreakerTask(
            taskId,
            "{{ taskName | default(value="CircuitBreaker") }}",
            parentNet,
            {{ threshold | default(value=5) }},                    // failureThreshold
            Duration.parse("{{ timeout | default(value="PT30S") }}"), // timeout
            {{ halfOpenMaxCalls | default(value=3) }},                // halfOpenMaxCalls
            Duration.parse("{{ callTimeout | default(value="PT10S") }}") // callTimeout
        );
    }

    /**
     * Set the protected action to execute.
     */
    public void setProtectedAction(Supplier<Object> action) {
        this.protectedAction = action;
    }

    /**
     * Set the fallback action when circuit is open.
     */
    public void setFallbackAction(Supplier<Object> action) {
        this.fallbackAction = action;
    }

    /**
     * Execute the circuit breaker protected call.
     *
     * @return Result from protected action or fallback
     * @throws YCircuitBreakerException if circuit is open and no fallback
     */
    public Object execute() throws YCircuitBreakerException {
        totalCalls.incrementAndGet();

        // Check if request should be allowed
        if (!circuitState.allowRequest()) {
            rejectedCalls.incrementAndGet();

            if (fallbackAction != null) {
                return fallbackAction.get();
            }

            throw new YCircuitBreakerException(
                "Circuit breaker is OPEN for " + getTaskId(),
                circuitState.getLastFailureTime()
            );
        }

        // Execute protected action
        try {
            CompletableFuture<Object> future = CompletableFuture.supplyAsync(() -> {
                if (protectedAction == null) {
                    throw new IllegalStateException("No protected action configured");
                }
                return protectedAction.get();
            });

            Object result = future.get(callTimeout.toMillis(), TimeUnit.MILLISECONDS);
            circuitState.recordSuccess();
            successfulCalls.incrementAndGet();
            return result;

        } catch (TimeoutException e) {
            circuitState.recordFailure();
            failedCalls.incrementAndGet();

            if (fallbackAction != null) {
                return fallbackAction.get();
            }
            throw new YCircuitBreakerException("Circuit breaker call timed out", e);

        } catch (ExecutionException e) {
            circuitState.recordFailure();
            failedCalls.incrementAndGet();

            if (fallbackAction != null) {
                return fallbackAction.get();
            }
            throw new YCircuitBreakerException("Circuit breaker call failed", e.getCause());

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new YCircuitBreakerException("Circuit breaker call interrupted", e);
        }
    }

    /**
     * Get current circuit breaker state.
     */
    public YCircuitBreakerState.State getState() {
        return circuitState.getCurrentState();
    }

    /**
     * Get failure count.
     */
    public int getFailureCount() {
        return circuitState.getFailureCount();
    }

    /**
     * Force circuit breaker to a specific state.
     */
    public void forceState(YCircuitBreakerState.State state) {
        circuitState.forceState(state);
    }

    /**
     * Get metrics snapshot.
     */
    public CircuitBreakerMetrics getMetrics() {
        return new CircuitBreakerMetrics(
            getTaskId(),
            circuitState.getCurrentState().name(),
            totalCalls.get(),
            successfulCalls.get(),
            failedCalls.get(),
            rejectedCalls.get(),
            circuitState.getFailureCount(),
            circuitState.getLastFailureTime()
        );
    }

    /**
     * Metrics data class.
     */
    public static class CircuitBreakerMetrics {
        private final String circuitId;
        private final String state;
        private final int totalCalls;
        private final int successfulCalls;
        private final int failedCalls;
        private final int rejectedCalls;
        private final int currentFailureCount;
        private final Instant lastFailureTime;

        public CircuitBreakerMetrics(String circuitId, String state,
                                     int totalCalls, int successfulCalls,
                                     int failedCalls, int rejectedCalls,
                                     int currentFailureCount, Instant lastFailureTime) {
            this.circuitId = circuitId;
            this.state = state;
            this.totalCalls = totalCalls;
            this.successfulCalls = successfulCalls;
            this.failedCalls = failedCalls;
            this.rejectedCalls = rejectedCalls;
            this.currentFailureCount = currentFailureCount;
            this.lastFailureTime = lastFailureTime;
        }

        // Getters
        public String getCircuitId() { return circuitId; }
        public String getState() { return state; }
        public int getTotalCalls() { return totalCalls; }
        public int getSuccessfulCalls() { return successfulCalls; }
        public int getFailedCalls() { return failedCalls; }
        public int getRejectedCalls() { return rejectedCalls; }
        public int getCurrentFailureCount() { return currentFailureCount; }
        public Instant getLastFailureTime() { return lastFailureTime; }

        public double getSuccessRate() {
            if (totalCalls == 0) return 1.0;
            return (double) successfulCalls / totalCalls;
        }
    }
}
