/*
 * Copyright (c) 2004-2025 The YAWL Foundation. All rights reserved.
 * The YAWL Foundation is a collaboration of individuals and
 * organisations who are committed to improving workflow technology.
 *
 * This file is part of YAWL. YAWL is free software: you can
 * redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation.
 *
 * YAWL is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
 * Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with YAWL. If not, see <http://www.gnu.org/licenses/>.
 */

package org.yawlfoundation.yawl.unmarshal;

import static org.junit.jupiter.api.Assertions.*;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Set;

import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.JDOMException;
import org.jdom2.Namespace;
import org.jdom2.input.SAXBuilder;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.yawlfoundation.yawl.elements.YAWLServiceGateway;
import org.yawlfoundation.yawl.elements.YDecomposition;
import org.yawlfoundation.yawl.elements.YNet;
import org.yawlfoundation.yawl.elements.YSpecification;
import org.yawlfoundation.yawl.elements.YTask;
import org.yawlfoundation.yawl.exceptions.YSyntaxException;
import org.yawlfoundation.yawl.schema.YSchemaVersion;
import org.yawlfoundation.yawl.util.StringUtil;

/**
 * Test suite for YSpecificationParser - parses YSpecification objects from XML.
 *
 * <p>This test suite follows Chicago TDD methodology with real XML documents
 * and real parsing operations. No mocks are used.</p>
 *
 * <p>Test coverage includes:</p>
 * <ul>
 *   <li>Parsing valid specifications from XML strings</li>
 *   <li>Handling malformed XML gracefully</li>
 *   <li>Parsing metadata (name, version, author, dates)</li>
 *   <li>Parsing decompositions (nets, gateways)</li>
 *   <li>Parsing data definitions and schemas</li>
 *   <li>Parsing extended attributes</li>
 *   <li>Version handling (Beta2, Beta3, and modern versions)</li>
 * </ul>
 *
 * @author Test Suite Generated by Claude
 * @see YSpecificationParser
 * @see YSpecification
 * @see YMarshal
 */
@DisplayName("YSpecificationParser Tests")
@Tag("unit")
class TestYSpecificationParser {

    private static final String SPEC_RESOURCE_PATH = "/org/yawlfoundation/yawl/unmarshal/";
    private static final Namespace YAWL_NS = Namespace.getNamespace("http://www.citi.qut.edu.au/yawl");

    private String simpleSpecXml;
    private String makeRecordingsXml;

    /**
     * Loads XML test fixtures before each test.
     */
    @BeforeEach
    void setUp() throws IOException {
        simpleSpecXml = loadResource("YAWL_Specification.xml");
        makeRecordingsXml = loadResource("MakeRecordings.xml");
    }

    /**
     * Helper method to load XML test resources from the classpath.
     */
    private String loadResource(String resourceName) throws IOException {
        try (InputStream is = getClass().getResourceAsStream(resourceName)) {
            if (is == null) {
                throw new IOException("Resource not found: " + resourceName);
            }
            return new String(is.readAllBytes(), StandardCharsets.UTF_8);
        }
    }

    /**
     * Parses an XML string into a JDOM Element for testing YSpecificationParser directly.
     */
    private Element parseXmlToElement(String xml) throws JDOMException, IOException {
        SAXBuilder builder = new SAXBuilder();
        Document doc = builder.build(new java.io.StringReader(xml));
        Element root = doc.getRootElement();

        // Get the specification element (first child of specificationSet)
        return root.getChild("specification", root.getNamespace());
    }

    // =========================================================================
    // Test 1: Parse Valid Specification from XML
    // =========================================================================

    @Test
    @DisplayName("Parse valid specification from XML string")
    void parseValidSpecification() throws YSyntaxException, JDOMException, IOException {
        // Parse the XML document and extract specification element
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(simpleSpecXml, false);

        // Verify we got at least one specification
        assertNotNull(specs, "Specification list should not be null");
        assertFalse(specs.isEmpty(), "Specification list should not be empty");

        YSpecification spec = specs.get(0);
        assertNotNull(spec, "Specification should not be null");
        assertNotNull(spec.getRootNet(), "Root net should not be null");
        assertEquals("YAWL_Specification.xml", spec.getURI(), "URI should match specification URI");
    }

    // =========================================================================
    // Test 2: Handle Malformed XML Gracefully
    // =========================================================================

    @Test
    @DisplayName("Handle well-formed XML with missing specification elements - returns empty list")
    void handleWellFormedXmlMissingSpecElements() throws YSyntaxException {
        // Well-formed XML but not a YAWL specification - returns empty list
        String nonSpecXml = "<?xml version=\"1.0\"?><notASpecification/>";

        List<YSpecification> specs = YMarshal.unmarshalSpecifications(nonSpecXml, false);
        // Should return empty list, not throw exception
        assertNotNull(specs, "Should return non-null list");
        assertTrue(specs.isEmpty(), "Should return empty list for non-specification XML");
    }

    @Test
    @DisplayName("Handle completely invalid XML string")
    void handleCompletelyInvalidXml() {
        String invalidXml = "this is not xml at all";

        YSyntaxException exception = assertThrows(YSyntaxException.class, () -> {
            YMarshal.unmarshalSpecifications(invalidXml, false);
        }, "Should throw YSyntaxException for invalid XML");

        assertNotNull(exception.getMessage(), "Exception should have a message");
    }

    @Test
    @DisplayName("Handle empty XML string")
    void handleEmptyXmlString() {
        String emptyXml = "";

        YSyntaxException exception = assertThrows(YSyntaxException.class, () -> {
            YMarshal.unmarshalSpecifications(emptyXml, false);
        }, "Should throw YSyntaxException for empty XML");

        assertNotNull(exception.getMessage(), "Exception should have a message");
    }

    // =========================================================================
    // Test 3: Parse Metadata (name, version, author)
    // =========================================================================

    @Test
    @DisplayName("Parse specification metadata including name and documentation")
    void parseMetadata() throws YSyntaxException, JDOMException, IOException {
        // Use MakeRecordings.xml which has name and documentation
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(makeRecordingsXml, false);
        YSpecification spec = specs.get(0);

        // Verify metadata
        assertEquals("Cut Records", spec.getName(), "Specification name should be 'Cut Records'");
        assertNotNull(spec.getDocumentation(), "Documentation should not be null");
        assertTrue(spec.getDocumentation().contains("record some some songs"),
                   "Documentation should contain expected text");
    }

    @Test
    @DisplayName("Parse specification with empty metadata")
    void parseEmptyMetadata() throws YSyntaxException, JDOMException, IOException {
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(simpleSpecXml, false);
        YSpecification spec = specs.get(0);

        YMetaData metaData = spec.getMetaData();
        assertNotNull(metaData, "Metadata should not be null even if empty in XML");

        // Empty metadata should have default version
        assertNotNull(metaData.getVersion(), "Version should default to initial version");
        assertEquals("0.1", metaData.getVersion().toString(), "Default version should be 0.1");
    }

    @Test
    @DisplayName("Parse specification URI from XML")
    void parseSpecificationUri() throws YSyntaxException, JDOMException, IOException {
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(simpleSpecXml, false);
        YSpecification spec = specs.get(0);

        assertEquals("YAWL_Specification.xml", spec.getURI(),
                     "URI should match specification attribute");
    }

    // =========================================================================
    // Test 4: Parse Decompositions (nets, gateways)
    // =========================================================================

    @Test
    @DisplayName("Parse root net decomposition")
    void parseRootNetDecomposition() throws YSyntaxException, JDOMException, IOException {
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(simpleSpecXml, false);
        YSpecification spec = specs.get(0);

        YNet rootNet = spec.getRootNet();
        assertNotNull(rootNet, "Root net should not be null");
        assertEquals("top", rootNet.getID(), "Root net ID should be 'top'");
        assertNotNull(rootNet.getInputCondition(), "Root net should have input condition");
        assertNotNull(rootNet.getOutputCondition(), "Root net should have output condition");
    }

    @Test
    @DisplayName("Parse multiple decompositions including gateways and sub-nets")
    void parseMultipleDecompositions() throws YSyntaxException, JDOMException, IOException {
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(simpleSpecXml, false);
        YSpecification spec = specs.get(0);

        Set<YDecomposition> decompositions = spec.getDecompositions();
        assertNotNull(decompositions, "Decompositions set should not be null");

        // The simple spec has root net + multiple gateways + sub-nets
        assertTrue(decompositions.size() > 1,
                   "Should have multiple decompositions (found: " + decompositions.size() + ")");

        // Verify we have both nets and gateways
        boolean hasNet = false;
        boolean hasGateway = false;
        for (YDecomposition decomp : decompositions) {
            if (decomp instanceof YNet) {
                hasNet = true;
            }
            if (decomp instanceof YAWLServiceGateway) {
                hasGateway = true;
            }
        }
        assertTrue(hasNet, "Should have at least one YNet decomposition");
        assertTrue(hasGateway, "Should have at least one YAWLServiceGateway decomposition");
    }

    @Test
    @DisplayName("Parse decomposition by ID")
    void parseDecompositionById() throws YSyntaxException, JDOMException, IOException {
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(simpleSpecXml, false);
        YSpecification spec = specs.get(0);

        // Get a specific gateway decomposition
        YDecomposition decompA = spec.getDecomposition("A");
        assertNotNull(decompA, "Decomposition 'A' should exist");
        assertEquals("A", decompA.getID(), "Decomposition ID should match");

        // Get a sub-net decomposition
        YDecomposition leafC = spec.getDecomposition("leaf-c");
        assertNotNull(leafC, "Decomposition 'leaf-c' should exist");
        assertTrue(leafC instanceof YNet, "'leaf-c' should be a YNet");
    }

    // =========================================================================
    // Test 5: Parse Data Definitions (Schema)
    // =========================================================================

    @Test
    @DisplayName("Parse XML schema data definitions")
    void parseDataSchemaDefinitions() throws YSyntaxException, JDOMException, IOException {
        // MakeRecordings.xml has a rich XSD schema
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(makeRecordingsXml, false);
        YSpecification spec = specs.get(0);

        String schema = spec.getDataSchema();
        assertNotNull(schema, "Data schema should not be null");
        assertTrue(schema.contains("xs:schema") || schema.contains("schema"),
                   "Schema should contain schema element");
        assertTrue(schema.contains("SongType") || schema.contains("SonglistType"),
                   "Schema should contain custom type definitions");
    }

    @Test
    @DisplayName("Parse specification with default schema when none provided")
    void parseDefaultSchemaWhenNoneProvided() throws YSyntaxException, JDOMException, IOException {
        // Simple spec has no explicit schema
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(simpleSpecXml, false);
        YSpecification spec = specs.get(0);

        String schema = spec.getDataSchema();
        assertNotNull(schema, "Even without explicit schema, default should be provided");
        assertTrue(schema.contains("xs:schema") || schema.contains("schema"),
                   "Default schema should be valid XSD");
    }

    @Test
    @DisplayName("Data validator is initialized after parsing")
    void dataValidatorInitialized() throws YSyntaxException, JDOMException, IOException {
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(makeRecordingsXml, false);
        YSpecification spec = specs.get(0);

        assertNotNull(spec.getDataValidator(), "Data validator should be initialized");
    }

    // =========================================================================
    // Test 6: Parse Extended Attributes and Task Details
    // =========================================================================

    @Test
    @DisplayName("Parse task with join and split codes")
    void parseTaskJoinSplitCodes() throws YSyntaxException, JDOMException, IOException {
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(simpleSpecXml, false);
        YSpecification spec = specs.get(0);

        YNet rootNet = spec.getRootNet();

        // Find a task with known join/split
        YTask taskA = (YTask) rootNet.getNetElement("a-top");
        assertNotNull(taskA, "Task 'a-top' should exist");

        // Verify join/split codes
        assertEquals(YTask._XOR, taskA.getJoinType(), "Task should have XOR join");
        assertEquals(YTask._OR, taskA.getSplitType(), "Task should have OR split");
    }

    @Test
    @DisplayName("Parse multiple instance task attributes")
    void parseMultipleInstanceTaskAttributes() throws YSyntaxException, JDOMException, IOException {
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(simpleSpecXml, false);
        YSpecification spec = specs.get(0);

        YNet rootNet = spec.getRootNet();

        // Task 'c-top' is a multiple instance task
        YTask taskC = (YTask) rootNet.getNetElement("c-top");
        assertNotNull(taskC, "Task 'c-top' should exist");

        // Verify MI attributes exist
        var miAttrs = taskC.getMultiInstanceAttributes();
        assertNotNull(miAttrs, "Multiple instance attributes should be parsed");
        assertEquals(2, miAttrs.getMinInstances(), "Min instances should be 2");
        assertEquals(7, miAttrs.getMaxInstances(), "Max instances should be 7");
        assertEquals(5, miAttrs.getThreshold(), "Threshold should be 5");
    }

    @Test
    @DisplayName("Parse task decomposition reference")
    void parseTaskDecompositionReference() throws YSyntaxException, JDOMException, IOException {
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(simpleSpecXml, false);
        YSpecification spec = specs.get(0);

        YNet rootNet = spec.getRootNet();

        // Task 'a-top' decomposes to 'A'
        YTask taskA = (YTask) rootNet.getNetElement("a-top");
        assertNotNull(taskA, "Task 'a-top' should exist");

        YDecomposition decomp = taskA.getDecompositionPrototype();
        assertNotNull(decomp, "Task should have decomposition prototype");
        assertEquals("A", decomp.getID(), "Task should decompose to 'A'");
    }

    // =========================================================================
    // Test 7: Version Handling
    // =========================================================================

    @Test
    @DisplayName("Parse Beta 3 version specification")
    void parseBeta3Version() throws YSyntaxException, JDOMException, IOException {
        // MakeRecordings.xml is a Beta 3 specification
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(makeRecordingsXml, false);
        YSpecification spec = specs.get(0);

        YSchemaVersion version = spec.getSchemaVersion();
        assertNotNull(version, "Schema version should not be null");
        assertEquals(YSchemaVersion.Beta3, version, "Version should be Beta 3");
        assertTrue(version.isBetaVersion(), "Beta 3 should be identified as beta version");
        assertFalse(version.isBeta2(), "Beta 3 should not be identified as Beta 2");
    }

    @Test
    @DisplayName("Parse Beta 2 version specification (legacy rootNet element)")
    void parseBeta2Version() throws YSyntaxException, JDOMException, IOException {
        // YAWL_Specification.xml uses rootNet element (Beta 2 style)
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(simpleSpecXml, false);
        YSpecification spec = specs.get(0);

        // Without explicit version attribute, it should default based on structure
        // The spec has rootNet element which is Beta 2 style
        assertNotNull(spec.getRootNet(), "Root net should be parsed regardless of version");
    }

    // =========================================================================
    // Test 8: Net Elements and Flow
    // =========================================================================

    @Test
    @DisplayName("Parse input and output conditions")
    void parseInputOutputConditions() throws YSyntaxException, JDOMException, IOException {
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(simpleSpecXml, false);
        YSpecification spec = specs.get(0);

        YNet rootNet = spec.getRootNet();

        assertNotNull(rootNet.getInputCondition(), "Input condition should exist");
        assertNotNull(rootNet.getOutputCondition(), "Output condition should exist");
        assertEquals("i-top", rootNet.getInputCondition().getID(), "Input condition ID should match");
        assertEquals("o-top", rootNet.getOutputCondition().getID(), "Output condition ID should match");
    }

    @Test
    @DisplayName("Parse net with multiple conditions and tasks")
    void parseNetWithMultipleElements() throws YSyntaxException, JDOMException, IOException {
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(simpleSpecXml, false);
        YSpecification spec = specs.get(0);

        YNet rootNet = spec.getRootNet();

        // Verify we have the expected net elements
        assertNotNull(rootNet.getNetElement("a-top"), "Task 'a-top' should exist");
        assertNotNull(rootNet.getNetElement("b-top"), "Task 'b-top' should exist");
        assertNotNull(rootNet.getNetElement("c-top"), "Task 'c-top' should exist");
        assertNotNull(rootNet.getNetElement("d-top"), "Task 'd-top' should exist");
        assertNotNull(rootNet.getNetElement("c1-top"), "Condition 'c1-top' should exist");
        assertNotNull(rootNet.getNetElement("c2-top"), "Condition 'c2-top' should exist");
    }

    @Test
    @DisplayName("Parse task flows between elements")
    void parseTaskFlows() throws YSyntaxException, JDOMException, IOException {
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(simpleSpecXml, false);
        YSpecification spec = specs.get(0);

        YNet rootNet = spec.getRootNet();

        // Input condition should flow into 'a-top'
        var inputCondition = rootNet.getInputCondition();
        var postset = inputCondition.getPostsetElements();
        assertFalse(postset.isEmpty(), "Input condition should have postset elements");
        assertTrue(postset.stream().anyMatch(e -> e.getID().equals("a-top")),
                   "Input condition should flow to task 'a-top'");

        // Task 'a-top' should flow to multiple elements (OR split)
        YTask taskA = (YTask) rootNet.getNetElement("a-top");
        var taskPostset = taskA.getPostsetElements();
        assertTrue(taskPostset.size() >= 2,
                   "Task 'a-top' should have at least 2 postset elements (OR split)");
    }

    // =========================================================================
    // Test 9: Specification ID Generation
    // =========================================================================

    @Test
    @DisplayName("Generate specification ID from parsed data")
    void generateSpecificationId() throws YSyntaxException, JDOMException, IOException {
        List<YSpecification> specs = YMarshal.unmarshalSpecifications(simpleSpecXml, false);
        YSpecification spec = specs.get(0);

        var specId = spec.getSpecificationID();
        assertNotNull(specId, "Specification ID should not be null");
        assertEquals("YAWL_Specification.xml", specId.getUri(), "Spec ID URI should match");
    }

    // =========================================================================
    // Test 10: Round-Trip Parsing (Marshal -> Unmarshal)
    // =========================================================================

    @Test
    @DisplayName("Round-trip: parse, marshal, and parse again preserves structure")
    void roundTripParsing() throws YSyntaxException, JDOMException, IOException {
        // Original parse
        List<YSpecification> originalSpecs = YMarshal.unmarshalSpecifications(makeRecordingsXml, false);
        YSpecification original = originalSpecs.get(0);

        // Marshal to XML
        String marshalledXml = YMarshal.marshal(original);

        // Parse again
        List<YSpecification> reparsedSpecs = YMarshal.unmarshalSpecifications(marshalledXml, false);
        YSpecification reparsed = reparsedSpecs.get(0);

        // Verify key attributes match
        assertEquals(original.getURI(), reparsed.getURI(), "URI should match after round-trip");
        assertEquals(original.getName(), reparsed.getName(), "Name should match after round-trip");
        assertEquals(original.getRootNet().getID(), reparsed.getRootNet().getID(),
                     "Root net ID should match after round-trip");
    }

    @Test
    @DisplayName("Decomposition count preserved after round-trip")
    void decompositionCountPreservedAfterRoundTrip() throws YSyntaxException, JDOMException, IOException {
        List<YSpecification> originalSpecs = YMarshal.unmarshalSpecifications(simpleSpecXml, false);
        YSpecification original = originalSpecs.get(0);
        int originalCount = original.getDecompositions().size();

        String marshalledXml = YMarshal.marshal(original);
        List<YSpecification> reparsedSpecs = YMarshal.unmarshalSpecifications(marshalledXml, false);
        YSpecification reparsed = reparsedSpecs.get(0);

        assertEquals(originalCount, reparsed.getDecompositions().size(),
                     "Decomposition count should be preserved after round-trip");
    }
}
