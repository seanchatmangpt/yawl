package org.yawlfoundation.yawl.integration.selfplay;

import org.yawlfoundation.yawl.integration.selfplay.model.DesignChallenge;
import org.yawlfoundation.yawl.integration.selfplay.model.DesignProposal;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

/**
 * YAWL v7 Challenge Agent — the CHALLENGE side of self-play.
 *
 * <p>For each proposal generated by {@link V7DesignAgent}, this agent issues a challenge
 * verdict: ACCEPTED, REJECTED, or MODIFIED. The same underlying agent class plays both
 * proposer and challenger roles (AlphaGo-style), forcing honest self-critique.
 *
 * <p><strong>Acceptance criterion</strong>: A proposal is ACCEPTED if its
 * {@code backwardCompatScore} ≥ the current round's acceptance threshold. The threshold
 * starts at 0.80 and decays by 0.05 per round, so more aggressive designs become
 * acceptable as the agent gains confidence in the specification:
 * <ul>
 *   <li>Round 1 threshold: 0.80 — only highly compatible proposals accepted</li>
 *   <li>Round 2 threshold: 0.75 — moderately disruptive proposals accepted</li>
 *   <li>Round 3 threshold: 0.70 — all analysed proposals accepted</li>
 * </ul>
 *
 * <p>The decay models the challenger's growing confidence that contested designs are sound
 * after surviving repeated scrutiny (severity decay = reduced objection strength).
 */
public class V7ChallengeAgent {

    /**
     * Initial acceptance threshold (round 1). Proposals with backwardCompatScore below
     * this value are REJECTED in the first round.
     */
    private static final double INITIAL_THRESHOLD = 0.80;

    /**
     * Per-round decay of the acceptance threshold. Each round, the challenger
     * accepts proposals with lower backward-compat scores.
     */
    private static final double THRESHOLD_DECAY_PER_ROUND = 0.05;

    private final String agentId;

    public V7ChallengeAgent(String agentId) {
        if (agentId == null || agentId.isBlank()) {
            throw new IllegalArgumentException("agentId is required");
        }
        this.agentId = agentId;
    }

    public String getAgentId() {
        return agentId;
    }

    /**
     * Issue challenge verdicts for a list of proposals in the given round.
     *
     * <p>Each proposal receives exactly one challenge. The verdict is:
     * <ul>
     *   <li>ACCEPTED — backwardCompatScore ≥ acceptance threshold for this round</li>
     *   <li>REJECTED — backwardCompatScore &lt; acceptance threshold (will be re-proposed)</li>
     * </ul>
     *
     * @param proposals proposals generated by the design agent this round
     * @param round the current self-play round (1-indexed)
     * @return one challenge per proposal
     */
    public List<DesignChallenge> challenge(List<DesignProposal> proposals, int round) {
        if (round < 1) {
            throw new IllegalArgumentException("round must be >= 1, got: " + round);
        }

        double acceptanceThreshold = INITIAL_THRESHOLD - (round - 1) * THRESHOLD_DECAY_PER_ROUND;
        // Clamp to [0.0, 1.0]
        acceptanceThreshold = Math.max(0.0, Math.min(1.0, acceptanceThreshold));

        double severity = computeSeverity(round);

        List<DesignChallenge> challenges = new ArrayList<>();

        for (DesignProposal proposal : proposals) {
            boolean accept = proposal.backwardCompatScore() >= acceptanceThreshold;
            String verdict = accept ? DesignChallenge.ACCEPTED : DesignChallenge.REJECTED;

            String objection = accept
                ? ""
                : buildRejectionObjection(proposal, acceptanceThreshold, round);

            String challengeId = "CHG-" + proposal.gap().name() + "-r" + round + "-" + agentId;

            challenges.add(new DesignChallenge(
                challengeId,
                proposal.proposalId(),
                proposal.gap(),
                verdict,
                objection,
                accept ? 0.0 : severity,
                round,
                Instant.now()
            ));
        }

        return challenges;
    }

    /**
     * Severity of rejection objections decays as the challenger gains confidence in designs.
     * severity = max(0.05, 1.0 - (round - 1) * 0.25)
     */
    private static double computeSeverity(int round) {
        double severity = 1.0 - (round - 1) * 0.25;
        return Math.max(0.05, severity);
    }

    private static String buildRejectionObjection(
        DesignProposal proposal, double threshold, int round
    ) {
        return String.format(
            "[Round %d] Rejected: backwardCompatScore %.2f < required threshold %.2f. " +
            "Gap '%s' proposal needs stronger migration path documentation and a " +
            "deprecated-but-supported bridge API before it can be accepted.",
            round, proposal.backwardCompatScore(), threshold, proposal.gap().name()
        );
    }
}
