# JUnit Platform parallel execution configuration.
#
# Part 4 Optimization (Phase 3): Virtual Thread Optimized Configuration for YAWL v6.0.0
#
# Architecture:
# - Default factor: 4.0 (aggressive virtual threads, suitable for I/O-bound tests)
# - Surefire overrides this via configurationParameters (see pom.xml)
# - Unit tests (@Tag("unit")): factor=1.5 (conservative, unit-only)
# - Integration tests (with DB): factor=2.0 (balanced, safer for state isolation)
# - Stress tests: factor=1.0 (minimal parallelism for fairness)
#
# Key JVM flags for virtual thread optimization:
# - -XX:+UseZGC: Low-latency GC for virtual thread pooling
# - -XX:+UseStringDeduplication: Reduces memory footprint of generated code
# - -Djdk.virtualThreadScheduler.parallelism=<cores>: Explicit scheduler config
#
# Why virtual threads: Java 21+ virtual threads are lightweight (~1KB vs ~1MB platform threads)
# and can scale to thousands of concurrent tasks. Ideal for I/O-bound tests
# (H2 database setup, XML parsing, network calls) common in YAWL's workflow engine.
#
# Why JUnit Platform parallel=true: JUnit 5 parallel execution is independent of
# Maven Surefire's legacy parallel mode. This file is the authoritative source for
# how tests execute within forked JVMs.
#
# Dynamic factor tuning:
# - 4.0: Aggressive, virtual threads 4x CPU cores (suitable for pure I/O tests)
# - 2.0: Balanced, virtual threads 2x CPU cores (suitable for mixed I/O+computation)
# - 1.5: Conservative, virtual threads 1.5x CPU cores (safe for stateful tests)
# - 1.0: Sequential, no parallelism (only for stress/breaking-point tests)

junit.jupiter.execution.parallel.enabled=true
junit.jupiter.execution.parallel.mode.default=concurrent
junit.jupiter.execution.parallel.mode.classes.default=concurrent
junit.jupiter.execution.parallel.config.strategy=dynamic

# Virtual thread optimized: 4x factor, 512 max pool (default for high parallelism)
# Overridden per test phase in pom.xml via Surefire configurationParameters
junit.jupiter.execution.parallel.config.dynamic.factor=4.0
junit.jupiter.execution.parallel.config.dynamic.max-pool-size=512

# Test sharding for CI parallelization
# Designed for 8-shard GitHub Actions matrix (8x workers, 1 shard per worker)
yawl.test.shard.count=8
yawl.test.shard.index=${yawl.test.shard.index:0}

# Virtual thread pinning detection (Phase 3 monitoring)
# When a virtual thread is pinned to a carrier thread (platform thread), it cannot
# be paused, reducing the scheduler's ability to handle other virtual threads.
# Pinning typically occurs when holding locks or making blocking JNI calls.
#
# Detection modes:
#   'full'   : Detailed stack trace of pinning event (verbose, for diagnosis)
#   'short'  : Brief warning message (quiet, for CI)
#   'false'  : Disable detection (fastest, for stress testing)
yawl.test.virtual.pinning.detection=short

# Timeout enforcement: prevent runaway tests from blocking the entire suite
#
# Default timeouts (Phase 3 baseline):
#   - Method-level (default): 90 seconds
#     Covers: unit tests, lightweight integration tests, typical workflow operations
#   - Testable method (explicit @Timeout): 180 seconds
#     Covers: stateful tests with setup/teardown, database initialization
#   - Lifecycle method (@BeforeAll/@AfterAll): 180 seconds
#     Covers: expensive one-time setup (H2 schema creation, engine initialization)
#
# Override via profile or system property:
#   mvn test -Djunit.jupiter.execution.timeout.default="120 s"
#   mvn -P integration-parallel test  # Uses profile-specific timeouts
#
junit.jupiter.execution.timeout.default=90 s
junit.jupiter.execution.timeout.testable.method.default=180 s
junit.jupiter.execution.timeout.lifecycle.method.default=180 s

# Thread pool naming for observability (Phase 3 enhancement)
# Helps identify which test or fork is consuming resources via thread dumps
junit.jupiter.execution.parallel.config.fixed.parallelism=${junit.jupiter.execution.parallel.config.dynamic.factor}
