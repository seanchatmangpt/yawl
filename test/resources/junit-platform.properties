# JUnit Platform parallel execution configuration.
#
# Part 4 Optimization (Phase 3): Virtual Thread Optimized Configuration for YAWL v6.0.0
#
# Architecture:
# - Default factor: 4.0 (aggressive virtual threads, suitable for I/O-bound tests)
# - Surefire overrides this via configurationParameters (see pom.xml)
# - Unit tests (@Tag("unit")): factor=1.5 (conservative, unit-only)
# - Integration tests (with DB): factor=2.0 (balanced, safer for state isolation)
# - Stress tests: factor=1.0 (minimal parallelism for fairness)
#
# Key JVM flags for virtual thread optimization:
# - -XX:+UseZGC: Low-latency GC for virtual thread pooling
# - -XX:+UseStringDeduplication: Reduces memory footprint of generated code
# - -Djdk.virtualThreadScheduler.parallelism=<cores>: Explicit scheduler config
#
# Why virtual threads: Java 21+ virtual threads are lightweight (~1KB vs ~1MB platform threads)
# and can scale to thousands of concurrent tasks. Ideal for I/O-bound tests
# (H2 database setup, XML parsing, network calls) common in YAWL's workflow engine.
#
# Why JUnit Platform parallel=true: JUnit 5 parallel execution is independent of
# Maven Surefire's legacy parallel mode. This file is the authoritative source for
# how tests execute within forked JVMs.
#
# Dynamic factor tuning:
# - 4.0: Aggressive, virtual threads 4x CPU cores (suitable for pure I/O tests)
# - 2.0: Balanced, virtual threads 2x CPU cores (suitable for mixed I/O+computation)
# - 1.5: Conservative, virtual threads 1.5x CPU cores (safe for stateful tests)
# - 1.0: Sequential, no parallelism (only for stress/breaking-point tests)

junit.jupiter.execution.parallel.enabled=true
junit.jupiter.execution.parallel.mode.default=concurrent
junit.jupiter.execution.parallel.mode.classes.default=concurrent
junit.jupiter.execution.parallel.config.strategy=dynamic

# Virtual thread optimized: 4x factor, 512 max pool (default for high parallelism)
# Overridden per test phase in pom.xml via Surefire configurationParameters
junit.jupiter.execution.parallel.config.dynamic.factor=4.0
junit.jupiter.execution.parallel.config.dynamic.max-pool-size=512

# Test sharding for CI parallelization
# Designed for 8-shard GitHub Actions matrix (8x workers, 1 shard per worker)
yawl.test.shard.count=8
yawl.test.shard.index=${yawl.test.shard.index:0}

# Virtual thread pinning detection (Phase 3 monitoring)
# When a virtual thread is pinned to a carrier thread (platform thread), it cannot
# be paused, reducing the scheduler's ability to handle other virtual threads.
# Pinning typically occurs when holding locks or making blocking JNI calls.
#
# Detection modes:
#   'full'   : Detailed stack trace of pinning event (verbose, for diagnosis)
#   'short'  : Brief warning message (quiet, for CI)
#   'false'  : Disable detection (fastest, for stress testing)
yawl.test.virtual.pinning.detection=short

# Timeout enforcement: prevent runaway tests from blocking the entire suite
#
# Default timeouts (Phase 3 baseline):
#   - Method-level (default): 90 seconds
#     Covers: unit tests, lightweight integration tests, typical workflow operations
#   - Testable method (explicit @Timeout): 180 seconds
#     Covers: stateful tests with setup/teardown, database initialization
#   - Lifecycle method (@BeforeAll/@AfterAll): 180 seconds
#     Covers: expensive one-time setup (H2 schema creation, engine initialization)
#
# Override via profile or system property:
#   mvn test -Djunit.jupiter.execution.timeout.default="120 s"
#   mvn -P integration-parallel test  # Uses profile-specific timeouts
#
junit.jupiter.execution.timeout.default=90 s
junit.jupiter.execution.timeout.testable.method.default=180 s
junit.jupiter.execution.timeout.lifecycle.method.default=180 s

# Thread pool naming for observability (Phase 3 enhancement)
# Helps identify which test or fork is consuming resources via thread dumps
junit.jupiter.execution.parallel.config.fixed.parallelism=${junit.jupiter.execution.parallel.config.dynamic.factor}

# Test clustering and sharding (Phase 4 optimization)
# Cluster-specific timeout configuration:
#   - Fast tests (<100ms):       30s timeout (1000x margin)
#   - Medium tests (100ms-5s):   60s timeout (100x-600x margin)
#   - Slow tests (5s-30s):       120s timeout (4-24x margin)
#   - Heavy tests (>30s):        180s timeout (baseline)
#
# Implementation notes:
#   - Use @Timeout(value = 30, unit = TimeUnit.SECONDS) for fast tests
#   - Use @Timeout(value = 60, unit = TimeUnit.SECONDS) for medium tests
#   - Use @Timeout(value = 120, unit = TimeUnit.SECONDS) for slow tests
#   - Use @Timeout(value = 180, unit = TimeUnit.SECONDS) for heavy/stress tests
#   - Untagged tests default to 90s (junit.jupiter.execution.timeout.default)
#

# Cluster-specific timeout overrides (per execution context)
# Fast cluster (<100ms): 30 second timeout for quick tests
yawl.test.cluster.fast.timeout=30 s

# Medium cluster (100ms-5s): 60 second timeout for typical integration tests
yawl.test.cluster.medium.timeout=60 s

# Slow cluster (5s-30s): 120 second timeout for complex workflow operations
yawl.test.cluster.slow.timeout=120 s

# Heavy cluster (>30s): 180 second timeout for stress/performance tests
yawl.test.cluster.heavy.timeout=180 s

# ============================================================================
# Stateless Test Execution (STE) Configuration (Phase 5)
# ============================================================================
# Enables per-test H2 database snapshots for 100% test isolation.
#
# Problem: Tests share state via thread-local isolation (couples tests)
# Solution: Per-test H2 snapshots for complete isolation
# Mechanism:
#   1. Before test: snapshot H2 schema
#   2. Run test in isolation
#   3. After test: restore schema snapshot
#
# Overhead: +5-10% time per test for snapshot/restore
# Benefit: Tests run in any order, parallel without conflicts
#
# Enable via:
#   mvn -P stateless test                          # Use stateless profile
#   mvn test -Dyawl.stateless.enabled=true         # System property
#
# Configuration:
yawl.stateless.enabled=${yawl.stateless.enabled:false}
yawl.stateless.verbose=${yawl.stateless.verbose:false}
yawl.stateless.snapshot.timeout.ms=5000
yawl.stateless.snapshot.dir=/tmp/h2-snapshots
yawl.stateless.cleanup.interval.min=60

# Verification tests for STE:
#   Test 1: Run same test 100 times in parallel → all pass
#   Test 2: Run tests in random order → all pass (proves isolation)
#   Test 3: Modify test to depend on state → fails (proves isolation works)
#
# Success criteria:
#   - All tests pass regardless of execution order
#   - Parallel test time < sequential time × 1.5 (accounting for snapshot overhead)
#   - No state leakage between tests
