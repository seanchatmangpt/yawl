/*
 * Copyright (c) 2004-2026 The YAWL Foundation. All rights reserved.
 * The YAWL Foundation is a collaboration of individuals and
 * organisations who are committed to improving workflow technology.
 *
 * This file is part of YAWL. YAWL is free software: you can
 * redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation.
 *
 * YAWL is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
 * Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with YAWL. If not, see <http://www.gnu.org/licenses/>.
 */

package org.yawlfoundation.yawl.integration.gateway.traefik;

import org.yawlfoundation.yawl.integration.gateway.GatewayCircuitBreakerConfig;
import org.yawlfoundation.yawl.integration.gateway.GatewayRouteDefinition;

import java.util.List;
import java.util.Objects;

/**
 * Generates Traefik v3 dynamic YAML configuration for YAWL API routing.
 *
 * <p>Produces a Traefik dynamic configuration file with:
 * <ul>
 *   <li>HTTP routers for each YAWL API route</li>
 *   <li>Per-route rate limiting middlewares (in-memory, suitable for single-instance;
 *       use Redis-backed rate limiting for multi-instance deployments)</li>
 *   <li>ForwardAuth middleware for OIDC token validation</li>
 *   <li>Circuit breaker middleware (Traefik expression language)</li>
 *   <li>Retry middleware for transient failures</li>
 *   <li>Headers middleware for security headers and CORS</li>
 * </ul>
 *
 * <h2>Usage</h2>
 * <pre>
 * {@code
 * String traefikYaml = TraefikConfigurationGenerator.generate(
 *     "http://yawl-engine:8080",
 *     "http://auth-service:8081/validate",
 *     GatewayCircuitBreakerConfig.traefikDefault()
 * );
 * Files.writeString(Path.of("traefik/dynamic/yawl.yml"), traefikYaml);
 * // Traefik watches this file via its file provider
 * }
 * </pre>
 *
 * <h2>Traefik Static Configuration Required</h2>
 * <pre>
 * # traefik.yml
 * providers:
 *   file:
 *     directory: /etc/traefik/dynamic/
 *     watch: true
 * entryPoints:
 *   web:
 *     address: ":80"
 *   websecure:
 *     address: ":443"
 * </pre>
 *
 * @author YAWL Foundation
 * @version 6.0.0
 * @since 6.0.0
 */
public final class TraefikConfigurationGenerator {

    private TraefikConfigurationGenerator() {
        throw new UnsupportedOperationException(
                "TraefikConfigurationGenerator is a utility class and cannot be instantiated.");
    }

    /**
     * Generate complete Traefik v3 dynamic YAML for YAWL API routing.
     *
     * @param upstreamBaseUrl      YAWL engine base URL
     * @param forwardAuthUrl       OIDC forward-auth service URL for token validation
     * @param circuitBreaker       circuit breaker configuration
     * @return Traefik dynamic configuration YAML string
     */
    public static String generate(String upstreamBaseUrl, String forwardAuthUrl,
                                  GatewayCircuitBreakerConfig circuitBreaker) {
        Objects.requireNonNull(upstreamBaseUrl, "upstreamBaseUrl must not be null");
        Objects.requireNonNull(forwardAuthUrl,  "forwardAuthUrl must not be null");
        Objects.requireNonNull(circuitBreaker,  "circuitBreaker must not be null");

        List<GatewayRouteDefinition> routes =
                GatewayRouteDefinition.yawlV1Routes(upstreamBaseUrl);

        StringBuilder yaml = new StringBuilder();
        yaml.append("# YAWL v6.0.0 Traefik v3 Dynamic Configuration\n");
        yaml.append("# Generated by TraefikConfigurationGenerator\n");
        yaml.append("# Place in Traefik dynamic configuration directory\n\n");

        appendHttpSection(yaml, routes, forwardAuthUrl, circuitBreaker, upstreamBaseUrl);

        return yaml.toString();
    }

    private static void appendHttpSection(StringBuilder yaml,
                                          List<GatewayRouteDefinition> routes,
                                          String forwardAuthUrl,
                                          GatewayCircuitBreakerConfig cb,
                                          String upstreamBaseUrl) {
        yaml.append("http:\n\n");

        appendRouters(yaml, routes);
        appendMiddlewares(yaml, routes, forwardAuthUrl, cb);
        appendServices(yaml, upstreamBaseUrl);
    }

    private static void appendRouters(StringBuilder yaml,
                                      List<GatewayRouteDefinition> routes) {
        yaml.append("  routers:\n");
        for (GatewayRouteDefinition route : routes) {
            String rule = buildTraefikRule(route);
            yaml.append("    ").append(route.getRouteId()).append(":\n");
            yaml.append("      rule: \"").append(rule).append("\"\n");
            yaml.append("      service: yawl-engine\n");
            yaml.append("      entryPoints:\n");
            yaml.append("        - websecure\n");

            // Build middleware chain
            yaml.append("      middlewares:\n");
            if (route.isRequiresAuthentication()) {
                yaml.append("        - yawl-forward-auth\n");
            }
            yaml.append("        - yawl-rate-").append(route.getRateLimitTier().name().toLowerCase())
                .append("\n");
            yaml.append("        - yawl-circuit-breaker\n");
            yaml.append("        - yawl-security-headers\n");
            yaml.append("        - yawl-retry\n");
            yaml.append("      tls: {}\n\n");
        }
    }

    private static void appendMiddlewares(StringBuilder yaml,
                                          List<GatewayRouteDefinition> routes,
                                          String forwardAuthUrl,
                                          GatewayCircuitBreakerConfig cb) {
        yaml.append("  middlewares:\n\n");

        // ForwardAuth middleware (OIDC token validation)
        yaml.append("    yawl-forward-auth:\n");
        yaml.append("      forwardAuth:\n");
        yaml.append("        address: \"").append(forwardAuthUrl).append("\"\n");
        yaml.append("        authResponseHeaders:\n");
        yaml.append("          - X-Auth-User\n");
        yaml.append("          - X-Auth-Roles\n");
        yaml.append("          - X-Auth-Email\n");
        yaml.append("        trustForwardHeader: false\n\n");

        // Rate limiting middlewares (one per tier)
        for (GatewayRouteDefinition.RateLimitTier tier : GatewayRouteDefinition.RateLimitTier.values()) {
            yaml.append("    yawl-rate-").append(tier.name().toLowerCase()).append(":\n");
            yaml.append("      rateLimit:\n");
            yaml.append("        average: ").append(tier.getRequestsPerWindow()).append("\n");
            yaml.append("        burst: ").append(tier.getRequestsPerWindow() * 2).append("\n");
            yaml.append("        period: 1m\n\n");
        }

        // Circuit breaker
        yaml.append("    yawl-circuit-breaker:\n");
        yaml.append("      circuitBreaker:\n");
        yaml.append("        expression: \"")
            .append(cb.getOpenExpression() != null
                    ? cb.getOpenExpression()
                    : "NetworkErrorRatio() > 0.30 || ResponseCodeRatio(500, 600, 0, 600) > 0.25")
            .append("\"\n");
        yaml.append("        checkPeriod: ").append(cb.getCheckPeriodSeconds()).append("s\n");
        yaml.append("        fallbackDuration: ").append(cb.getFallbackDurationSeconds()).append("s\n");
        yaml.append("        recoveryDuration: ").append(cb.getRecoveryDurationSeconds()).append("s\n\n");

        // Retry middleware
        yaml.append("    yawl-retry:\n");
        yaml.append("      retry:\n");
        yaml.append("        attempts: 2\n");
        yaml.append("        initialInterval: 100ms\n\n");

        // Security headers middleware
        yaml.append("    yawl-security-headers:\n");
        yaml.append("      headers:\n");
        yaml.append("        customResponseHeaders:\n");
        yaml.append("          X-Content-Type-Options: nosniff\n");
        yaml.append("          X-Frame-Options: DENY\n");
        yaml.append("          Referrer-Policy: strict-origin-when-cross-origin\n");
        yaml.append("          Cache-Control: no-store, no-cache\n");
        yaml.append("        customRequestHeaders:\n");
        yaml.append("          X-Forwarded-Proto: https\n");
        yaml.append("        stsSeconds: 31536000\n");
        yaml.append("        stsIncludeSubdomains: true\n");
        yaml.append("        stsPreload: true\n\n");
    }

    private static void appendServices(StringBuilder yaml, String upstreamBaseUrl) {
        yaml.append("  services:\n\n");
        yaml.append("    yawl-engine:\n");
        yaml.append("      loadBalancer:\n");
        yaml.append("        servers:\n");
        yaml.append("          - url: \"").append(upstreamBaseUrl).append("\"\n");
        yaml.append("        healthCheck:\n");
        yaml.append("          path: /yawl/actuator/health\n");
        yaml.append("          interval: 10s\n");
        yaml.append("          timeout: 5s\n");
        yaml.append("        passHostHeader: true\n");
    }

    private static String buildTraefikRule(GatewayRouteDefinition route) {
        String path = route.getPathPattern();
        // Convert {param} to PathRegexp
        boolean hasParam = path.contains("{");
        StringBuilder rule = new StringBuilder();

        if (hasParam) {
            String regexPath = path.replaceAll("\\{[^}]+}", "[^/]+")
                                   .replace("/", "\\/");
            rule.append("PathRegexp(`").append(regexPath).append("`)");
        } else if (path.endsWith("/**")) {
            rule.append("PathPrefix(`").append(path, 0, path.length() - 3).append("`)");
        } else {
            rule.append("Path(`").append(path).append("`)");
        }

        // Add method constraints
        if (!route.getMethods().isEmpty()) {
            rule.append(" && Method(");
            List<String> methodNames = route.getMethods().stream()
                    .map(m -> "`" + m.name() + "`").toList();
            rule.append(String.join(", ", methodNames));
            rule.append(")");
        }

        return rule.toString();
    }
}
