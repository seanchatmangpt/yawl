#!/usr/bin/env bash
# emit-docs.sh - Documentation generator library for YAWL Observatory
#
# This library provides functions to generate documentation for the observatory
# scripts, including README files, API documentation, and usage guides.
#
# Usage:
#   source scripts/observatory/lib/emit-docs.sh
#   emit_readme > README.md
#   emit_api_doc "collect_metrics" > docs/api/collect_metrics.md

set -euo pipefail

# Get the directory containing this script
LIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
OBSERVATORY_DIR="$(cd "${LIB_DIR}/.." && pwd)"
SCRIPTS_DIR="${OBSERVATORY_DIR}"
YAWL_ROOT="$(cd "${OBSERVATORY_DIR}/../.." && pwd)"

# Default configuration
DOC_OUTPUT_DIR="${DOC_OUTPUT_DIR:-${OBSERVATORY_DIR}/docs}"
DOC_FORMAT="${DOC_FORMAT:-markdown}"
DOC_INCLUDE_EXAMPLES="${DOC_INCLUDE_EXAMPLES:-true}"

#######################################
# Generate markdown documentation with proper formatting
# Arguments:
#   $1 - Title of the document
#   $2 - Content body (can be multi-line)
# Outputs:
#   Writes formatted markdown to stdout
#######################################
emit_markdown_doc() {
    local title="${1:?Error: title is required}"
    local content="${2:-}"
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    cat <<EOF
# ${title}

> Generated: ${timestamp}
> Format: ${DOC_FORMAT}

---

${content}

---

*This documentation was auto-generated by the YAWL Observatory documentation system.*
EOF
}

#######################################
# Generate the main README for the observatory
# Outputs:
#   Writes README content to stdout
#######################################
emit_readme() {
    local content
    content=$(cat <<'HEREDOC'
## YAWL Observatory

A comprehensive monitoring and observability toolkit for the YAWL workflow engine. The observatory provides real-time metrics collection, performance analysis, and operational insights.

### What the Observatory Does

The YAWL Observatory monitors workflow execution across multiple dimensions:

- **Performance Metrics**: Track workflow execution times, throughput, and latency
- **Resource Utilization**: Monitor memory, CPU, and thread pool usage
- **Workflow Health**: Detect failed tasks, timeouts, and bottlenecks
- **Pattern Analysis**: Analyze control-flow patterns and their performance characteristics
- **Compliance Tracking**: Verify workflow specifications against defined schemas

### Available Scripts

| Script | Purpose | Usage |
|--------|---------|-------|
| `collect-metrics.sh` | Collect performance and health metrics | `./collect-metrics.sh [--output FORMAT]` |
| `analyze-patterns.sh` | Analyze control-flow pattern usage | `./analyze-patterns.sh [--spec PATH]` |
| `health-check.sh` | Run comprehensive health checks | `./health-check.sh [--verbose]` |
| `emit-report.sh` | Generate formatted reports | `./emit-report.sh [--type TYPE]` |
| `validate-schema.sh` | Validate XML specifications | `./validate-schema.sh [SPEC_FILE]` |

### How to Use Each Script

#### collect-metrics.sh
Collects real-time metrics from the YAWL engine and outputs them in various formats.

```bash
# Basic usage - output to stdout in JSON format
./collect-metrics.sh

# Output to file in CSV format
./collect-metrics.sh --output csv --file metrics.csv

# Continuous collection with interval
./collect-metrics.sh --interval 30 --duration 300

# Filter specific metric types
./collect-metrics.sh --filter "performance,memory"
```

#### analyze-patterns.sh
Analyzes workflow specifications to identify control-flow patterns and their usage.

```bash
# Analyze a specific specification file
./analyze-patterns.sh --spec /path/to/specification.xml

# Analyze all specifications in a directory
./analyze-patterns.sh --directory /path/to/specs/

# Output pattern statistics
./analyze-patterns.sh --stats --output json
```

#### health-check.sh
Performs comprehensive health checks on the YAWL engine and infrastructure.

```bash
# Run all health checks
./health-check.sh

# Verbose output with detailed diagnostics
./health-check.sh --verbose

# Check specific components only
./health-check.sh --components engine,database,h2

# Output in machine-readable format
./health-check.sh --output json
```

#### emit-report.sh
Generates formatted reports from collected metrics and analysis results.

```bash
# Generate summary report
./emit-report.sh --type summary

# Generate detailed performance report
./emit-report.sh --type performance --period weekly

# Export to HTML format
./emit-report.sh --type full --format html --output report.html
```

#### validate-schema.sh
Validates XML workflow specifications against XSD schemas.

```bash
# Validate a single specification
./validate-schema.sh specification.xml

# Validate against specific schema version
./validate-schema.sh --schema-version 4.0 specification.xml

# Batch validation with error reporting
./validate-schema.sh --batch ./specs/ --report validation-report.json
```

### Configuration Options

Configuration is managed through environment variables and optional config files.

#### Environment Variables

| Variable | Default | Description |
|----------|---------|-------------|
| `YAWL_HOME` | `/opt/yawl` | YAWL installation directory |
| `OBSERVATORY_LOG_LEVEL` | `INFO` | Logging level (DEBUG, INFO, WARN, ERROR) |
| `OBSERVATORY_OUTPUT_FORMAT` | `json` | Default output format |
| `OBSERVATORY_METRICS_INTERVAL` | `60` | Collection interval in seconds |
| `OBSERVATORY_DB_URL` | `jdbc:h2:./yawl` | Database connection URL |
| `DOC_OUTPUT_DIR` | `./docs` | Documentation output directory |
| `DOC_FORMAT` | `markdown` | Documentation format |
| `DOC_INCLUDE_EXAMPLES` | `true` | Include examples in generated docs |

#### Configuration File

Create `observatory.conf` in the observatory directory:

```properties
# Observatory Configuration
metrics.enabled=true
metrics.retention_days=30
metrics.storage_path=/var/lib/yawl/metrics

alerts.enabled=true
alerts.email=admin@example.com
alerts.threshold.cpu=80
alerts.threshold.memory=90

reports.schedule=cron:0 0 * * *
reports.format=html
```

### Output Formats

The observatory supports multiple output formats:

- **JSON**: Structured data for programmatic consumption
- **CSV**: Tabular data for spreadsheet import
- **HTML**: Human-readable reports with styling
- **Markdown**: Documentation-friendly format
- **Prometheus**: Metrics exposition format for monitoring systems

Example format selection:

```bash
# JSON output (default)
./collect-metrics.sh --output json

# CSV for data analysis
./collect-metrics.sh --output csv --delimiter ","

# HTML report
./emit-report.sh --format html --template corporate

# Prometheus exposition format
./collect-metrics.sh --output prometheus --port 9090
```

### Integration with CI/CD

The observatory integrates seamlessly with CI/CD pipelines for automated monitoring and quality gates.

#### GitHub Actions

```yaml
name: YAWL Observatory Check
on: [push, pull_request]

jobs:
  observatory:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup YAWL
        run: |
          mvn clean compile

      - name: Run Health Check
        run: ./scripts/observatory/health-check.sh --output json > health-report.json

      - name: Validate Specifications
        run: ./scripts/observatory/validate-schema.sh --batch ./specs/

      - name: Collect Metrics
        run: ./scripts/observatory/collect-metrics.sh --output prometheus

      - name: Upload Reports
        uses: actions/upload-artifact@v4
        with:
          name: observatory-reports
          path: |
            health-report.json
            metrics/
```

#### Jenkins Pipeline

```groovy
pipeline {
    agent any

    stages {
        stage('Build') {
            steps {
                sh 'mvn clean compile'
            }
        }

        stage('Observatory Health Check') {
            steps {
                sh '''
                    ./scripts/observatory/health-check.sh --output junit > health-check.xml
                    ./scripts/observatory/validate-schema.sh --batch ./specs/
                '''
            }
            post {
                always {
                    junit 'health-check.xml'
                }
            }
        }

        stage('Collect Metrics') {
            steps {
                sh './scripts/observatory/collect-metrics.sh --output json --file metrics.json'
                archiveArtifacts artifacts: 'metrics.json', fingerprint: true
            }
        }
    }

    post {
        failure {
            mail to: 'team@example.com',
                 subject: "YAWL Observatory Alert: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                 body: 'Health check or validation failed. Check the build logs.'
        }
    }
}
```

#### GitLab CI

```yaml
stages:
  - build
  - observatory
  - report

build:
  stage: build
  script:
    - mvn clean compile

health_check:
  stage: observatory
  script:
    - ./scripts/observatory/health-check.sh --output json > health.json
    - ./scripts/observatory/validate-schema.sh --batch ./specs/
  artifacts:
    paths:
      - health.json
    expire_in: 1 week

metrics_collection:
  stage: observatory
  script:
    - ./scripts/observatory/collect-metrics.sh --output prometheus > metrics.prom
  artifacts:
    paths:
      - metrics.prom

generate_report:
  stage: report
  script:
    - ./scripts/observatory/emit-report.sh --type full --format html --output report.html
  artifacts:
    paths:
      - report.html
```

### Quick Start

1. **Prerequisites**: Ensure Maven and Java 25+ are installed
2. **Build**: Run `mvn clean compile` in the YAWL root directory
3. **Health Check**: Run `./scripts/observatory/health-check.sh` to verify setup
4. **Collect Metrics**: Run `./scripts/observatory/collect-metrics.sh` to start monitoring
5. **Generate Reports**: Run `./scripts/observatory/emit-report.sh` for insights

### Library Functions

This documentation library provides reusable functions:

- `emit_markdown_doc` - Generate formatted markdown documents
- `emit_api_doc` - Document individual functions
- `emit_usage` - Generate usage documentation with examples

### Support

For issues and feature requests, please use the project issue tracker.

### License

Part of the YAWL Foundation project.
HEREDOC
)

    emit_markdown_doc "YAWL Observatory Documentation" "${content}"
}

#######################################
# Generate API documentation for a specific function
# Arguments:
#   $1 - Function name to document
#   $2 - Script file containing the function (optional)
# Outputs:
#   Writes API documentation to stdout
#######################################
emit_api_doc() {
    local function_name="${1:?Error: function name is required}"
    local script_file="${2:-}"
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Build documentation content based on function name
    local description=""
    local syntax=""
    local arguments=""
    local returns=""
    local examples=""
    local see_also=""

    case "${function_name}" in
        collect_metrics)
            description="Collects performance and health metrics from the YAWL workflow engine. This function gathers data on execution times, throughput, resource utilization, and workflow health indicators."
            syntax="collect_metrics [OPTIONS]"
            arguments=$(cat <<'EOF'
### Arguments

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `--output` | string | `json` | Output format: json, csv, prometheus |
| `--file` | string | stdout | Output file path |
| `--interval` | number | 60 | Collection interval in seconds |
| `--duration` | number | 0 | Total collection duration (0 = infinite) |
| `--filter` | string | all | Comma-separated metric categories |
| `--verbose` | flag | false | Enable verbose logging |
EOF
)
            returns=$(cat <<'EOF'
### Return Value

Returns a structured data object containing:

- **timestamp**: ISO 8601 timestamp of collection
- **metrics**: Array of metric objects
  - `name`: Metric identifier
  - `value`: Numeric value
  - `unit`: Measurement unit
  - `tags`: Additional metadata
- **status`: Collection status (success/partial/failure)
- **errors`: Array of error messages if any

### Exit Codes

| Code | Meaning |
|------|---------|
| 0 | Success |
| 1 | General error |
| 2 | Configuration error |
| 3 | Connection error |
EOF
)
            examples=$(cat <<'EOF'
### Examples

```bash
# Basic metric collection
collect_metrics

# JSON output to file
collect_metrics --output json --file /var/log/yawl/metrics.json

# Continuous collection with filtering
collect_metrics --interval 30 --filter "performance,memory" --verbose

# Prometheus exposition format
collect_metrics --output prometheus --port 9090
```
EOF
)
            see_also="analyze_patterns, health_check, emit_report"
            ;;

        analyze_patterns)
            description="Analyzes YAWL workflow specifications to identify and report on control-flow pattern usage. This function parses specification files and extracts pattern statistics."
            syntax="analyze_patterns [OPTIONS]"
            arguments=$(cat <<'EOF'
### Arguments

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `--spec` | string | - | Single specification file to analyze |
| `--directory` | string | - | Directory containing specifications |
| `--output` | string | `json` | Output format |
| `--stats` | flag | false | Include aggregate statistics |
| `--deep` | flag | false | Perform deep analysis |
EOF
)
            returns=$(cat <<'EOF'
### Return Value

Returns analysis results containing:

- **specification**: Analyzed specification name
- **patterns**: Detected pattern objects
  - `type`: Pattern category (sequence, split, join, etc.)
  - `count`: Occurrences found
  - `locations`: XPath locations in spec
- **statistics**: Aggregate metrics
  - `total_patterns`: Sum of all patterns
  - `complexity_score`: Calculated complexity
  - `coverage`: Pattern coverage percentage
EOF
)
            examples=$(cat <<'EOF'
### Examples

```bash
# Analyze single specification
analyze_patterns --spec workflow.xml

# Batch analysis with statistics
analyze_patterns --directory ./specs/ --stats --output json

# Deep analysis for complex workflows
analyze_patterns --spec complex.xml --deep --verbose
```
EOF
)
            see_also="validate_schema, collect_metrics"
            ;;

        health_check)
            description="Performs comprehensive health checks on the YAWL engine and related infrastructure components. Validates connectivity, resource availability, and operational status."
            syntax="health_check [OPTIONS]"
            arguments=$(cat <<'EOF'
### Arguments

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `--components` | string | all | Comma-separated components to check |
| `--output` | string | `text` | Output format |
| `--verbose` | flag | false | Detailed diagnostics |
| `--timeout` | number | 30 | Check timeout in seconds |
EOF
)
            returns=$(cat <<'EOF'
### Return Value

Returns health check results:

- **status**: Overall health (healthy/degraded/unhealthy)
- **timestamp**: Check execution time
- **components**: Array of component results
  - `name`: Component identifier
  - `status`: Component health status
  - `latency_ms`: Response time
  - `details`: Additional information
- **recommendations**: Suggested actions if issues found
EOF
)
            examples=$(cat <<'EOF'
### Examples

```bash
# Full health check
health_check

# Check specific components
health_check --components engine,database,h2

# JSON output for monitoring systems
health_check --output json --verbose

# CI/CD integration with timeout
health_check --output junit --timeout 60 > health.xml
```
EOF
)
            see_also="collect_metrics, validate_schema"
            ;;

        emit_report)
            description="Generates formatted reports from collected metrics, health checks, and analysis results. Supports multiple output formats suitable for various audiences."
            syntax="emit_report [OPTIONS]"
            arguments=$(cat <<'EOF'
### Arguments

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `--type` | string | `summary` | Report type: summary, performance, full |
| `--format` | string | `markdown` | Output format: md, html, pdf |
| `--period` | string | `daily` | Report period: daily, weekly, monthly |
| `--output` | string | stdout | Output file path |
| `--template` | string | default | Report template name |
EOF
)
            returns=$(cat <<'EOF'
### Return Value

Returns the generated report content in the specified format.

### Report Types

| Type | Description |
|------|-------------|
| `summary` | High-level overview with key metrics |
| `performance` | Detailed performance analysis |
| `compliance` | Schema validation and standards compliance |
| `full` | Comprehensive report with all sections |
EOF
)
            examples=$(cat <<'EOF'
### Examples

```bash
# Generate summary report
emit_report --type summary

# Weekly performance report in HTML
emit_report --type performance --period weekly --format html --output report.html

# Full compliance report
emit_report --type compliance --format pdf --template corporate
```
EOF
)
            see_also="collect_metrics, analyze_patterns, health_check"
            ;;

        validate_schema)
            description="Validates XML workflow specifications against YAWL XSD schemas. Ensures specifications conform to required structure and constraints."
            syntax="validate_schema [OPTIONS] SPEC_FILE"
            arguments=$(cat <<'EOF'
### Arguments

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `SPEC_FILE` | string | - | Specification file to validate |
| `--schema-version` | string | `4.0` | XSD schema version |
| `--batch` | string | - | Directory for batch validation |
| `--report` | string | - | Output report file path |
| `--strict` | flag | false | Enable strict validation |
EOF
)
            returns=$(cat <<'EOF'
### Return Value

Returns validation results:

- **valid**: Boolean indicating overall validity
- **file`: Validated file path
- **errors**: Array of validation errors
  - `line`: Line number
  - `column`: Column number
  - `message`: Error description
  - `severity`: Error level
- **warnings**: Non-fatal issues found
EOF
)
            examples=$(cat <<'EOF'
### Examples

```bash
# Validate single specification
validate_schema workflow.xml

# Batch validation with report
validate_schema --batch ./specs/ --report validation-report.json

# Strict validation against specific schema
validate_schema --schema-version 4.0 --strict workflow.xml
```
EOF
)
            see_also="analyze_patterns, health_check"
            ;;

        *)
            description="Custom function: ${function_name}"
            syntax="${function_name} [OPTIONS]"
            arguments="### Arguments\n\n| Option | Type | Default | Description |\n|--------|------|---------|-------------|\n| `--help` | flag | - | Show help message |"
            returns="### Return Value\n\nReturns function execution result."
            examples="### Examples\n\n```bash\n${function_name} --help\n```"
            see_also=""
            ;;
    esac

    cat <<EOF
# API Reference: ${function_name}

> Generated: ${timestamp}

## Description

${description}

## Syntax

\`\`\`bash
${syntax}
\`\`\`

${arguments}

${returns}

${examples}

EOF

    if [[ -n "${see_also}" ]]; then
        echo "## See Also"
        echo ""
        echo "${see_also}"
        echo ""
    fi

    cat <<EOF
---

*Auto-generated by YAWL Observatory documentation system.*
EOF
}

#######################################
# Generate usage documentation with examples
# Arguments:
#   $1 - Script name (optional, generates for all if not specified)
# Outputs:
#   Writes usage documentation to stdout
#######################################
emit_usage() {
    local script_name="${1:-}"
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    local header="# YAWL Observatory Usage Guide\n\n> Generated: ${timestamp}\n\n"

    local common_options=$(cat <<'EOF'
## Common Options

All observatory scripts support these common options:

| Option | Description |
|--------|-------------|
| `-h, --help` | Display help message and exit |
| `-v, --verbose` | Enable verbose output |
| `-q, --quiet` | Suppress non-essential output |
| `--version` | Display version information |
| `--config FILE` | Use specified configuration file |
| `--log-level LEVEL` | Set logging level |
| `--output FORMAT` | Set output format |

EOF
)

    local environment_vars=$(cat <<'EOF'
## Environment Variables

### Core Configuration

```bash
# YAWL installation directory
export YAWL_HOME=/opt/yawl

# Logging configuration
export OBSERVATORY_LOG_LEVEL=INFO
export OBSERVATORY_LOG_FILE=/var/log/yawl/observatory.log

# Output configuration
export OBSERVATORY_OUTPUT_FORMAT=json
export OBSERVATORY_OUTPUT_DIR=/var/lib/yawl/output

# Database configuration
export OBSERVATORY_DB_URL=jdbc:h2:./yawl
export OBSERVATORY_DB_USER=sa
export OBSERVATORY_DB_PASSWORD=
```

### Metrics Collection

```bash
# Collection settings
export OBSERVATORY_METRICS_INTERVAL=60
export OBSERVATORY_METRICS_RETENTION=30
export OBSERVATORY_METRICS_STORAGE=/var/lib/yawl/metrics

# Filtering
export OBSERVATORY_METRICS_FILTER=performance,memory,threads
```

### Alerting

```bash
# Alert configuration
export OBSERVATORY_ALERTS_ENABLED=true
export OBSERVATORY_ALERTS_EMAIL=admin@example.com
export OBSERVATORY_ALERTS_WEBHOOK=https://hooks.example.com/alert
```

EOF
)

    local usage_examples
    if [[ -n "${script_name}" ]]; then
        usage_examples=$(cat <<EOF
## Usage: ${script_name}

EOF
)
        case "${script_name}" in
            collect-metrics.sh)
                usage_examples+=$(cat <<'EOF'
### Basic Usage

```bash
# Collect metrics once
./collect-metrics.sh

# Collect with JSON output
./collect-metrics.sh --output json

# Continuous collection
./collect-metrics.sh --interval 30 --duration 300
```

### Advanced Usage

```bash
# Filter specific metrics
./collect-metrics.sh --filter "performance,workflow" --output json

# Output to Prometheus format
./collect-metrics.sh --output prometheus | curl -X POST http://pushgateway:9091/metrics/job/yawl

# Collect with custom configuration
./collect-metrics.sh --config /etc/yawl/metrics.conf --verbose
```

### Integration Example

```bash
# Send metrics to monitoring system
./collect-metrics.sh --output json | jq '.metrics' | \
  curl -H "Content-Type: application/json" \
       -d @- http://monitoring.example.com/api/v1/metrics
```
EOF
)
                ;;
            health-check.sh)
                usage_examples+=$(cat <<'EOF'
### Basic Usage

```bash
# Run all health checks
./health-check.sh

# Verbose output
./health-check.sh --verbose

# JSON output for monitoring
./health-check.sh --output json
```

### Component-Specific Checks

```bash
# Check only engine component
./health-check.sh --components engine

# Check multiple components
./health-check.sh --components engine,database,h2 --verbose

# Database connectivity check
./health-check.sh --components database --timeout 10
```

### CI/CD Integration

```bash
# Generate JUnit XML for CI systems
./health-check.sh --output junit > health-check.xml

# Exit with error on unhealthy status
./health-check.sh --fail-on-error
```
EOF
)
                ;;
            *)
                usage_examples+=$(cat <<'EOF'
### Basic Usage

```bash
# Show help
./SCRIPT_NAME --help

# Run with defaults
./SCRIPT_NAME

# Verbose mode
./SCRIPT_NAME --verbose
```

Refer to the script's help output for specific options.
EOF
)
                ;;
        esac
    else
        usage_examples=$(cat <<'EOF'
## Usage Examples by Script

### collect-metrics.sh

Collect performance and health metrics from the YAWL engine.

```bash
# Basic collection
./collect-metrics.sh

# Continuous monitoring
./collect-metrics.sh --interval 60 --duration 3600

# Filtered output
./collect-metrics.sh --filter performance --output json
```

### health-check.sh

Perform comprehensive health checks.

```bash
# Full health check
./health-check.sh

# Component-specific check
./health-check.sh --components engine --output json

# CI/CD integration
./health-check.sh --output junit > health.xml
```

### analyze-patterns.sh

Analyze workflow control-flow patterns.

```bash
# Analyze specification
./analyze-patterns.sh --spec workflow.xml

# Batch analysis
./analyze-patterns.sh --directory ./specs/ --stats
```

### emit-report.sh

Generate formatted reports.

```bash
# Summary report
./emit-report.sh --type summary

# Full HTML report
./emit-report.sh --type full --format html --output report.html
```

### validate-schema.sh

Validate XML specifications.

```bash
# Validate single file
./validate-schema.sh workflow.xml

# Batch validation
./validate-schema.sh --batch ./specs/ --report results.json
```

EOF
)
    fi

    local troubleshooting=$(cat <<'EOF'
## Troubleshooting

### Common Issues

#### Connection Refused

```bash
# Check YAWL engine is running
curl http://localhost:8080/yawl/health

# Verify port availability
netstat -tuln | grep 8080
```

#### Permission Denied

```bash
# Ensure scripts are executable
chmod +x scripts/observatory/*.sh

# Check file ownership
ls -la scripts/observatory/
```

#### Configuration Not Found

```bash
# Verify configuration file exists
ls -la observatory.conf

# Use explicit config path
./collect-metrics.sh --config /path/to/observatory.conf
```

### Debug Mode

Enable debug logging for detailed diagnostics:

```bash
# Enable debug mode
export OBSERVATORY_LOG_LEVEL=DEBUG

# Run with verbose output
./collect-metrics.sh --verbose --log-level DEBUG
```

### Getting Help

```bash
# Script help
./SCRIPT_NAME --help

# Version information
./SCRIPT_NAME --version
```

EOF
)

    cat <<EOF
${header}
${common_options}
${environment_vars}
${usage_examples}
${troubleshooting}
---

*Auto-generated by YAWL Observatory documentation system.*
EOF
}

#######################################
# Generate table of contents from document structure
# Arguments:
#   $1 - Document content (markdown format)
# Outputs:
#   Writes table of contents to stdout
#######################################
emit_toc() {
    local content="${1:-}"

    echo "## Table of Contents"
    echo ""

    # Extract headers and generate TOC entries
    echo "${content}" | grep -E '^#{1,3} ' | while IFS= read -r line; do
        local level
        level=$(echo "${line}" | sed 's/[^#]//g' | wc -c)
        level=$((level - 1))

        local title
        title=$(echo "${line}" | sed 's/^#* //')

        local anchor
        anchor=$(echo "${title}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/-$//' | sed 's/^-//')

        local indent=""
        case ${level} in
            2) indent="  " ;;
            3) indent="    " ;;
            4) indent="      " ;;
        esac

        echo "${indent}- [${title}](#${anchor})"
    done
    echo ""
}

#######################################
# Main entry point for CLI usage
# Arguments:
#   All command line arguments
# Outputs:
#   Writes generated documentation to stdout
#######################################
main() {
    local command="${1:-help}"
    shift || true

    case "${command}" in
        doc|markdown)
            local title="${1:-Documentation}"
            local content="${2:-}"
            if [[ -z "${content}" ]] && [[ ! -t 0 ]]; then
                content=$(cat)
            fi
            emit_markdown_doc "${title}" "${content}"
            ;;
        readme)
            emit_readme
            ;;
        api)
            local func_name="${1:?Error: function name required}"
            local script_file="${2:-}"
            emit_api_doc "${func_name}" "${script_file}"
            ;;
        usage)
            local script="${1:-}"
            emit_usage "${script}"
            ;;
        toc)
            local content
            if [[ ! -t 0 ]]; then
                content=$(cat)
            else
                content="${1:-}"
            fi
            emit_toc "${content}"
            ;;
        help|--help|-h)
            cat <<'EOF'
emit-docs.sh - Documentation generator library for YAWL Observatory

Usage:
  source emit-docs.sh                          # Load as library
  emit-docs.sh readme                          # Generate README
  emit-docs.sh api <function>                  # Generate API docs
  emit-docs.sh usage [script]                  # Generate usage docs
  emit-docs.sh doc <title> [content]           # Generate markdown doc
  emit-docs.sh toc < content.md                # Generate table of contents

Commands:
  readme       Generate main README for observatory
  api          Generate API documentation for a function
  usage        Generate usage documentation
  doc          Generate custom markdown document
  toc          Generate table of contents from markdown

Environment Variables:
  DOC_OUTPUT_DIR       Output directory for generated docs
  DOC_FORMAT           Documentation format (default: markdown)
  DOC_INCLUDE_EXAMPLES Include examples in docs (default: true)

Examples:
  # Generate README
  ./emit-docs.sh readme > README.md

  # Generate API docs for collect_metrics
  ./emit-docs.sh api collect_metrics > docs/api/collect_metrics.md

  # Generate usage guide
  ./emit-docs.sh usage collect-metrics.sh > docs/usage/collect-metrics.md

  # Generate custom document
  echo "Content here" | ./emit-docs.sh doc "My Title" -

EOF
            ;;
        *)
            echo "Unknown command: ${command}" >&2
            echo "Run 'emit-docs.sh help' for usage information." >&2
            exit 1
            ;;
    esac
}

# Run main if executed directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
