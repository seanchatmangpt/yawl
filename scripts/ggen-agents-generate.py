#!/usr/bin/env python3
"""
GGEN Agent Generator — Generate A2A & MCP implementations from Turtle ontologies
Converts: ontology/agents/*.ttl + templates → generated Java implementations
"""

import json
import sys
import os
from pathlib import Path
from datetime import datetime
from rdflib import Graph, Namespace, RDF, RDFS
from jinja2 import Environment, FileSystemLoader, select_autoescape

def load_ttl(ttl_file):
    """Load RDF Turtle file and parse"""
    g = Graph()
    g.parse(ttl_file, format='turtle')
    return g

def extract_agents(graph):
    """Extract agent definitions from RDF graph"""
    A2A = Namespace("http://yawl.io/a2a#")
    agents = []

    for agent in graph.subjects(RDF.type, A2A.Agent):
        agent_data = {
            'uri': str(agent),
            'id': str(agent).split('#')[-1],
            'name': str(graph.value(agent, RDFS.label, default='')),
            'description': str(graph.value(agent, RDFS.comment, default='')),
            'protocol': str(graph.value(agent, A2A.hasProtocol, default='')),
            'messaging_style': str(graph.value(agent, A2A.messagingStyle, default='')),
            'concurrency': str(graph.value(agent, A2A.concurrency, default='')),
            'mcp_server': str(graph.value(agent, A2A.hasMCPServer, default='')),
            'endpoints': []
        }

        # Extract endpoints
        for endpoint in graph.objects(agent, A2A.endpoint):
            endpoint_data = {
                'name': str(graph.value(endpoint, A2A.name, default='')),
                'method': str(graph.value(endpoint, A2A.method, default='')).split('#')[-1],
                'message_type': str(graph.value(endpoint, A2A.messageType, default='')).split('#')[-1],
                'response_time': int(graph.value(endpoint, A2A.responseTime, default=0))
            }
            agent_data['endpoints'].append(endpoint_data)

        agents.append(agent_data)

    return agents

def extract_tools(graph):
    """Extract MCP tool definitions from RDF graph"""
    MCP = Namespace("http://yawl.io/mcp#")
    tools = []

    for tool in graph.subjects(RDF.type, MCP.Tool):
        tool_data = {
            'uri': str(tool),
            'id': str(tool).split('#')[-1],
            'name': str(graph.value(tool, RDFS.label, default='')),
            'description': str(graph.value(tool, RDFS.comment, default='')),
            'server': str(graph.value(tool, MCP.server, default=''))
        }
        tools.append(tool_data)

    return tools

def generate_agent_factory(agents, output_file):
    """Generate AgentFactory.java from agent data"""
    newline = '\n'
    agent_puts = newline.join(f'        AGENTS.put("{agent["id"].lower()}", null); // {agent["name"]}' for agent in agents)
    agent_appends = newline.join(f'        sb.append("  {agent["id"].ljust(25)} | Role: {agent["name"]}\\n");' for agent in agents)
    timestamp = datetime.now().isoformat()

    content = f"""// AUTO-GENERATED by ggen from a2a-protocols.ttl
// Generated: {Path.cwd()}
// Time: {timestamp}

package org.yawl.integration.agents;

import org.yawl.integration.mcp.*;
import org.yawl.integration.a2a.*;
import java.util.*;
import java.time.Instant;
import java.util.concurrent.*;

/**
 * AgentFactory — Auto-generated from Turtle RDF ontologies
 * {len(agents)} agents configured
 */
public class AgentFactory {{

    private static final Map<String, Agent> AGENTS = new ConcurrentHashMap<>();

    static {{
        // Agent Registry
{agent_puts}
    }}

    public static Collection<Agent> getAllAgents() {{
        return AGENTS.values();
    }}

    public static Agent getAgent(String id) {{
        return AGENTS.get(id.toLowerCase());
    }}

    public static int getAgentCount() {{
        return AGENTS.size();
    }}

    public static String getAgentsInfo() {{
        StringBuilder sb = new StringBuilder();
        sb.append("=== YAWL Agent Registry ===\\n");
        sb.append("Total Agents: ").append(AGENTS.size()).append("\\n\\n");
{agent_appends}
        return sb.toString();
    }}
}}
"""
    with open(output_file, 'w') as f:
        f.write(content)
    print(f"✓ Generated: {output_file}")

def generate_protocol_specs(agents, output_file):
    """Generate protocol specifications JSON"""
    specs = {
        'version': '1.0',
        'timestamp': datetime.now().isoformat(),
        'agents': agents
    }
    with open(output_file, 'w') as f:
        json.dump(specs, f, indent=2)
    print(f"✓ Generated: {output_file}")

def generate_agent_configs(agents, output_dir):
    """Generate per-agent configuration files"""
    Path(output_dir).mkdir(parents=True, exist_ok=True)

    for agent in agents:
        config = {
            'id': agent['id'],
            'name': agent['name'],
            'description': agent['description'],
            'protocol': agent['protocol'],
            'mcp_server': agent['mcp_server'],
            'endpoints': agent['endpoints']
        }
        config_file = Path(output_dir) / f"{agent['id'].lower()}-config.json"
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=2)
        print(f"✓ Generated: {config_file}")

def main():
    # Paths
    ttl_protocols = Path('ontology/agents/a2a-protocols.ttl')
    ttl_tools = Path('ontology/agents/mcp-tools.ttl')
    output_dir = Path('generated/agents')
    output_dir.mkdir(parents=True, exist_ok=True)

    print(f"\n{'='*70}")
    print("GGEN Agent Generator — A2A & MCP Protocol Implementation")
    print(f"{'='*70}\n")

    # Load RDF graphs
    print(f"[1/5] Loading Turtle ontologies...")
    graph_protocols = load_ttl(ttl_protocols)
    graph_tools = load_ttl(ttl_tools)
    print(f"  ✓ Loaded {len(graph_protocols)} triples from {ttl_protocols}")
    print(f"  ✓ Loaded {len(graph_tools)} triples from {ttl_tools}")

    # Extract entities
    print(f"\n[2/5] Extracting agent definitions...")
    agents = extract_agents(graph_protocols)
    print(f"  ✓ Extracted {len(agents)} agent definitions:")
    for agent in agents:
        print(f"      • {agent['id'].ljust(25)} - {agent['name']}")
        print(f"        Endpoints: {len(agent['endpoints'])}, Server: {agent['mcp_server']}")

    print(f"\n[3/5] Extracting MCP tool definitions...")
    tools = extract_tools(graph_tools)
    print(f"  ✓ Extracted {len(tools)} MCP tool definitions:")
    for tool in tools[:5]:
        print(f"      • {tool['id']}")
    if len(tools) > 5:
        print(f"      ... and {len(tools) - 5} more")

    # Generate implementations
    print(f"\n[4/5] Generating implementation artifacts...")
    generate_agent_factory(agents, output_dir / 'AgentFactory.java')
    generate_protocol_specs(agents, output_dir / 'agent-protocols-spec.json')
    generate_agent_configs(agents, output_dir / 'configs')

    # Summary
    print(f"\n[5/5] Generation complete!")
    print(f"\n{'='*70}")
    print(f"Generated Artifacts:")
    print(f"  • AgentFactory.java (central agent registry)")
    print(f"  • agent-protocols-spec.json (protocol specifications)")
    print(f"  • configs/ (per-agent configuration files)")
    print(f"\nAgent Summary:")
    print(f"  • Total agents: {len(agents)}")
    print(f"  • Total MCP tools: {len(tools)}")
    print(f"  • Total endpoints: {sum(len(a['endpoints']) for a in agents)}")
    print(f"  • Output directory: {output_dir}")
    print(f"{'='*70}\n")

    return 0

if __name__ == '__main__':
    sys.exit(main())
